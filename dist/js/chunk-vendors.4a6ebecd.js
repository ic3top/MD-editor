(window.webpackJsonp = window.webpackJsonp || []).push([['chunk-vendors'], {
  '00ee': function (e, t, n) { const r = n('b622'); const i = r('toStringTag'); const o = {}; o[i] = 'z', e.exports = String(o) === '[object z]'; },
  '0366': function (e, t, n) { const r = n('1c0b'); e.exports = function (e, t, n) { if (r(e), void 0 === t) return e; switch (n) { case 0: return function () { return e.call(t); }; case 1: return function (n) { return e.call(t, n); }; case 2: return function (n, r) { return e.call(t, n, r); }; case 3: return function (n, r, i) { return e.call(t, n, r, i); }; } return function () { return e.apply(t, arguments); }; }; },
  '06cf': function (e, t, n) { const r = n('83ab'); const i = n('d1e7'); const o = n('5c6c'); const a = n('fc6a'); const s = n('c04e'); const l = n('5135'); const c = n('0cfb'); const u = Object.getOwnPropertyDescriptor; t.f = r ? u : function (e, t) { if (e = a(e), t = s(t, !0), c) try { return u(e, t); } catch (n) {} if (l(e, t)) return o(!i.f.call(e, t), e[t]); }; },
  '098b': function (e, t, n) {},
  '0cfb': function (e, t, n) { const r = n('83ab'); const i = n('d039'); const o = n('cc12'); e.exports = !r && !i((() => Object.defineProperty(o('div'), 'a', { get() { return 7; } }).a != 7)); },
  '19aa': function (e, t) { e.exports = function (e, t, n) { if (!(e instanceof t)) throw TypeError(`Incorrect ${n ? `${n} ` : ''}invocation`); return e; }; },
  '1be4': function (e, t, n) { const r = n('d066'); e.exports = r('document', 'documentElement'); },
  '1c0b': function (e, t) { e.exports = function (e) { if (typeof e !== 'function') throw TypeError(`${String(e)} is not a function`); return e; }; },
  '1c7e': function (e, t, n) { const r = n('b622'); const i = r('iterator'); let o = !1; try { let a = 0; const s = { next() { return { done: !!a++ }; }, return() { o = !0; } }; s[i] = function () { return this; }, Array.from(s, (() => { throw 2; })); } catch (l) {}e.exports = function (e, t) { if (!t && !o) return !1; let n = !1; try { const r = {}; r[i] = function () { return { next() { return { done: n = !0 }; } }; }, e(r); } catch (l) {} return n; }; },
  '1cdc': function (e, t, n) { const r = n('342f'); e.exports = /(?:iphone|ipod|ipad).*applewebkit/i.test(r); },
  '1d80': function (e, t) { e.exports = function (e) { if (void 0 == e) throw TypeError(`Can't call method on ${e}`); return e; }; },
  '1fdb': function (e, t, n) {
    (function (e) { e(n('56b3')); }(((e) => {
      function t(t, n, r) {
        this.orientation = n, this.scroll = r, this.screen = this.total = this.size = 1, this.pos = 0, this.node = document.createElement('div'), this.node.className = `${t}-${n}`, this.inner = this.node.appendChild(document.createElement('div')); const i = this; function o(t) { const n = e.wheelEventPixels(t)[i.orientation == 'horizontal' ? 'x' : 'y']; const r = i.pos; i.moveTo(i.pos + n), i.pos != r && e.e_preventDefault(t); }e.on(this.inner, 'mousedown', ((t) => {
          if (t.which == 1) {
            e.e_preventDefault(t); var n = i.orientation == 'horizontal' ? 'pageX' : 'pageY'; var r = t[n]; var
              o = i.pos; e.on(document, 'mousemove', s), e.on(document, 'mouseup', a);
          } function a() { e.off(document, 'mousemove', s), e.off(document, 'mouseup', a); } function s(e) { if (e.which != 1) return a(); i.moveTo(o + (e[n] - r) * (i.total / i.size)); }
        })), e.on(this.node, 'click', ((t) => { e.e_preventDefault(t); let n; const r = i.inner.getBoundingClientRect(); n = i.orientation == 'horizontal' ? t.clientX < r.left ? -1 : t.clientX > r.right ? 1 : 0 : t.clientY < r.top ? -1 : t.clientY > r.bottom ? 1 : 0, i.moveTo(i.pos + n * i.screen); })), e.on(this.node, 'mousewheel', o), e.on(this.node, 'DOMMouseScroll', o);
      }t.prototype.setPos = function (e, t) { return e < 0 && (e = 0), e > this.total - this.screen && (e = this.total - this.screen), !(!t && e == this.pos) && (this.pos = e, this.inner.style[this.orientation == 'horizontal' ? 'left' : 'top'] = `${e * (this.size / this.total)}px`, !0); }, t.prototype.moveTo = function (e) { this.setPos(e) && this.scroll(e, this.orientation); }; const n = 10; function r(e, n, r) { this.addClass = e, this.horiz = new t(e, 'horizontal', r), n(this.horiz.node), this.vert = new t(e, 'vertical', r), n(this.vert.node), this.width = null; }t.prototype.update = function (e, t, r) { const i = this.screen != t || this.total != e || this.size != r; i && (this.screen = t, this.total = e, this.size = r); let o = this.screen * (this.size / this.total); o < n && (this.size -= n - o, o = n), this.inner.style[this.orientation == 'horizontal' ? 'width' : 'height'] = `${o}px`, this.setPos(this.pos, i); }, r.prototype.update = function (e) { if (this.width == null) { const t = window.getComputedStyle ? window.getComputedStyle(this.horiz.node) : this.horiz.node.currentStyle; t && (this.width = parseInt(t.height)); } const n = this.width || 0; const r = e.scrollWidth > e.clientWidth + 1; const i = e.scrollHeight > e.clientHeight + 1; return this.vert.node.style.display = i ? 'block' : 'none', this.horiz.node.style.display = r ? 'block' : 'none', i && (this.vert.update(e.scrollHeight, e.clientHeight, e.viewHeight - (r ? n : 0)), this.vert.node.style.bottom = r ? `${n}px` : '0'), r && (this.horiz.update(e.scrollWidth, e.clientWidth, e.viewWidth - (i ? n : 0) - e.barLeft), this.horiz.node.style.right = i ? `${n}px` : '0', this.horiz.node.style.left = `${e.barLeft}px`), { right: i ? n : 0, bottom: r ? n : 0 }; }, r.prototype.setScrollTop = function (e) { this.vert.setPos(e); }, r.prototype.setScrollLeft = function (e) { this.horiz.setPos(e); }, r.prototype.clear = function () { const e = this.horiz.node.parentNode; e.removeChild(this.horiz.node), e.removeChild(this.vert.node); }, e.scrollbarModel.simple = function (e, t) { return new r('CodeMirror-simplescroll', e, t); }, e.scrollbarModel.overlay = function (e, t) { return new r('CodeMirror-overlayscroll', e, t); };
    })));
  },
  2266(e, t, n) { const r = n('825a'); const i = n('e95a'); const o = n('50c4'); const a = n('0366'); const s = n('35a1'); const l = n('2a62'); const c = function (e, t) { this.stopped = e, this.result = t; }; e.exports = function (e, t, n) { let u; let f; let d; let h; let p; let m; let g; const v = n && n.that; const b = !(!n || !n.AS_ENTRIES); const y = !(!n || !n.IS_ITERATOR); const w = !(!n || !n.INTERRUPTED); const x = a(t, v, 1 + b + w); const k = function (e) { return u && l(u), new c(!0, e); }; const _ = function (e) { return b ? (r(e), w ? x(e[0], e[1], k) : x(e[0], e[1])) : w ? x(e, k) : x(e); }; if (y)u = e; else { if (f = s(e), typeof f !== 'function') throw TypeError('Target is not iterable'); if (i(f)) { for (d = 0, h = o(e.length); h > d; d++) if (p = _(e[d]), p && p instanceof c) return p; return new c(!1); }u = f.call(e); }m = u.next; while (!(g = m.call(u)).done) { try { p = _(g.value); } catch (C) { throw l(u), C; } if (typeof p === 'object' && p && p instanceof c) return p; } return new c(!1); }; },
  '23cb': function (e, t, n) { const r = n('a691'); const i = Math.max; const o = Math.min; e.exports = function (e, t) { const n = r(e); return n < 0 ? i(n + t, 0) : o(n, t); }; },
  '23e7': function (e, t, n) { const r = n('da84'); const i = n('06cf').f; const o = n('9112'); const a = n('6eeb'); const s = n('ce4e'); const l = n('e893'); const c = n('94ca'); e.exports = function (e, t) { let n; let u; let f; let d; let h; let p; const m = e.target; const g = e.global; const v = e.stat; if (u = g ? r : v ? r[m] || s(m, {}) : (r[m] || {}).prototype, u) for (f in t) { if (h = t[f], e.noTargetGet ? (p = i(u, f), d = p && p.value) : d = u[f], n = c(g ? f : m + (v ? '.' : '#') + f, e.forced), !n && void 0 !== d) { if (typeof h === typeof d) continue; l(h, d); }(e.sham || d && d.sham) && o(h, 'sham', !0), a(u, f, h, e); } }; },
  '241c': function (e, t, n) { const r = n('ca84'); const i = n('7839'); const o = i.concat('length', 'prototype'); t.f = Object.getOwnPropertyNames || function (e) { return r(e, o); }; },
  2626(e, t, n) {
    const r = n('d066'); const i = n('9bf2'); const o = n('b622'); const a = n('83ab'); const s = o('species'); e.exports = function (e) { const t = r(e); const n = i.f; a && t && !t[s] && n(t, s, { configurable: !0, get() { return this; } }); };
  },
  '2a62': function (e, t, n) { const r = n('825a'); e.exports = function (e) { const t = e.return; if (void 0 !== t) return r(t.call(e)).value; }; },
  '2cf4': function (e, t, n) { let r; let i; let o; const a = n('da84'); const s = n('d039'); const l = n('0366'); const c = n('1be4'); const u = n('cc12'); const f = n('1cdc'); const d = n('605d'); const h = a.location; let p = a.setImmediate; let m = a.clearImmediate; const g = a.process; const v = a.MessageChannel; const b = a.Dispatch; let y = 0; const w = {}; const x = 'onreadystatechange'; const k = function (e) { if (w.hasOwnProperty(e)) { const t = w[e]; delete w[e], t(); } }; const _ = function (e) { return function () { k(e); }; }; const C = function (e) { k(e.data); }; const S = function (e) { a.postMessage(`${e}`, `${h.protocol}//${h.host}`); }; p && m || (p = function (e) { const t = []; let n = 1; while (arguments.length > n)t.push(arguments[n++]); return w[++y] = function () { (typeof e === 'function' ? e : Function(e)).apply(void 0, t); }, r(y), y; }, m = function (e) { delete w[e]; }, d ? r = function (e) { g.nextTick(_(e)); } : b && b.now ? r = function (e) { b.now(_(e)); } : v && !f ? (i = new v(), o = i.port2, i.port1.onmessage = C, r = l(o.postMessage, o, 1)) : a.addEventListener && typeof postMessage === 'function' && !a.importScripts && h && h.protocol !== 'file:' && !s(S) ? (r = S, a.addEventListener('message', C, !1)) : r = x in u('script') ? function (e) { c.appendChild(u('script'))[x] = function () { c.removeChild(this), k(e); }; } : function (e) { setTimeout(_(e), 0); }), e.exports = { set: p, clear: m }; },
  '2d00': function (e, t, n) { let r; let i; const o = n('da84'); const a = n('342f'); const s = o.process; const l = s && s.versions; const c = l && l.v8; c ? (r = c.split('.'), i = r[0] < 4 ? 1 : r[0] + r[1]) : a && (r = a.match(/Edge\/(\d+)/), (!r || r[1] >= 74) && (r = a.match(/Chrome\/(\d+)/), r && (i = r[1]))), e.exports = i && +i; },
  '31c5': function (e, t, n) {
    (function (e) { e(n('56b3')); }(((e) => {
      const t = 'CodeMirror-activeline'; const n = 'CodeMirror-activeline-background'; const r = 'CodeMirror-activeline-gutter'; function i(e) { for (let i = 0; i < e.state.activeLines.length; i++)e.removeLineClass(e.state.activeLines[i], 'wrap', t), e.removeLineClass(e.state.activeLines[i], 'background', n), e.removeLineClass(e.state.activeLines[i], 'gutter', r); } function o(e, t) { if (e.length != t.length) return !1; for (let n = 0; n < e.length; n++) if (e[n] != t[n]) return !1; return !0; } function a(e, a) { for (var s = [], l = 0; l < a.length; l++) { const c = a[l]; const u = e.getOption('styleActiveLine'); if (typeof u === 'object' && u.nonEmpty ? c.anchor.line == c.head.line : c.empty()) { const f = e.getLineHandleVisualStart(c.head.line); s[s.length - 1] != f && s.push(f); } }o(e.state.activeLines, s) || e.operation((() => { i(e); for (let o = 0; o < s.length; o++)e.addLineClass(s[o], 'wrap', t), e.addLineClass(s[o], 'background', n), e.addLineClass(s[o], 'gutter', r); e.state.activeLines = s; })); } function s(e, t) { a(e, t.ranges); }e.defineOption('styleActiveLine', !1, ((t, n, r) => { const o = r != e.Init && r; n != o && (o && (t.off('beforeSelectionChange', s), i(t), delete t.state.activeLines), n && (t.state.activeLines = [], a(t, t.listSelections()), t.on('beforeSelectionChange', s))); }));
    })));
  },
  '339e': function (e, t, n) {
    let r;/*! showdown v 1.9.1 - 02-11-2019 */
    (function () {
      function i(e) {
        const t = {
          omitExtraWLInCodeBlocks: { defaultValue: !1, describe: 'Omit the default extra whiteline added to code blocks', type: 'boolean' }, noHeaderId: { defaultValue: !1, describe: 'Turn on/off generated header id', type: 'boolean' }, prefixHeaderId: { defaultValue: !1, describe: "Add a prefix to the generated header ids. Passing a string will prefix that string to the header id. Setting to true will add a generic 'section-' prefix", type: 'string' }, rawPrefixHeaderId: { defaultValue: !1, describe: 'Setting this option to true will prevent showdown from modifying the prefix. This might result in malformed IDs (if, for instance, the " char is used in the prefix)', type: 'boolean' }, ghCompatibleHeaderId: { defaultValue: !1, describe: 'Generate header ids compatible with github style (spaces are replaced with dashes, a bunch of non alphanumeric chars are removed)', type: 'boolean' }, rawHeaderId: { defaultValue: !1, describe: "Remove only spaces, ' and \" from generated header ids (including prefixes), replacing them with dashes (-). WARNING: This might result in malformed ids", type: 'boolean' }, headerLevelStart: { defaultValue: !1, describe: 'The header blocks level start', type: 'integer' }, parseImgDimensions: { defaultValue: !1, describe: 'Turn on/off image dimension parsing', type: 'boolean' }, simplifiedAutoLink: { defaultValue: !1, describe: 'Turn on/off GFM autolink style', type: 'boolean' }, excludeTrailingPunctuationFromURLs: { defaultValue: !1, describe: 'Excludes trailing punctuation from links generated with autoLinking', type: 'boolean' }, literalMidWordUnderscores: { defaultValue: !1, describe: 'Parse midword underscores as literal underscores', type: 'boolean' }, literalMidWordAsterisks: { defaultValue: !1, describe: 'Parse midword asterisks as literal asterisks', type: 'boolean' }, strikethrough: { defaultValue: !1, describe: 'Turn on/off strikethrough support', type: 'boolean' }, tables: { defaultValue: !1, describe: 'Turn on/off tables support', type: 'boolean' }, tablesHeaderId: { defaultValue: !1, describe: 'Add an id to table headers', type: 'boolean' }, ghCodeBlocks: { defaultValue: !0, describe: 'Turn on/off GFM fenced code blocks support', type: 'boolean' }, tasklists: { defaultValue: !1, describe: 'Turn on/off GFM tasklist support', type: 'boolean' }, smoothLivePreview: { defaultValue: !1, describe: 'Prevents weird effects in live previews due to incomplete input', type: 'boolean' }, smartIndentationFix: { defaultValue: !1, description: 'Tries to smartly fix indentation in es6 strings', type: 'boolean' }, disableForced4SpacesIndentedSublists: { defaultValue: !1, description: 'Disables the requirement of indenting nested sublists by 4 spaces', type: 'boolean' }, simpleLineBreaks: { defaultValue: !1, description: 'Parses simple line breaks as <br> (GFM Style)', type: 'boolean' }, requireSpaceBeforeHeadingText: { defaultValue: !1, description: 'Makes adding a space between `#` and the header text mandatory (GFM Style)', type: 'boolean' }, ghMentions: { defaultValue: !1, description: 'Enables github @mentions', type: 'boolean' }, ghMentionsLink: { defaultValue: 'https://github.com/{u}', description: 'Changes the link generated by @mentions. Only applies if ghMentions option is enabled.', type: 'string' }, encodeEmails: { defaultValue: !0, description: 'Encode e-mail addresses through the use of Character Entities, transforming ASCII e-mail addresses into its equivalent decimal entities', type: 'boolean' }, openLinksInNewWindow: { defaultValue: !1, description: 'Open all links in new windows', type: 'boolean' }, backslashEscapesHTMLTags: { defaultValue: !1, description: 'Support for HTML Tag escaping. ex: <div>foo</div>', type: 'boolean' }, emoji: { defaultValue: !1, description: 'Enable emoji support. Ex: `this is a :smile: emoji`', type: 'boolean' }, underline: { defaultValue: !1, description: 'Enable support for underline. Syntax is double or triple underscores: `__underline word__`. With this option enabled, underscores no longer parses into `<em>` and `<strong>`', type: 'boolean' }, completeHTMLDocument: { defaultValue: !1, description: 'Outputs a complete html document, including `<html>`, `<head>` and `<body>` tags', type: 'boolean' }, metadata: { defaultValue: !1, description: 'Enable support for document metadata (defined at the top of the document between `«««` and `»»»` or between `---` and `---`).', type: 'boolean' }, splitAdjacentBlockquotes: { defaultValue: !1, description: 'Split adjacent blockquote blocks', type: 'boolean' },
        }; if (!1 === e) return JSON.parse(JSON.stringify(t)); const n = {}; for (const r in t)t.hasOwnProperty(r) && (n[r] = t[r].defaultValue); return n;
      } function o() {
        const e = i(!0); const t = {}; for (const n in e)e.hasOwnProperty(n) && (t[n] = !0); return t;
      } const a = {}; const s = {}; let l = {}; let c = i(!0); let u = 'vanilla'; const f = {
        github: {
          omitExtraWLInCodeBlocks: !0, simplifiedAutoLink: !0, excludeTrailingPunctuationFromURLs: !0, literalMidWordUnderscores: !0, strikethrough: !0, tables: !0, tablesHeaderId: !0, ghCodeBlocks: !0, tasklists: !0, disableForced4SpacesIndentedSublists: !0, simpleLineBreaks: !0, requireSpaceBeforeHeadingText: !0, ghCompatibleHeaderId: !0, ghMentions: !0, backslashEscapesHTMLTags: !0, emoji: !0, splitAdjacentBlockquotes: !0,
        },
        original: { noHeaderId: !0, ghCodeBlocks: !1 },
        ghost: {
          omitExtraWLInCodeBlocks: !0, parseImgDimensions: !0, simplifiedAutoLink: !0, excludeTrailingPunctuationFromURLs: !0, literalMidWordUnderscores: !0, strikethrough: !0, tables: !0, tablesHeaderId: !0, ghCodeBlocks: !0, tasklists: !0, smoothLivePreview: !0, simpleLineBreaks: !0, requireSpaceBeforeHeadingText: !0, ghMentions: !1, encodeEmails: !0,
        },
        vanilla: i(!0),
        allOn: o(),
      }; function d(e, t) {
        const n = t ? `Error in ${t} extension->` : 'Error in unnamed extension'; const
          r = { valid: !0, error: '' }; a.helper.isArray(e) || (e = [e]); for (let i = 0; i < e.length; ++i) { const o = `${n} sub-extension ${i}: `; const s = e[i]; if (typeof s !== 'object') return r.valid = !1, r.error = `${o}must be an object, but ${typeof s} given`, r; if (!a.helper.isString(s.type)) return r.valid = !1, r.error = `${o}property "type" must be a string, but ${typeof s.type} given`, r; let l = s.type = s.type.toLowerCase(); if (l === 'language' && (l = s.type = 'lang'), l === 'html' && (l = s.type = 'output'), l !== 'lang' && l !== 'output' && l !== 'listener') return r.valid = !1, r.error = `${o}type ${l} is not recognized. Valid values: "lang/language", "output/html" or "listener"`, r; if (l === 'listener') { if (a.helper.isUndefined(s.listeners)) return r.valid = !1, r.error = `${o}. Extensions of type "listener" must have a property called "listeners"`, r; } else if (a.helper.isUndefined(s.filter) && a.helper.isUndefined(s.regex)) return r.valid = !1, r.error = `${o + l} extensions must define either a "regex" property or a "filter" method`, r; if (s.listeners) { if (typeof s.listeners !== 'object') return r.valid = !1, r.error = `${o}"listeners" property must be an object but ${typeof s.listeners} given`, r; for (const c in s.listeners) if (s.listeners.hasOwnProperty(c) && typeof s.listeners[c] !== 'function') return r.valid = !1, r.error = `${o}"listeners" property must be an hash of [event name]: [callback]. listeners.${c} must be a function but ${typeof s.listeners[c]} given`, r; } if (s.filter) { if (typeof s.filter !== 'function') return r.valid = !1, r.error = `${o}"filter" must be a function, but ${typeof s.filter} given`, r; } else if (s.regex) { if (a.helper.isString(s.regex) && (s.regex = new RegExp(s.regex, 'g')), !(s.regex instanceof RegExp)) return r.valid = !1, r.error = `${o}"regex" property must either be a string or a RegExp object, but ${typeof s.regex} given`, r; if (a.helper.isUndefined(s.replace)) return r.valid = !1, r.error = `${o}"regex" extensions must implement a replace string or function`, r; } } return r;
      } function h(e, t) {
        const n = t.charCodeAt(0); return `¨E${n}E`;
      }a.helper = {}, a.extensions = {}, a.setOption = function (e, t) {
        return c[e] = t, this;
      }, a.getOption = function (e) {
        return c[e];
      }, a.getOptions = function () {
        return c;
      }, a.resetOptions = function () {
        c = i(!0);
      }, a.setFlavor = function (e) {
        if (!f.hasOwnProperty(e)) throw Error(`${e} flavor was not found`); a.resetOptions(); const t = f[e]; for (const n in u = e, t)t.hasOwnProperty(n) && (c[n] = t[n]);
      }, a.getFlavor = function () {
        return u;
      }, a.getFlavorOptions = function (e) {
        if (f.hasOwnProperty(e)) return f[e];
      }, a.getDefaultOptions = function (e) {
        return i(e);
      }, a.subParser = function (e, t) {
        if (a.helper.isString(e)) { if (typeof t === 'undefined') { if (s.hasOwnProperty(e)) return s[e]; throw Error(`SubParser named ${e} not registered!`); }s[e] = t; }
      }, a.extension = function (e, t) {
        if (!a.helper.isString(e)) throw Error("Extension 'name' must be a string"); if (e = a.helper.stdExtName(e), a.helper.isUndefined(t)) { if (!l.hasOwnProperty(e)) throw Error(`Extension named ${e} is not registered!`); return l[e]; } typeof t === 'function' && (t = t()), a.helper.isArray(t) || (t = [t]); const n = d(t, e); if (!n.valid) throw Error(n.error); l[e] = t;
      }, a.getAllExtensions = function () {
        return l;
      }, a.removeExtension = function (e) {
        delete l[e];
      }, a.resetExtensions = function () {
        l = {};
      }, a.validateExtension = function (e) {
        const t = d(e, null); return !!t.valid || (console.warn(t.error), !1);
      }, a.hasOwnProperty('helper') || (a.helper = {}), a.helper.isString = function (e) {
        return typeof e === 'string' || e instanceof String;
      }, a.helper.isFunction = function (e) {
        const t = {}; return e && t.toString.call(e) === '[object Function]';
      }, a.helper.isArray = function (e) {
        return Array.isArray(e);
      }, a.helper.isUndefined = function (e) {
        return typeof e === 'undefined';
      }, a.helper.forEach = function (e, t) {
        if (a.helper.isUndefined(e)) throw new Error('obj param is required'); if (a.helper.isUndefined(t)) throw new Error('callback param is required'); if (!a.helper.isFunction(t)) throw new Error('callback param must be a function/closure'); if (typeof e.forEach === 'function')e.forEach(t); else if (a.helper.isArray(e)) for (let n = 0; n < e.length; n++)t(e[n], n, e); else { if (typeof e !== 'object') throw new Error('obj does not seem to be an array or an iterable object'); for (const r in e)e.hasOwnProperty(r) && t(e[r], r, e); }
      }, a.helper.stdExtName = function (e) {
        return e.replace(/[_?*+\/\\.^-]/g, '').replace(/\s/g, '').toLowerCase();
      }, a.helper.escapeCharactersCallback = h, a.helper.escapeCharacters = function (e, t, n) {
        let r = `([${t.replace(/([\[\]\\])/g, '\\$1')}])`; n && (r = `\\\\${r}`); const i = new RegExp(r, 'g'); return e = e.replace(i, h), e;
      }, a.helper.unescapeHTMLEntities = function (e) {
        return e.replace(/&quot;/g, '"').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');
      }; const p = function (e, t, n, r) {
        let i; let o; let a; let s; let l; const c = r || ''; const u = c.indexOf('g') > -1; const f = new RegExp(`${t}|${n}`, `g${c.replace(/g/g, '')}`); const d = new RegExp(t, c.replace(/g/g, '')); const h = []; do {
          i = 0; while (a = f.exec(e)) {
            if (d.test(a[0]))i++ || (o = f.lastIndex, s = o - a[0].length); else if (i && !--i) {
              l = a.index + a[0].length; const p = {
                left: { start: s, end: o }, match: { start: o, end: a.index }, right: { start: a.index, end: l }, wholeMatch: { start: s, end: l },
              }; if (h.push(p), !u) return h;
            }
          }
        } while (i && (f.lastIndex = o));return h;
      }; a.helper.matchRecursiveRegExp = function (e, t, n, r) {
        for (var i = p(e, t, n, r), o = [], a = 0; a < i.length; ++a)o.push([e.slice(i[a].wholeMatch.start, i[a].wholeMatch.end), e.slice(i[a].match.start, i[a].match.end), e.slice(i[a].left.start, i[a].left.end), e.slice(i[a].right.start, i[a].right.end)]); return o;
      }, a.helper.replaceRecursiveRegExp = function (e, t, n, r, i) {
        if (!a.helper.isFunction(t)) { const o = t; t = function () { return o; }; } const s = p(e, n, r, i); let l = e; const c = s.length; if (c > 0) { const u = []; s[0].wholeMatch.start !== 0 && u.push(e.slice(0, s[0].wholeMatch.start)); for (let f = 0; f < c; ++f)u.push(t(e.slice(s[f].wholeMatch.start, s[f].wholeMatch.end), e.slice(s[f].match.start, s[f].match.end), e.slice(s[f].left.start, s[f].left.end), e.slice(s[f].right.start, s[f].right.end))), f < c - 1 && u.push(e.slice(s[f].wholeMatch.end, s[f + 1].wholeMatch.start)); s[c - 1].wholeMatch.end < e.length && u.push(e.slice(s[c - 1].wholeMatch.end)), l = u.join(''); } return l;
      }, a.helper.regexIndexOf = function (e, t, n) {
        if (!a.helper.isString(e)) throw 'InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string'; if (t instanceof RegExp === !1) throw 'InvalidArgumentError: second parameter of showdown.helper.regexIndexOf function must be an instance of RegExp'; const r = e.substring(n || 0).search(t); return r >= 0 ? r + (n || 0) : r;
      }, a.helper.splitAtIndex = function (e, t) {
        if (!a.helper.isString(e)) throw 'InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string'; return [e.substring(0, t), e.substring(t)];
      }, a.helper.encodeEmailAddress = function (e) {
        const t = [function (e) { return `&#${e.charCodeAt(0)};`; }, function (e) { return `&#x${e.charCodeAt(0).toString(16)};`; }, function (e) { return e; }]; return e = e.replace(/./g, ((e) => { if (e === '@')e = t[Math.floor(2 * Math.random())](e); else { const n = Math.random(); e = n > 0.9 ? t[2](e) : n > 0.45 ? t[1](e) : t[0](e); } return e; })), e;
      }, a.helper.padEnd = function (e, t, n) {
        return t >>= 0, n = String(n || ' '), e.length > t ? String(e) : (t -= e.length, t > n.length && (n += n.repeat(t / n.length)), String(e) + n.slice(0, t));
      }, typeof console === 'undefined' && (console = {
        warn(e) {
          alert(e);
        },
        log(e) {
          alert(e);
        },
        error(e) {
          throw e;
        },
      }), a.helper.regexes = { asteriskDashAndColon: /([*_:~])/g }, a.helper.emojis = {
        '+1': '👍', '-1': '👎', 100: '💯', 1234: '🔢', '1st_place_medal': '🥇', '2nd_place_medal': '🥈', '3rd_place_medal': '🥉', '8ball': '🎱', a: '🅰️', ab: '🆎', abc: '🔤', abcd: '🔡', accept: '🉑', aerial_tramway: '🚡', airplane: '✈️', alarm_clock: '⏰', alembic: '⚗️', alien: '👽', ambulance: '🚑', amphora: '🏺', anchor: '⚓️', angel: '👼', anger: '💢', angry: '😠', anguished: '😧', ant: '🐜', apple: '🍎', aquarius: '♒️', aries: '♈️', arrow_backward: '◀️', arrow_double_down: '⏬', arrow_double_up: '⏫', arrow_down: '⬇️', arrow_down_small: '🔽', arrow_forward: '▶️', arrow_heading_down: '⤵️', arrow_heading_up: '⤴️', arrow_left: '⬅️', arrow_lower_left: '↙️', arrow_lower_right: '↘️', arrow_right: '➡️', arrow_right_hook: '↪️', arrow_up: '⬆️', arrow_up_down: '↕️', arrow_up_small: '🔼', arrow_upper_left: '↖️', arrow_upper_right: '↗️', arrows_clockwise: '🔃', arrows_counterclockwise: '🔄', art: '🎨', articulated_lorry: '🚛', artificial_satellite: '🛰', astonished: '😲', athletic_shoe: '👟', atm: '🏧', atom_symbol: '⚛️', avocado: '🥑', b: '🅱️', baby: '👶', baby_bottle: '🍼', baby_chick: '🐤', baby_symbol: '🚼', back: '🔙', bacon: '🥓', badminton: '🏸', baggage_claim: '🛄', baguette_bread: '🥖', balance_scale: '⚖️', balloon: '🎈', ballot_box: '🗳', ballot_box_with_check: '☑️', bamboo: '🎍', banana: '🍌', bangbang: '‼️', bank: '🏦', bar_chart: '📊', barber: '💈', baseball: '⚾️', basketball: '🏀', basketball_man: '⛹️', basketball_woman: '⛹️&zwj;♀️', bat: '🦇', bath: '🛀', bathtub: '🛁', battery: '🔋', beach_umbrella: '🏖', bear: '🐻', bed: '🛏', bee: '🐝', beer: '🍺', beers: '🍻', beetle: '🐞', beginner: '🔰', bell: '🔔', bellhop_bell: '🛎', bento: '🍱', biking_man: '🚴', bike: '🚲', biking_woman: '🚴&zwj;♀️', bikini: '👙', biohazard: '☣️', bird: '🐦', birthday: '🎂', black_circle: '⚫️', black_flag: '🏴', black_heart: '🖤', black_joker: '🃏', black_large_square: '⬛️', black_medium_small_square: '◾️', black_medium_square: '◼️', black_nib: '✒️', black_small_square: '▪️', black_square_button: '🔲', blonde_man: '👱', blonde_woman: '👱&zwj;♀️', blossom: '🌼', blowfish: '🐡', blue_book: '📘', blue_car: '🚙', blue_heart: '💙', blush: '😊', boar: '🐗', boat: '⛵️', bomb: '💣', book: '📖', bookmark: '🔖', bookmark_tabs: '📑', books: '📚', boom: '💥', boot: '👢', bouquet: '💐', bowing_man: '🙇', bow_and_arrow: '🏹', bowing_woman: '🙇&zwj;♀️', bowling: '🎳', boxing_glove: '🥊', boy: '👦', bread: '🍞', bride_with_veil: '👰', bridge_at_night: '🌉', briefcase: '💼', broken_heart: '💔', bug: '🐛', building_construction: '🏗', bulb: '💡', bullettrain_front: '🚅', bullettrain_side: '🚄', burrito: '🌯', bus: '🚌', business_suit_levitating: '🕴', busstop: '🚏', bust_in_silhouette: '👤', busts_in_silhouette: '👥', butterfly: '🦋', cactus: '🌵', cake: '🍰', calendar: '📆', call_me_hand: '🤙', calling: '📲', camel: '🐫', camera: '📷', camera_flash: '📸', camping: '🏕', cancer: '♋️', candle: '🕯', candy: '🍬', canoe: '🛶', capital_abcd: '🔠', capricorn: '♑️', car: '🚗', card_file_box: '🗃', card_index: '📇', card_index_dividers: '🗂', carousel_horse: '🎠', carrot: '🥕', cat: '🐱', cat2: '🐈', cd: '💿', chains: '⛓', champagne: '🍾', chart: '💹', chart_with_downwards_trend: '📉', chart_with_upwards_trend: '📈', checkered_flag: '🏁', cheese: '🧀', cherries: '🍒', cherry_blossom: '🌸', chestnut: '🌰', chicken: '🐔', children_crossing: '🚸', chipmunk: '🐿', chocolate_bar: '🍫', christmas_tree: '🎄', church: '⛪️', cinema: '🎦', circus_tent: '🎪', city_sunrise: '🌇', city_sunset: '🌆', cityscape: '🏙', cl: '🆑', clamp: '🗜', clap: '👏', clapper: '🎬', classical_building: '🏛', clinking_glasses: '🥂', clipboard: '📋', clock1: '🕐', clock10: '🕙', clock1030: '🕥', clock11: '🕚', clock1130: '🕦', clock12: '🕛', clock1230: '🕧', clock130: '🕜', clock2: '🕑', clock230: '🕝', clock3: '🕒', clock330: '🕞', clock4: '🕓', clock430: '🕟', clock5: '🕔', clock530: '🕠', clock6: '🕕', clock630: '🕡', clock7: '🕖', clock730: '🕢', clock8: '🕗', clock830: '🕣', clock9: '🕘', clock930: '🕤', closed_book: '📕', closed_lock_with_key: '🔐', closed_umbrella: '🌂', cloud: '☁️', cloud_with_lightning: '🌩', cloud_with_lightning_and_rain: '⛈', cloud_with_rain: '🌧', cloud_with_snow: '🌨', clown_face: '🤡', clubs: '♣️', cocktail: '🍸', coffee: '☕️', coffin: '⚰️', cold_sweat: '😰', comet: '☄️', computer: '💻', computer_mouse: '🖱', confetti_ball: '🎊', confounded: '😖', confused: '😕', congratulations: '㊗️', construction: '🚧', construction_worker_man: '👷', construction_worker_woman: '👷&zwj;♀️', control_knobs: '🎛', convenience_store: '🏪', cookie: '🍪', cool: '🆒', policeman: '👮', copyright: '©️', corn: '🌽', couch_and_lamp: '🛋', couple: '👫', couple_with_heart_woman_man: '💑', couple_with_heart_man_man: '👨&zwj;❤️&zwj;👨', couple_with_heart_woman_woman: '👩&zwj;❤️&zwj;👩', couplekiss_man_man: '👨&zwj;❤️&zwj;💋&zwj;👨', couplekiss_man_woman: '💏', couplekiss_woman_woman: '👩&zwj;❤️&zwj;💋&zwj;👩', cow: '🐮', cow2: '🐄', cowboy_hat_face: '🤠', crab: '🦀', crayon: '🖍', credit_card: '💳', crescent_moon: '🌙', cricket: '🏏', crocodile: '🐊', croissant: '🥐', crossed_fingers: '🤞', crossed_flags: '🎌', crossed_swords: '⚔️', crown: '👑', cry: '😢', crying_cat_face: '😿', crystal_ball: '🔮', cucumber: '🥒', cupid: '💘', curly_loop: '➰', currency_exchange: '💱', curry: '🍛', custard: '🍮', customs: '🛃', cyclone: '🌀', dagger: '🗡', dancer: '💃', dancing_women: '👯', dancing_men: '👯&zwj;♂️', dango: '🍡', dark_sunglasses: '🕶', dart: '🎯', dash: '💨', date: '📅', deciduous_tree: '🌳', deer: '🦌', department_store: '🏬', derelict_house: '🏚', desert: '🏜', desert_island: '🏝', desktop_computer: '🖥', male_detective: '🕵️', diamond_shape_with_a_dot_inside: '💠', diamonds: '♦️', disappointed: '😞', disappointed_relieved: '😥', dizzy: '💫', dizzy_face: '😵', do_not_litter: '🚯', dog: '🐶', dog2: '🐕', dollar: '💵', dolls: '🎎', dolphin: '🐬', door: '🚪', doughnut: '🍩', dove: '🕊', dragon: '🐉', dragon_face: '🐲', dress: '👗', dromedary_camel: '🐪', drooling_face: '🤤', droplet: '💧', drum: '🥁', duck: '🦆', dvd: '📀', 'e-mail': '📧', eagle: '🦅', ear: '👂', ear_of_rice: '🌾', earth_africa: '🌍', earth_americas: '🌎', earth_asia: '🌏', egg: '🥚', eggplant: '🍆', eight_pointed_black_star: '✴️', eight_spoked_asterisk: '✳️', electric_plug: '🔌', elephant: '🐘', email: '✉️', end: '🔚', envelope_with_arrow: '📩', euro: '💶', european_castle: '🏰', european_post_office: '🏤', evergreen_tree: '🌲', exclamation: '❗️', expressionless: '😑', eye: '👁', eye_speech_bubble: '👁&zwj;🗨', eyeglasses: '👓', eyes: '👀', face_with_head_bandage: '🤕', face_with_thermometer: '🤒', fist_oncoming: '👊', factory: '🏭', fallen_leaf: '🍂', family_man_woman_boy: '👪', family_man_boy: '👨&zwj;👦', family_man_boy_boy: '👨&zwj;👦&zwj;👦', family_man_girl: '👨&zwj;👧', family_man_girl_boy: '👨&zwj;👧&zwj;👦', family_man_girl_girl: '👨&zwj;👧&zwj;👧', family_man_man_boy: '👨&zwj;👨&zwj;👦', family_man_man_boy_boy: '👨&zwj;👨&zwj;👦&zwj;👦', family_man_man_girl: '👨&zwj;👨&zwj;👧', family_man_man_girl_boy: '👨&zwj;👨&zwj;👧&zwj;👦', family_man_man_girl_girl: '👨&zwj;👨&zwj;👧&zwj;👧', family_man_woman_boy_boy: '👨&zwj;👩&zwj;👦&zwj;👦', family_man_woman_girl: '👨&zwj;👩&zwj;👧', family_man_woman_girl_boy: '👨&zwj;👩&zwj;👧&zwj;👦', family_man_woman_girl_girl: '👨&zwj;👩&zwj;👧&zwj;👧', family_woman_boy: '👩&zwj;👦', family_woman_boy_boy: '👩&zwj;👦&zwj;👦', family_woman_girl: '👩&zwj;👧', family_woman_girl_boy: '👩&zwj;👧&zwj;👦', family_woman_girl_girl: '👩&zwj;👧&zwj;👧', family_woman_woman_boy: '👩&zwj;👩&zwj;👦', family_woman_woman_boy_boy: '👩&zwj;👩&zwj;👦&zwj;👦', family_woman_woman_girl: '👩&zwj;👩&zwj;👧', family_woman_woman_girl_boy: '👩&zwj;👩&zwj;👧&zwj;👦', family_woman_woman_girl_girl: '👩&zwj;👩&zwj;👧&zwj;👧', fast_forward: '⏩', fax: '📠', fearful: '😨', feet: '🐾', female_detective: '🕵️&zwj;♀️', ferris_wheel: '🎡', ferry: '⛴', field_hockey: '🏑', file_cabinet: '🗄', file_folder: '📁', film_projector: '📽', film_strip: '🎞', fire: '🔥', fire_engine: '🚒', fireworks: '🎆', first_quarter_moon: '🌓', first_quarter_moon_with_face: '🌛', fish: '🐟', fish_cake: '🍥', fishing_pole_and_fish: '🎣', fist_raised: '✊', fist_left: '🤛', fist_right: '🤜', flags: '🎏', flashlight: '🔦', fleur_de_lis: '⚜️', flight_arrival: '🛬', flight_departure: '🛫', floppy_disk: '💾', flower_playing_cards: '🎴', flushed: '😳', fog: '🌫', foggy: '🌁', football: '🏈', footprints: '👣', fork_and_knife: '🍴', fountain: '⛲️', fountain_pen: '🖋', four_leaf_clover: '🍀', fox_face: '🦊', framed_picture: '🖼', free: '🆓', fried_egg: '🍳', fried_shrimp: '🍤', fries: '🍟', frog: '🐸', frowning: '😦', frowning_face: '☹️', frowning_man: '🙍&zwj;♂️', frowning_woman: '🙍', middle_finger: '🖕', fuelpump: '⛽️', full_moon: '🌕', full_moon_with_face: '🌝', funeral_urn: '⚱️', game_die: '🎲', gear: '⚙️', gem: '💎', gemini: '♊️', ghost: '👻', gift: '🎁', gift_heart: '💝', girl: '👧', globe_with_meridians: '🌐', goal_net: '🥅', goat: '🐐', golf: '⛳️', golfing_man: '🏌️', golfing_woman: '🏌️&zwj;♀️', gorilla: '🦍', grapes: '🍇', green_apple: '🍏', green_book: '📗', green_heart: '💚', green_salad: '🥗', grey_exclamation: '❕', grey_question: '❔', grimacing: '😬', grin: '😁', grinning: '😀', guardsman: '💂', guardswoman: '💂&zwj;♀️', guitar: '🎸', gun: '🔫', haircut_woman: '💇', haircut_man: '💇&zwj;♂️', hamburger: '🍔', hammer: '🔨', hammer_and_pick: '⚒', hammer_and_wrench: '🛠', hamster: '🐹', hand: '✋', handbag: '👜', handshake: '🤝', hankey: '💩', hatched_chick: '🐥', hatching_chick: '🐣', headphones: '🎧', hear_no_evil: '🙉', heart: '❤️', heart_decoration: '💟', heart_eyes: '😍', heart_eyes_cat: '😻', heartbeat: '💓', heartpulse: '💗', hearts: '♥️', heavy_check_mark: '✔️', heavy_division_sign: '➗', heavy_dollar_sign: '💲', heavy_heart_exclamation: '❣️', heavy_minus_sign: '➖', heavy_multiplication_x: '✖️', heavy_plus_sign: '➕', helicopter: '🚁', herb: '🌿', hibiscus: '🌺', high_brightness: '🔆', high_heel: '👠', hocho: '🔪', hole: '🕳', honey_pot: '🍯', horse: '🐴', horse_racing: '🏇', hospital: '🏥', hot_pepper: '🌶', hotdog: '🌭', hotel: '🏨', hotsprings: '♨️', hourglass: '⌛️', hourglass_flowing_sand: '⏳', house: '🏠', house_with_garden: '🏡', houses: '🏘', hugs: '🤗', hushed: '😯', ice_cream: '🍨', ice_hockey: '🏒', ice_skate: '⛸', icecream: '🍦', id: '🆔', ideograph_advantage: '🉐', imp: '👿', inbox_tray: '📥', incoming_envelope: '📨', tipping_hand_woman: '💁', information_source: 'ℹ️', innocent: '😇', interrobang: '⁉️', iphone: '📱', izakaya_lantern: '🏮', jack_o_lantern: '🎃', japan: '🗾', japanese_castle: '🏯', japanese_goblin: '👺', japanese_ogre: '👹', jeans: '👖', joy: '😂', joy_cat: '😹', joystick: '🕹', kaaba: '🕋', key: '🔑', keyboard: '⌨️', keycap_ten: '🔟', kick_scooter: '🛴', kimono: '👘', kiss: '💋', kissing: '😗', kissing_cat: '😽', kissing_closed_eyes: '😚', kissing_heart: '😘', kissing_smiling_eyes: '😙', kiwi_fruit: '🥝', koala: '🐨', koko: '🈁', label: '🏷', large_blue_circle: '🔵', large_blue_diamond: '🔷', large_orange_diamond: '🔶', last_quarter_moon: '🌗', last_quarter_moon_with_face: '🌜', latin_cross: '✝️', laughing: '😆', leaves: '🍃', ledger: '📒', left_luggage: '🛅', left_right_arrow: '↔️', leftwards_arrow_with_hook: '↩️', lemon: '🍋', leo: '♌️', leopard: '🐆', level_slider: '🎚', libra: '♎️', light_rail: '🚈', link: '🔗', lion: '🦁', lips: '👄', lipstick: '💄', lizard: '🦎', lock: '🔒', lock_with_ink_pen: '🔏', lollipop: '🍭', loop: '➿', loud_sound: '🔊', loudspeaker: '📢', love_hotel: '🏩', love_letter: '💌', low_brightness: '🔅', lying_face: '🤥', m: 'Ⓜ️', mag: '🔍', mag_right: '🔎', mahjong: '🀄️', mailbox: '📫', mailbox_closed: '📪', mailbox_with_mail: '📬', mailbox_with_no_mail: '📭', man: '👨', man_artist: '👨&zwj;🎨', man_astronaut: '👨&zwj;🚀', man_cartwheeling: '🤸&zwj;♂️', man_cook: '👨&zwj;🍳', man_dancing: '🕺', man_facepalming: '🤦&zwj;♂️', man_factory_worker: '👨&zwj;🏭', man_farmer: '👨&zwj;🌾', man_firefighter: '👨&zwj;🚒', man_health_worker: '👨&zwj;⚕️', man_in_tuxedo: '🤵', man_judge: '👨&zwj;⚖️', man_juggling: '🤹&zwj;♂️', man_mechanic: '👨&zwj;🔧', man_office_worker: '👨&zwj;💼', man_pilot: '👨&zwj;✈️', man_playing_handball: '🤾&zwj;♂️', man_playing_water_polo: '🤽&zwj;♂️', man_scientist: '👨&zwj;🔬', man_shrugging: '🤷&zwj;♂️', man_singer: '👨&zwj;🎤', man_student: '👨&zwj;🎓', man_teacher: '👨&zwj;🏫', man_technologist: '👨&zwj;💻', man_with_gua_pi_mao: '👲', man_with_turban: '👳', tangerine: '🍊', mans_shoe: '👞', mantelpiece_clock: '🕰', maple_leaf: '🍁', martial_arts_uniform: '🥋', mask: '😷', massage_woman: '💆', massage_man: '💆&zwj;♂️', meat_on_bone: '🍖', medal_military: '🎖', medal_sports: '🏅', mega: '📣', melon: '🍈', memo: '📝', men_wrestling: '🤼&zwj;♂️', menorah: '🕎', mens: '🚹', metal: '🤘', metro: '🚇', microphone: '🎤', microscope: '🔬', milk_glass: '🥛', milky_way: '🌌', minibus: '🚐', minidisc: '💽', mobile_phone_off: '📴', money_mouth_face: '🤑', money_with_wings: '💸', moneybag: '💰', monkey: '🐒', monkey_face: '🐵', monorail: '🚝', moon: '🌔', mortar_board: '🎓', mosque: '🕌', motor_boat: '🛥', motor_scooter: '🛵', motorcycle: '🏍', motorway: '🛣', mount_fuji: '🗻', mountain: '⛰', mountain_biking_man: '🚵', mountain_biking_woman: '🚵&zwj;♀️', mountain_cableway: '🚠', mountain_railway: '🚞', mountain_snow: '🏔', mouse: '🐭', mouse2: '🐁', movie_camera: '🎥', moyai: '🗿', mrs_claus: '🤶', muscle: '💪', mushroom: '🍄', musical_keyboard: '🎹', musical_note: '🎵', musical_score: '🎼', mute: '🔇', nail_care: '💅', name_badge: '📛', national_park: '🏞', nauseated_face: '🤢', necktie: '👔', negative_squared_cross_mark: '❎', nerd_face: '🤓', neutral_face: '😐', new: '🆕', new_moon: '🌑', new_moon_with_face: '🌚', newspaper: '📰', newspaper_roll: '🗞', next_track_button: '⏭', ng: '🆖', no_good_man: '🙅&zwj;♂️', no_good_woman: '🙅', night_with_stars: '🌃', no_bell: '🔕', no_bicycles: '🚳', no_entry: '⛔️', no_entry_sign: '🚫', no_mobile_phones: '📵', no_mouth: '😶', no_pedestrians: '🚷', no_smoking: '🚭', 'non-potable_water': '🚱', nose: '👃', notebook: '📓', notebook_with_decorative_cover: '📔', notes: '🎶', nut_and_bolt: '🔩', o: '⭕️', o2: '🅾️', ocean: '🌊', octopus: '🐙', oden: '🍢', office: '🏢', oil_drum: '🛢', ok: '🆗', ok_hand: '👌', ok_man: '🙆&zwj;♂️', ok_woman: '🙆', old_key: '🗝', older_man: '👴', older_woman: '👵', om: '🕉', on: '🔛', oncoming_automobile: '🚘', oncoming_bus: '🚍', oncoming_police_car: '🚔', oncoming_taxi: '🚖', open_file_folder: '📂', open_hands: '👐', open_mouth: '😮', open_umbrella: '☂️', ophiuchus: '⛎', orange_book: '📙', orthodox_cross: '☦️', outbox_tray: '📤', owl: '🦉', ox: '🐂', package: '📦', page_facing_up: '📄', page_with_curl: '📃', pager: '📟', paintbrush: '🖌', palm_tree: '🌴', pancakes: '🥞', panda_face: '🐼', paperclip: '📎', paperclips: '🖇', parasol_on_ground: '⛱', parking: '🅿️', part_alternation_mark: '〽️', partly_sunny: '⛅️', passenger_ship: '🛳', passport_control: '🛂', pause_button: '⏸', peace_symbol: '☮️', peach: '🍑', peanuts: '🥜', pear: '🍐', pen: '🖊', pencil2: '✏️', penguin: '🐧', pensive: '😔', performing_arts: '🎭', persevere: '😣', person_fencing: '🤺', pouting_woman: '🙎', phone: '☎️', pick: '⛏', pig: '🐷', pig2: '🐖', pig_nose: '🐽', pill: '💊', pineapple: '🍍', ping_pong: '🏓', pisces: '♓️', pizza: '🍕', place_of_worship: '🛐', plate_with_cutlery: '🍽', play_or_pause_button: '⏯', point_down: '👇', point_left: '👈', point_right: '👉', point_up: '☝️', point_up_2: '👆', police_car: '🚓', policewoman: '👮&zwj;♀️', poodle: '🐩', popcorn: '🍿', post_office: '🏣', postal_horn: '📯', postbox: '📮', potable_water: '🚰', potato: '🥔', pouch: '👝', poultry_leg: '🍗', pound: '💷', rage: '😡', pouting_cat: '😾', pouting_man: '🙎&zwj;♂️', pray: '🙏', prayer_beads: '📿', pregnant_woman: '🤰', previous_track_button: '⏮', prince: '🤴', princess: '👸', printer: '🖨', purple_heart: '💜', purse: '👛', pushpin: '📌', put_litter_in_its_place: '🚮', question: '❓', rabbit: '🐰', rabbit2: '🐇', racehorse: '🐎', racing_car: '🏎', radio: '📻', radio_button: '🔘', radioactive: '☢️', railway_car: '🚃', railway_track: '🛤', rainbow: '🌈', rainbow_flag: '🏳️&zwj;🌈', raised_back_of_hand: '🤚', raised_hand_with_fingers_splayed: '🖐', raised_hands: '🙌', raising_hand_woman: '🙋', raising_hand_man: '🙋&zwj;♂️', ram: '🐏', ramen: '🍜', rat: '🐀', record_button: '⏺', recycle: '♻️', red_circle: '🔴', registered: '®️', relaxed: '☺️', relieved: '😌', reminder_ribbon: '🎗', repeat: '🔁', repeat_one: '🔂', rescue_worker_helmet: '⛑', restroom: '🚻', revolving_hearts: '💞', rewind: '⏪', rhinoceros: '🦏', ribbon: '🎀', rice: '🍚', rice_ball: '🍙', rice_cracker: '🍘', rice_scene: '🎑', right_anger_bubble: '🗯', ring: '💍', robot: '🤖', rocket: '🚀', rofl: '🤣', roll_eyes: '🙄', roller_coaster: '🎢', rooster: '🐓', rose: '🌹', rosette: '🏵', rotating_light: '🚨', round_pushpin: '📍', rowing_man: '🚣', rowing_woman: '🚣&zwj;♀️', rugby_football: '🏉', running_man: '🏃', running_shirt_with_sash: '🎽', running_woman: '🏃&zwj;♀️', sa: '🈂️', sagittarius: '♐️', sake: '🍶', sandal: '👡', santa: '🎅', satellite: '📡', saxophone: '🎷', school: '🏫', school_satchel: '🎒', scissors: '✂️', scorpion: '🦂', scorpius: '♏️', scream: '😱', scream_cat: '🙀', scroll: '📜', seat: '💺', secret: '㊙️', see_no_evil: '🙈', seedling: '🌱', selfie: '🤳', shallow_pan_of_food: '🥘', shamrock: '☘️', shark: '🦈', shaved_ice: '🍧', sheep: '🐑', shell: '🐚', shield: '🛡', shinto_shrine: '⛩', ship: '🚢', shirt: '👕', shopping: '🛍', shopping_cart: '🛒', shower: '🚿', shrimp: '🦐', signal_strength: '📶', six_pointed_star: '🔯', ski: '🎿', skier: '⛷', skull: '💀', skull_and_crossbones: '☠️', sleeping: '😴', sleeping_bed: '🛌', sleepy: '😪', slightly_frowning_face: '🙁', slightly_smiling_face: '🙂', slot_machine: '🎰', small_airplane: '🛩', small_blue_diamond: '🔹', small_orange_diamond: '🔸', small_red_triangle: '🔺', small_red_triangle_down: '🔻', smile: '😄', smile_cat: '😸', smiley: '😃', smiley_cat: '😺', smiling_imp: '😈', smirk: '😏', smirk_cat: '😼', smoking: '🚬', snail: '🐌', snake: '🐍', sneezing_face: '🤧', snowboarder: '🏂', snowflake: '❄️', snowman: '⛄️', snowman_with_snow: '☃️', sob: '😭', soccer: '⚽️', soon: '🔜', sos: '🆘', sound: '🔉', space_invader: '👾', spades: '♠️', spaghetti: '🍝', sparkle: '❇️', sparkler: '🎇', sparkles: '✨', sparkling_heart: '💖', speak_no_evil: '🙊', speaker: '🔈', speaking_head: '🗣', speech_balloon: '💬', speedboat: '🚤', spider: '🕷', spider_web: '🕸', spiral_calendar: '🗓', spiral_notepad: '🗒', spoon: '🥄', squid: '🦑', stadium: '🏟', star: '⭐️', star2: '🌟', star_and_crescent: '☪️', star_of_david: '✡️', stars: '🌠', station: '🚉', statue_of_liberty: '🗽', steam_locomotive: '🚂', stew: '🍲', stop_button: '⏹', stop_sign: '🛑', stopwatch: '⏱', straight_ruler: '📏', strawberry: '🍓', stuck_out_tongue: '😛', stuck_out_tongue_closed_eyes: '😝', stuck_out_tongue_winking_eye: '😜', studio_microphone: '🎙', stuffed_flatbread: '🥙', sun_behind_large_cloud: '🌥', sun_behind_rain_cloud: '🌦', sun_behind_small_cloud: '🌤', sun_with_face: '🌞', sunflower: '🌻', sunglasses: '😎', sunny: '☀️', sunrise: '🌅', sunrise_over_mountains: '🌄', surfing_man: '🏄', surfing_woman: '🏄&zwj;♀️', sushi: '🍣', suspension_railway: '🚟', sweat: '😓', sweat_drops: '💦', sweat_smile: '😅', sweet_potato: '🍠', swimming_man: '🏊', swimming_woman: '🏊&zwj;♀️', symbols: '🔣', synagogue: '🕍', syringe: '💉', taco: '🌮', tada: '🎉', tanabata_tree: '🎋', taurus: '♉️', taxi: '🚕', tea: '🍵', telephone_receiver: '📞', telescope: '🔭', tennis: '🎾', tent: '⛺️', thermometer: '🌡', thinking: '🤔', thought_balloon: '💭', ticket: '🎫', tickets: '🎟', tiger: '🐯', tiger2: '🐅', timer_clock: '⏲', tipping_hand_man: '💁&zwj;♂️', tired_face: '😫', tm: '™️', toilet: '🚽', tokyo_tower: '🗼', tomato: '🍅', tongue: '👅', top: '🔝', tophat: '🎩', tornado: '🌪', trackball: '🖲', tractor: '🚜', traffic_light: '🚥', train: '🚋', train2: '🚆', tram: '🚊', triangular_flag_on_post: '🚩', triangular_ruler: '📐', trident: '🔱', triumph: '😤', trolleybus: '🚎', trophy: '🏆', tropical_drink: '🍹', tropical_fish: '🐠', truck: '🚚', trumpet: '🎺', tulip: '🌷', tumbler_glass: '🥃', turkey: '🦃', turtle: '🐢', tv: '📺', twisted_rightwards_arrows: '🔀', two_hearts: '💕', two_men_holding_hands: '👬', two_women_holding_hands: '👭', u5272: '🈹', u5408: '🈴', u55b6: '🈺', u6307: '🈯️', u6708: '🈷️', u6709: '🈶', u6e80: '🈵', u7121: '🈚️', u7533: '🈸', u7981: '🈲', u7a7a: '🈳', umbrella: '☔️', unamused: '😒', underage: '🔞', unicorn: '🦄', unlock: '🔓', up: '🆙', upside_down_face: '🙃', v: '✌️', vertical_traffic_light: '🚦', vhs: '📼', vibration_mode: '📳', video_camera: '📹', video_game: '🎮', violin: '🎻', virgo: '♍️', volcano: '🌋', volleyball: '🏐', vs: '🆚', vulcan_salute: '🖖', walking_man: '🚶', walking_woman: '🚶&zwj;♀️', waning_crescent_moon: '🌘', waning_gibbous_moon: '🌖', warning: '⚠️', wastebasket: '🗑', watch: '⌚️', water_buffalo: '🐃', watermelon: '🍉', wave: '👋', wavy_dash: '〰️', waxing_crescent_moon: '🌒', wc: '🚾', weary: '😩', wedding: '💒', weight_lifting_man: '🏋️', weight_lifting_woman: '🏋️&zwj;♀️', whale: '🐳', whale2: '🐋', wheel_of_dharma: '☸️', wheelchair: '♿️', white_check_mark: '✅', white_circle: '⚪️', white_flag: '🏳️', white_flower: '💮', white_large_square: '⬜️', white_medium_small_square: '◽️', white_medium_square: '◻️', white_small_square: '▫️', white_square_button: '🔳', wilted_flower: '🥀', wind_chime: '🎐', wind_face: '🌬', wine_glass: '🍷', wink: '😉', wolf: '🐺', woman: '👩', woman_artist: '👩&zwj;🎨', woman_astronaut: '👩&zwj;🚀', woman_cartwheeling: '🤸&zwj;♀️', woman_cook: '👩&zwj;🍳', woman_facepalming: '🤦&zwj;♀️', woman_factory_worker: '👩&zwj;🏭', woman_farmer: '👩&zwj;🌾', woman_firefighter: '👩&zwj;🚒', woman_health_worker: '👩&zwj;⚕️', woman_judge: '👩&zwj;⚖️', woman_juggling: '🤹&zwj;♀️', woman_mechanic: '👩&zwj;🔧', woman_office_worker: '👩&zwj;💼', woman_pilot: '👩&zwj;✈️', woman_playing_handball: '🤾&zwj;♀️', woman_playing_water_polo: '🤽&zwj;♀️', woman_scientist: '👩&zwj;🔬', woman_shrugging: '🤷&zwj;♀️', woman_singer: '👩&zwj;🎤', woman_student: '👩&zwj;🎓', woman_teacher: '👩&zwj;🏫', woman_technologist: '👩&zwj;💻', woman_with_turban: '👳&zwj;♀️', womans_clothes: '👚', womans_hat: '👒', women_wrestling: '🤼&zwj;♀️', womens: '🚺', world_map: '🗺', worried: '😟', wrench: '🔧', writing_hand: '✍️', x: '❌', yellow_heart: '💛', yen: '💴', yin_yang: '☯️', yum: '😋', zap: '⚡️', zipper_mouth_face: '🤐', zzz: '💤', octocat: '<img alt=":octocat:" height="20" width="20" align="absmiddle" src="https://assets-cdn.github.com/images/icons/emoji/octocat.png">', showdown: "<span style=\"font-family: 'Anonymous Pro', monospace; text-decoration: underline; text-decoration-style: dashed; text-decoration-color: #3e8b8a;text-underline-position: under;\">S</span>",
      }, a.Converter = function (e) {
        const t = {}; const n = []; const r = []; const i = {}; let o = u; let s = { parsed: {}, raw: '', format: '' }; function h() { for (const n in e = e || {}, c)c.hasOwnProperty(n) && (t[n] = c[n]); if (typeof e !== 'object') throw Error(`Converter expects the passed parameter to be an object, but ${typeof e} was passed instead.`); for (const r in e)e.hasOwnProperty(r) && (t[r] = e[r]); t.extensions && a.helper.forEach(t.extensions, p); } function p(e, t) { if (t = t || null, a.helper.isString(e)) { if (e = a.helper.stdExtName(e), t = e, a.extensions[e]) return console.warn(`DEPRECATION WARNING: ${e} is an old extension that uses a deprecated loading method.Please inform the developer that the extension should be updated!`), void m(a.extensions[e], e); if (a.helper.isUndefined(l[e])) throw Error(`Extension "${e}" could not be loaded. It was either not found or is not a valid extension.`); e = l[e]; } typeof e === 'function' && (e = e()), a.helper.isArray(e) || (e = [e]); const i = d(e, t); if (!i.valid) throw Error(i.error); for (let o = 0; o < e.length; ++o) { switch (e[o].type) { case 'lang': n.push(e[o]); break; case 'output': r.push(e[o]); break; } if (e[o].hasOwnProperty('listeners')) for (const s in e[o].listeners)e[o].listeners.hasOwnProperty(s) && g(s, e[o].listeners[s]); } } function m(e, t) { typeof e === 'function' && (e = e(new a.Converter())), a.helper.isArray(e) || (e = [e]); const i = d(e, t); if (!i.valid) throw Error(i.error); for (let o = 0; o < e.length; ++o) switch (e[o].type) { case 'lang': n.push(e[o]); break; case 'output': r.push(e[o]); break; default: throw Error('Extension loader error: Type unrecognized!!!'); } } function g(e, t) { if (!a.helper.isString(e)) throw Error(`Invalid argument in converter.listen() method: name must be a string, but ${typeof e} given`); if (typeof t !== 'function') throw Error(`Invalid argument in converter.listen() method: callback must be a function, but ${typeof t} given`); i.hasOwnProperty(e) || (i[e] = []), i[e].push(t); } function v(e) { const t = e.match(/^\s*/)[0].length; const n = new RegExp(`^\\s{0,${t}}`, 'gm'); return e.replace(n, ''); }h(), this._dispatch = function (e, t, n, r) { if (i.hasOwnProperty(e)) for (let o = 0; o < i[e].length; ++o) { const a = i[e][o](e, t, this, n, r); a && typeof a !== 'undefined' && (t = a); } return t; }, this.listen = function (e, t) { return g(e, t), this; }, this.makeHtml = function (e) {
          if (!e) return e; const i = {
            gHtmlBlocks: [], gHtmlMdBlocks: [], gHtmlSpans: [], gUrls: {}, gTitles: {}, gDimensions: {}, gListLevel: 0, hashLinkCounts: {}, langExtensions: n, outputModifiers: r, converter: this, ghCodeBlocks: [], metadata: { parsed: {}, raw: '', format: '' },
          }; return e = e.replace(/¨/g, '¨T'), e = e.replace(/\$/g, '¨D'), e = e.replace(/\r\n/g, '\n'), e = e.replace(/\r/g, '\n'), e = e.replace(/\u00A0/g, '&nbsp;'), t.smartIndentationFix && (e = v(e)), e = `\n\n${e}\n\n`, e = a.subParser('detab')(e, t, i), e = e.replace(/^[ \t]+$/gm, ''), a.helper.forEach(n, ((n) => { e = a.subParser('runExtension')(n, e, t, i); })), e = a.subParser('metadata')(e, t, i), e = a.subParser('hashPreCodeTags')(e, t, i), e = a.subParser('githubCodeBlocks')(e, t, i), e = a.subParser('hashHTMLBlocks')(e, t, i), e = a.subParser('hashCodeTags')(e, t, i), e = a.subParser('stripLinkDefinitions')(e, t, i), e = a.subParser('blockGamut')(e, t, i), e = a.subParser('unhashHTMLSpans')(e, t, i), e = a.subParser('unescapeSpecialChars')(e, t, i), e = e.replace(/¨D/g, '$$'), e = e.replace(/¨T/g, '¨'), e = a.subParser('completeHTMLDocument')(e, t, i), a.helper.forEach(r, ((n) => { e = a.subParser('runExtension')(n, e, t, i); })), s = i.metadata, e;
        }, this.makeMarkdown = this.makeMd = function (e, t) { if (e = e.replace(/\r\n/g, '\n'), e = e.replace(/\r/g, '\n'), e = e.replace(/>[ \t]+</, '>¨NBSP;<'), !t) { if (!window || !window.document) throw new Error('HTMLParser is undefined. If in a webworker or nodejs environment, you need to provide a WHATWG DOM and HTML such as JSDOM'); t = window.document; } const n = t.createElement('div'); n.innerHTML = e; const r = { preList: c(n) }; l(n); for (var i = n.childNodes, o = '', s = 0; s < i.length; s++)o += a.subParser('makeMarkdown.node')(i[s], r); function l(e) { for (let t = 0; t < e.childNodes.length; ++t) { const n = e.childNodes[t]; n.nodeType === 3 ? /\S/.test(n.nodeValue) ? (n.nodeValue = n.nodeValue.split('\n').join(' '), n.nodeValue = n.nodeValue.replace(/(\s)+/g, '$1')) : (e.removeChild(n), --t) : n.nodeType === 1 && l(n); } } function c(e) { for (var t = e.querySelectorAll('pre'), n = [], r = 0; r < t.length; ++r) if (t[r].childElementCount === 1 && t[r].firstChild.tagName.toLowerCase() === 'code') { let i = t[r].firstChild.innerHTML.trim(); let o = t[r].firstChild.getAttribute('data-language') || ''; if (o === '') for (let s = t[r].firstChild.className.split(' '), l = 0; l < s.length; ++l) { const c = s[l].match(/^language-(.+)$/); if (c !== null) { o = c[1]; break; } }i = a.helper.unescapeHTMLEntities(i), n.push(i), t[r].outerHTML = `<precode language="${o}" precodenum="${r.toString()}"></precode>`; } else n.push(t[r].innerHTML), t[r].innerHTML = '', t[r].setAttribute('prenum', r.toString()); return n; } return o; }, this.setOption = function (e, n) { t[e] = n; }, this.getOption = function (e) { return t[e]; }, this.getOptions = function () { return t; }, this.addExtension = function (e, t) { t = t || null, p(e, t); }, this.useExtension = function (e) { p(e); }, this.setFlavor = function (e) { if (!f.hasOwnProperty(e)) throw Error(`${e} flavor was not found`); const n = f[e]; for (const r in o = e, n)n.hasOwnProperty(r) && (t[r] = n[r]); }, this.getFlavor = function () { return o; }, this.removeExtension = function (e) { a.helper.isArray(e) || (e = [e]); for (let t = 0; t < e.length; ++t) { for (var i = e[t], o = 0; o < n.length; ++o)n[o] === i && n[o].splice(o, 1); for (let s = 0; s < r.length; ++o)r[s] === i && r[s].splice(o, 1); } }, this.getAllExtensions = function () { return { language: n, output: r }; }, this.getMetadata = function (e) { return e ? s.raw : s.parsed; }, this.getMetadataFormat = function () { return s.format; }, this._setMetadataPair = function (e, t) { s.parsed[e] = t; }, this._setMetadataFormat = function (e) { s.format = e; }, this._setMetadataRaw = function (e) { s.raw = e; };
      }, a.subParser('anchors', ((e, t, n) => {
        e = n.converter._dispatch('anchors.before', e, t, n); const r = function (e, r, i, o, s, l, c) { if (a.helper.isUndefined(c) && (c = ''), i = i.toLowerCase(), e.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1)o = ''; else if (!o) { if (i || (i = r.toLowerCase().replace(/ ?\n/g, ' ')), o = `#${i}`, a.helper.isUndefined(n.gUrls[i])) return e; o = n.gUrls[i], a.helper.isUndefined(n.gTitles[i]) || (c = n.gTitles[i]); }o = o.replace(a.helper.regexes.asteriskDashAndColon, a.helper.escapeCharactersCallback); let u = `<a href="${o}"`; return c !== '' && c !== null && (c = c.replace(/"/g, '&quot;'), c = c.replace(a.helper.regexes.asteriskDashAndColon, a.helper.escapeCharactersCallback), u += ` title="${c}"`), t.openLinksInNewWindow && !/^#/.test(o) && (u += ' rel="noopener noreferrer" target="¨E95Eblank"'), u += `>${r}</a>`, u; }; return e = e.replace(/\[((?:\[[^\]]*]|[^\[\]])*)] ?(?:\n *)?\[(.*?)]()()()()/g, r), e = e.replace(/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<([^>]*)>(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g, r), e = e.replace(/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g, r), e = e.replace(/\[([^\[\]]+)]()()()()()/g, r), t.ghMentions && (e = e.replace(/(^|\s)(\\)?(@([a-z\d]+(?:[a-z\d.-]+?[a-z\d]+)*))/gim, ((e, n, r, i, o) => { if (r === '\\') return n + i; if (!a.helper.isString(t.ghMentionsLink)) throw new Error('ghMentionsLink option must be a string'); const s = t.ghMentionsLink.replace(/\{u}/g, o); let l = ''; return t.openLinksInNewWindow && (l = ' rel="noopener noreferrer" target="¨E95Eblank"'), `${n}<a href="${s}"${l}>${i}</a>`; }))), e = n.converter._dispatch('anchors.after', e, t, n), e;
      })); const m = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+?\.[^'">\s]+?)()(\1)?(?=\s|$)(?!["<>])/gi; const g = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+\.[^'">\s]+?)([.!?,()\[\]])?(\1)?(?=\s|$)(?!["<>])/gi; const v = /()<(((https?|ftp|dict):\/\/|www\.)[^'">\s]+)()>()/gi; const b = /(^|\s)(?:mailto:)?([A-Za-z0-9!#$%&'*+-/=?^_`{|}~.]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)(?=$|\s)/gim; const y = /<()(?:mailto:)?([-.\w]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi; const w = function (e) {
        return function (t, n, r, i, o, s, l) { r = r.replace(a.helper.regexes.asteriskDashAndColon, a.helper.escapeCharactersCallback); const c = r; let u = ''; let f = ''; const d = n || ''; const h = l || ''; return /^www\./i.test(r) && (r = r.replace(/^www\./i, 'http://www.')), e.excludeTrailingPunctuationFromURLs && s && (u = s), e.openLinksInNewWindow && (f = ' rel="noopener noreferrer" target="¨E95Eblank"'), `${d}<a href="${r}"${f}>${c}</a>${u}${h}`; };
      }; const x = function (e, t) {
        return function (n, r, i) { let o = 'mailto:'; return r = r || '', i = a.subParser('unescapeSpecialChars')(i, e, t), e.encodeEmails ? (o = a.helper.encodeEmailAddress(o + i), i = a.helper.encodeEmailAddress(i)) : o += i, `${r}<a href="${o}">${i}</a>`; };
      }; a.subParser('autoLinks', ((e, t, n) => (e = n.converter._dispatch('autoLinks.before', e, t, n), e = e.replace(v, w(t)), e = e.replace(y, x(t, n)), e = n.converter._dispatch('autoLinks.after', e, t, n), e))), a.subParser('simplifiedAutoLinks', ((e, t, n) => (t.simplifiedAutoLink ? (e = n.converter._dispatch('simplifiedAutoLinks.before', e, t, n), e = t.excludeTrailingPunctuationFromURLs ? e.replace(g, w(t)) : e.replace(m, w(t)), e = e.replace(b, x(t, n)), e = n.converter._dispatch('simplifiedAutoLinks.after', e, t, n), e) : e))), a.subParser('blockGamut', ((e, t, n) => (e = n.converter._dispatch('blockGamut.before', e, t, n), e = a.subParser('blockQuotes')(e, t, n), e = a.subParser('headers')(e, t, n), e = a.subParser('horizontalRule')(e, t, n), e = a.subParser('lists')(e, t, n), e = a.subParser('codeBlocks')(e, t, n), e = a.subParser('tables')(e, t, n), e = a.subParser('hashHTMLBlocks')(e, t, n), e = a.subParser('paragraphs')(e, t, n), e = n.converter._dispatch('blockGamut.after', e, t, n), e))), a.subParser('blockQuotes', ((e, t, n) => {
        e = n.converter._dispatch('blockQuotes.before', e, t, n), e += '\n\n'; let r = /(^ {0,3}>[ \t]?.+\n(.+\n)*\n*)+/gm; return t.splitAdjacentBlockquotes && (r = /^ {0,3}>[\s\S]*?(?:\n\n)/gm), e = e.replace(r, ((e) => (e = e.replace(/^[ \t]*>[ \t]?/gm, ''), e = e.replace(/¨0/g, ''), e = e.replace(/^[ \t]+$/gm, ''), e = a.subParser('githubCodeBlocks')(e, t, n), e = a.subParser('blockGamut')(e, t, n), e = e.replace(/(^|\n)/g, '$1  '), e = e.replace(/(\s*<pre>[^\r]+?<\/pre>)/gm, ((e, t) => { let n = t; return n = n.replace(/^ {2}/gm, '¨0'), n = n.replace(/¨0/g, ''), n; })), a.subParser('hashBlock')(`<blockquote>\n${e}\n</blockquote>`, t, n)))), e = n.converter._dispatch('blockQuotes.after', e, t, n), e;
      })), a.subParser('codeBlocks', ((e, t, n) => {
        e = n.converter._dispatch('codeBlocks.before', e, t, n), e += '¨0'; const r = /(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=¨0))/g; return e = e.replace(r, ((e, r, i) => { let o = r; const s = i; let l = '\n'; return o = a.subParser('outdent')(o, t, n), o = a.subParser('encodeCode')(o, t, n), o = a.subParser('detab')(o, t, n), o = o.replace(/^\n+/g, ''), o = o.replace(/\n+$/g, ''), t.omitExtraWLInCodeBlocks && (l = ''), o = `<pre><code>${o}${l}</code></pre>`, a.subParser('hashBlock')(o, t, n) + s; })), e = e.replace(/¨0/, ''), e = n.converter._dispatch('codeBlocks.after', e, t, n), e;
      })), a.subParser('codeSpans', ((e, t, n) => (e = n.converter._dispatch('codeSpans.before', e, t, n), typeof e === 'undefined' && (e = ''), e = e.replace(/(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm, ((e, r, i, o) => { let s = o; return s = s.replace(/^([ \t]*)/g, ''), s = s.replace(/[ \t]*$/g, ''), s = a.subParser('encodeCode')(s, t, n), s = `${r}<code>${s}</code>`, s = a.subParser('hashHTMLSpans')(s, t, n), s; })), e = n.converter._dispatch('codeSpans.after', e, t, n), e))), a.subParser('completeHTMLDocument', ((e, t, n) => {
        if (!t.completeHTMLDocument) return e; e = n.converter._dispatch('completeHTMLDocument.before', e, t, n); let r = 'html'; let i = '<!DOCTYPE HTML>\n'; let o = ''; let a = '<meta charset="utf-8">\n'; let s = ''; let l = ''; for (const c in typeof n.metadata.parsed.doctype !== 'undefined' && (i = `<!DOCTYPE ${n.metadata.parsed.doctype}>\n`, r = n.metadata.parsed.doctype.toString().toLowerCase(), r !== 'html' && r !== 'html5' || (a = '<meta charset="utf-8">')), n.metadata.parsed) if (n.metadata.parsed.hasOwnProperty(c)) switch (c.toLowerCase()) { case 'doctype': break; case 'title': o = `<title>${n.metadata.parsed.title}</title>\n`; break; case 'charset': a = r === 'html' || r === 'html5' ? `<meta charset="${n.metadata.parsed.charset}">\n` : `<meta name="charset" content="${n.metadata.parsed.charset}">\n`; break; case 'language': case 'lang': s = ` lang="${n.metadata.parsed[c]}"`, l += `<meta name="${c}" content="${n.metadata.parsed[c]}">\n`; break; default: l += `<meta name="${c}" content="${n.metadata.parsed[c]}">\n`; } return e = `${i}<html${s}>\n<head>\n${o}${a}${l}</head>\n<body>\n${e.trim()}\n</body>\n</html>`, e = n.converter._dispatch('completeHTMLDocument.after', e, t, n), e;
      })), a.subParser('detab', ((e, t, n) => (e = n.converter._dispatch('detab.before', e, t, n), e = e.replace(/\t(?=\t)/g, '    '), e = e.replace(/\t/g, '¨A¨B'), e = e.replace(/¨B(.+?)¨A/g, ((e, t) => { for (var n = t, r = 4 - n.length % 4, i = 0; i < r; i++)n += ' '; return n; })), e = e.replace(/¨A/g, '    '), e = e.replace(/¨B/g, ''), e = n.converter._dispatch('detab.after', e, t, n), e))), a.subParser('ellipsis', ((e, t, n) => (e = n.converter._dispatch('ellipsis.before', e, t, n), e = e.replace(/\.\.\./g, '…'), e = n.converter._dispatch('ellipsis.after', e, t, n), e))), a.subParser('emoji', ((e, t, n) => {
        if (!t.emoji) return e; e = n.converter._dispatch('emoji.before', e, t, n); const r = /:([\S]+?):/g; return e = e.replace(r, ((e, t) => (a.helper.emojis.hasOwnProperty(t) ? a.helper.emojis[t] : e))), e = n.converter._dispatch('emoji.after', e, t, n), e;
      })), a.subParser('encodeAmpsAndAngles', ((e, t, n) => (e = n.converter._dispatch('encodeAmpsAndAngles.before', e, t, n), e = e.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g, '&amp;'), e = e.replace(/<(?![a-z\/?$!])/gi, '&lt;'), e = e.replace(/</g, '&lt;'), e = e.replace(/>/g, '&gt;'), e = n.converter._dispatch('encodeAmpsAndAngles.after', e, t, n), e))), a.subParser('encodeBackslashEscapes', ((e, t, n) => (e = n.converter._dispatch('encodeBackslashEscapes.before', e, t, n), e = e.replace(/\\(\\)/g, a.helper.escapeCharactersCallback), e = e.replace(/\\([`*_{}\[\]()>#+.!~=|-])/g, a.helper.escapeCharactersCallback), e = n.converter._dispatch('encodeBackslashEscapes.after', e, t, n), e))), a.subParser('encodeCode', ((e, t, n) => (e = n.converter._dispatch('encodeCode.before', e, t, n), e = e.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/([*_{}\[\]\\=~-])/g, a.helper.escapeCharactersCallback), e = n.converter._dispatch('encodeCode.after', e, t, n), e))), a.subParser('escapeSpecialCharsWithinTagAttributes', ((e, t, n) => {
        e = n.converter._dispatch('escapeSpecialCharsWithinTagAttributes.before', e, t, n); const r = /<\/?[a-z\d_:-]+(?:[\s]+[\s\S]+?)?>/gi; const i = /<!(--(?:(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>/gi; return e = e.replace(r, ((e) => e.replace(/(.)<\/?code>(?=.)/g, '$1`').replace(/([\\`*_~=|])/g, a.helper.escapeCharactersCallback))), e = e.replace(i, ((e) => e.replace(/([\\`*_~=|])/g, a.helper.escapeCharactersCallback))), e = n.converter._dispatch('escapeSpecialCharsWithinTagAttributes.after', e, t, n), e;
      })), a.subParser('githubCodeBlocks', ((e, t, n) => (t.ghCodeBlocks ? (e = n.converter._dispatch('githubCodeBlocks.before', e, t, n), e += '¨0', e = e.replace(/(?:^|\n)(?: {0,3})(```+|~~~+)(?: *)([^\s`~]*)\n([\s\S]*?)\n(?: {0,3})\1/g, ((e, r, i, o) => { const s = t.omitExtraWLInCodeBlocks ? '' : '\n'; return o = a.subParser('encodeCode')(o, t, n), o = a.subParser('detab')(o, t, n), o = o.replace(/^\n+/g, ''), o = o.replace(/\n+$/g, ''), o = `<pre><code${i ? ` class="${i} language-${i}"` : ''}>${o}${s}</code></pre>`, o = a.subParser('hashBlock')(o, t, n), `\n\n¨G${n.ghCodeBlocks.push({ text: e, codeblock: o }) - 1}G\n\n`; })), e = e.replace(/¨0/, ''), n.converter._dispatch('githubCodeBlocks.after', e, t, n)) : e))), a.subParser('hashBlock', ((e, t, n) => (e = n.converter._dispatch('hashBlock.before', e, t, n), e = e.replace(/(^\n+|\n+$)/g, ''), e = `\n\n¨K${n.gHtmlBlocks.push(e) - 1}K\n\n`, e = n.converter._dispatch('hashBlock.after', e, t, n), e))), a.subParser('hashCodeTags', ((e, t, n) => {
        e = n.converter._dispatch('hashCodeTags.before', e, t, n); const r = function (e, r, i, o) { const s = i + a.subParser('encodeCode')(r, t, n) + o; return `¨C${n.gHtmlSpans.push(s) - 1}C`; }; return e = a.helper.replaceRecursiveRegExp(e, r, '<code\\b[^>]*>', '</code>', 'gim'), e = n.converter._dispatch('hashCodeTags.after', e, t, n), e;
      })), a.subParser('hashElement', ((e, t, n) => function (e, t) { let r = t; return r = r.replace(/\n\n/g, '\n'), r = r.replace(/^\n/, ''), r = r.replace(/\n+$/g, ''), r = `\n\n¨K${n.gHtmlBlocks.push(r) - 1}K\n\n`, r; })), a.subParser('hashHTMLBlocks', ((e, t, n) => {
        e = n.converter._dispatch('hashHTMLBlocks.before', e, t, n); const r = ['pre', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'table', 'dl', 'ol', 'ul', 'script', 'noscript', 'form', 'fieldset', 'iframe', 'math', 'style', 'section', 'header', 'footer', 'nav', 'article', 'aside', 'address', 'audio', 'canvas', 'figure', 'hgroup', 'output', 'video', 'p']; const i = function (e, t, r, i) { let o = e; return r.search(/\bmarkdown\b/) !== -1 && (o = r + n.converter.makeHtml(t) + i), `\n\n¨K${n.gHtmlBlocks.push(o) - 1}K\n\n`; }; t.backslashEscapesHTMLTags && (e = e.replace(/\\<(\/?[^>]+?)>/g, ((e, t) => `&lt;${t}&gt;`))); for (let o = 0; o < r.length; ++o) { var s; const l = new RegExp(`^ {0,3}(<${r[o]}\\b[^>]*>)`, 'im'); const c = `<${r[o]}\\b[^>]*>`; const u = `</${r[o]}>`; while ((s = a.helper.regexIndexOf(e, l)) !== -1) { const f = a.helper.splitAtIndex(e, s); const d = a.helper.replaceRecursiveRegExp(f[1], i, c, u, 'im'); if (d === f[1]) break; e = f[0].concat(d); } } return e = e.replace(/(\n {0,3}(<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g, a.subParser('hashElement')(e, t, n)), e = a.helper.replaceRecursiveRegExp(e, ((e) => `\n\n¨K${n.gHtmlBlocks.push(e) - 1}K\n\n`), '^ {0,3}\x3c!--', '--\x3e', 'gm'), e = e.replace(/(?:\n\n)( {0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g, a.subParser('hashElement')(e, t, n)), e = n.converter._dispatch('hashHTMLBlocks.after', e, t, n), e;
      })), a.subParser('hashHTMLSpans', ((e, t, n) => {
        function r(e) { return `¨C${n.gHtmlSpans.push(e) - 1}C`; } return e = n.converter._dispatch('hashHTMLSpans.before', e, t, n), e = e.replace(/<[^>]+?\/>/gi, ((e) => r(e))), e = e.replace(/<([^>]+?)>[\s\S]*?<\/\1>/g, ((e) => r(e))), e = e.replace(/<([^>]+?)\s[^>]+?>[\s\S]*?<\/\1>/g, ((e) => r(e))), e = e.replace(/<[^>]+?>/gi, ((e) => r(e))), e = n.converter._dispatch('hashHTMLSpans.after', e, t, n), e;
      })), a.subParser('unhashHTMLSpans', ((e, t, n) => {
        e = n.converter._dispatch('unhashHTMLSpans.before', e, t, n); for (let r = 0; r < n.gHtmlSpans.length; ++r) { let i = n.gHtmlSpans[r]; let o = 0; while (/¨C(\d+)C/.test(i)) { const a = RegExp.$1; if (i = i.replace(`¨C${a}C`, n.gHtmlSpans[a]), o === 10) { console.error('maximum nesting of 10 spans reached!!!'); break; }++o; }e = e.replace(`¨C${r}C`, i); } return e = n.converter._dispatch('unhashHTMLSpans.after', e, t, n), e;
      })), a.subParser('hashPreCodeTags', ((e, t, n) => {
        e = n.converter._dispatch('hashPreCodeTags.before', e, t, n); const r = function (e, r, i, o) { const s = i + a.subParser('encodeCode')(r, t, n) + o; return `\n\n¨G${n.ghCodeBlocks.push({ text: e, codeblock: s }) - 1}G\n\n`; }; return e = a.helper.replaceRecursiveRegExp(e, r, '^ {0,3}<pre\\b[^>]*>\\s*<code\\b[^>]*>', '^ {0,3}</code>\\s*</pre>', 'gim'), e = n.converter._dispatch('hashPreCodeTags.after', e, t, n), e;
      })), a.subParser('headers', ((e, t, n) => {
        e = n.converter._dispatch('headers.before', e, t, n); const r = isNaN(parseInt(t.headerLevelStart)) ? 1 : parseInt(t.headerLevelStart); const i = t.smoothLivePreview ? /^(.+)[ \t]*\n={2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n=+[ \t]*\n+/gm; const o = t.smoothLivePreview ? /^(.+)[ \t]*\n-{2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n-+[ \t]*\n+/gm; e = e.replace(i, ((e, i) => { const o = a.subParser('spanGamut')(i, t, n); const s = t.noHeaderId ? '' : ` id="${l(i)}"`; const c = r; const u = `<h${c}${s}>${o}</h${c}>`; return a.subParser('hashBlock')(u, t, n); })), e = e.replace(o, ((e, i) => { const o = a.subParser('spanGamut')(i, t, n); const s = t.noHeaderId ? '' : ` id="${l(i)}"`; const c = r + 1; const u = `<h${c}${s}>${o}</h${c}>`; return a.subParser('hashBlock')(u, t, n); })); const s = t.requireSpaceBeforeHeadingText ? /^(#{1,6})[ \t]+(.+?)[ \t]*#*\n+/gm : /^(#{1,6})[ \t]*(.+?)[ \t]*#*\n+/gm; function l(e) {
          let r; let i; if (t.customizedHeaderId) { const o = e.match(/\{([^{]+?)}\s*$/); o && o[1] && (e = o[1]); } return r = e, i = a.helper.isString(t.prefixHeaderId) ? t.prefixHeaderId : !0 === t.prefixHeaderId ? 'section-' : '', t.rawPrefixHeaderId || (r = i + r), r = t.ghCompatibleHeaderId ? r.replace(/ /g, '-').replace(/&amp;/g, '').replace(/¨T/g, '').replace(/¨D/g, '')
            .replace(/[&+$,\/:;=?@"#{}|^¨~\[\]`\\*)(%.!'<>]/g, '')
            .toLowerCase() : t.rawHeaderId ? r.replace(/ /g, '-').replace(/&amp;/g, '&').replace(/¨T/g, '¨').replace(/¨D/g, '$')
            .replace(/["']/g, '-')
            .toLowerCase() : r.replace(/[^\w]/g, '').toLowerCase(), t.rawPrefixHeaderId && (r = i + r), n.hashLinkCounts[r] ? r = `${r}-${n.hashLinkCounts[r]++}` : n.hashLinkCounts[r] = 1, r;
        } return e = e.replace(s, ((e, i, o) => { let s = o; t.customizedHeaderId && (s = o.replace(/\s?\{([^{]+?)}\s*$/, '')); const c = a.subParser('spanGamut')(s, t, n); const u = t.noHeaderId ? '' : ` id="${l(o)}"`; const f = r - 1 + i.length; const d = `<h${f}${u}>${c}</h${f}>`; return a.subParser('hashBlock')(d, t, n); })), e = n.converter._dispatch('headers.after', e, t, n), e;
      })), a.subParser('horizontalRule', ((e, t, n) => {
        e = n.converter._dispatch('horizontalRule.before', e, t, n); const r = a.subParser('hashBlock')('<hr />', t, n); return e = e.replace(/^ {0,2}( ?-){3,}[ \t]*$/gm, r), e = e.replace(/^ {0,2}( ?\*){3,}[ \t]*$/gm, r), e = e.replace(/^ {0,2}( ?_){3,}[ \t]*$/gm, r), e = n.converter._dispatch('horizontalRule.after', e, t, n), e;
      })), a.subParser('images', ((e, t, n) => {
        e = n.converter._dispatch('images.before', e, t, n); const r = /!\[([^\]]*?)][ \t]*()\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g; const i = /!\[([^\]]*?)][ \t]*()\([ \t]?<([^>]*)>(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(?:(["'])([^"]*?)\6))?[ \t]?\)/g; const o = /!\[([^\]]*?)][ \t]*()\([ \t]?<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g; const s = /!\[([^\]]*?)] ?(?:\n *)?\[([\s\S]*?)]()()()()()/g; const l = /!\[([^\[\]]+)]()()()()()/g; function c(e, t, n, r, i, o, a, s) { return r = r.replace(/\s/g, ''), u(e, t, n, r, i, o, a, s); } function u(e, t, r, i, o, s, l, c) { const u = n.gUrls; const f = n.gTitles; const d = n.gDimensions; if (r = r.toLowerCase(), c || (c = ''), e.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1)i = ''; else if (i === '' || i === null) { if (r !== '' && r !== null || (r = t.toLowerCase().replace(/ ?\n/g, ' ')), i = `#${r}`, a.helper.isUndefined(u[r])) return e; i = u[r], a.helper.isUndefined(f[r]) || (c = f[r]), a.helper.isUndefined(d[r]) || (o = d[r].width, s = d[r].height); }t = t.replace(/"/g, '&quot;').replace(a.helper.regexes.asteriskDashAndColon, a.helper.escapeCharactersCallback), i = i.replace(a.helper.regexes.asteriskDashAndColon, a.helper.escapeCharactersCallback); let h = `<img src="${i}" alt="${t}"`; return c && a.helper.isString(c) && (c = c.replace(/"/g, '&quot;').replace(a.helper.regexes.asteriskDashAndColon, a.helper.escapeCharactersCallback), h += ` title="${c}"`), o && s && (o = o === '*' ? 'auto' : o, s = s === '*' ? 'auto' : s, h += ` width="${o}"`, h += ` height="${s}"`), h += ' />', h; } return e = e.replace(s, u), e = e.replace(o, c), e = e.replace(i, u), e = e.replace(r, u), e = e.replace(l, u), e = n.converter._dispatch('images.after', e, t, n), e;
      })), a.subParser('italicsAndBold', ((e, t, n) => {
        function r(e, t, n) { return t + e + n; } return e = n.converter._dispatch('italicsAndBold.before', e, t, n), t.literalMidWordUnderscores ? (e = e.replace(/\b___(\S[\s\S]*?)___\b/g, ((e, t) => r(t, '<strong><em>', '</em></strong>'))), e = e.replace(/\b__(\S[\s\S]*?)__\b/g, ((e, t) => r(t, '<strong>', '</strong>'))), e = e.replace(/\b_(\S[\s\S]*?)_\b/g, ((e, t) => r(t, '<em>', '</em>')))) : (e = e.replace(/___(\S[\s\S]*?)___/g, ((e, t) => (/\S$/.test(t) ? r(t, '<strong><em>', '</em></strong>') : e))), e = e.replace(/__(\S[\s\S]*?)__/g, ((e, t) => (/\S$/.test(t) ? r(t, '<strong>', '</strong>') : e))), e = e.replace(/_([^\s_][\s\S]*?)_/g, ((e, t) => (/\S$/.test(t) ? r(t, '<em>', '</em>') : e)))), t.literalMidWordAsterisks ? (e = e.replace(/([^*]|^)\B\*\*\*(\S[\s\S]*?)\*\*\*\B(?!\*)/g, ((e, t, n) => r(n, `${t}<strong><em>`, '</em></strong>'))), e = e.replace(/([^*]|^)\B\*\*(\S[\s\S]*?)\*\*\B(?!\*)/g, ((e, t, n) => r(n, `${t}<strong>`, '</strong>'))), e = e.replace(/([^*]|^)\B\*(\S[\s\S]*?)\*\B(?!\*)/g, ((e, t, n) => r(n, `${t}<em>`, '</em>')))) : (e = e.replace(/\*\*\*(\S[\s\S]*?)\*\*\*/g, ((e, t) => (/\S$/.test(t) ? r(t, '<strong><em>', '</em></strong>') : e))), e = e.replace(/\*\*(\S[\s\S]*?)\*\*/g, ((e, t) => (/\S$/.test(t) ? r(t, '<strong>', '</strong>') : e))), e = e.replace(/\*([^\s*][\s\S]*?)\*/g, ((e, t) => (/\S$/.test(t) ? r(t, '<em>', '</em>') : e)))), e = n.converter._dispatch('italicsAndBold.after', e, t, n), e;
      })), a.subParser('lists', ((e, t, n) => {
        function r(e, r) { n.gListLevel++, e = e.replace(/\n{2,}$/, '\n'), e += '¨0'; let i = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(¨0| {0,3}([*+-]|\d+[.])[ \t]+))/gm; const o = /\n[ \t]*\n(?!¨0)/.test(e); return t.disableForced4SpacesIndentedSublists && (i = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(¨0|\2([*+-]|\d+[.])[ \t]+))/gm), e = e.replace(i, ((e, r, i, s, l, c, u) => { u = u && u.trim() !== ''; let f = a.subParser('outdent')(l, t, n); let d = ''; return c && t.tasklists && (d = ' class="task-list-item" style="list-style-type: none;"', f = f.replace(/^[ \t]*\[(x|X| )?]/m, (() => { let e = '<input type="checkbox" disabled style="margin: 0px 0.35em 0.25em -1.6em; vertical-align: middle;"'; return u && (e += ' checked'), e += '>', e; }))), f = f.replace(/^([-*+]|\d\.)[ \t]+[\S\n ]*/g, ((e) => `¨A${e}`)), r || f.search(/\n{2,}/) > -1 ? (f = a.subParser('githubCodeBlocks')(f, t, n), f = a.subParser('blockGamut')(f, t, n)) : (f = a.subParser('lists')(f, t, n), f = f.replace(/\n$/, ''), f = a.subParser('hashHTMLBlocks')(f, t, n), f = f.replace(/\n\n+/g, '\n\n'), f = o ? a.subParser('paragraphs')(f, t, n) : a.subParser('spanGamut')(f, t, n)), f = f.replace('¨A', ''), f = `<li${d}>${f}</li>\n`, f; })), e = e.replace(/¨0/g, ''), n.gListLevel--, r && (e = e.replace(/\s+$/, '')), e; } function i(e, t) { if (t === 'ol') { const n = e.match(/^ *(\d+)\./); if (n && n[1] !== '1') return ` start="${n[1]}"`; } return ''; } function o(e, n, o) { const a = t.disableForced4SpacesIndentedSublists ? /^ ?\d+\.[ \t]/gm : /^ {0,3}\d+\.[ \t]/gm; const s = t.disableForced4SpacesIndentedSublists ? /^ ?[*+-][ \t]/gm : /^ {0,3}[*+-][ \t]/gm; let l = n === 'ul' ? a : s; let c = ''; if (e.search(l) !== -1)(function t(u) { const f = u.search(l); const d = i(e, n); f !== -1 ? (c += `\n\n<${n}${d}>\n${r(u.slice(0, f), !!o)}</${n}>\n`, n = n === 'ul' ? 'ol' : 'ul', l = n === 'ul' ? a : s, t(u.slice(f))) : c += `\n\n<${n}${d}>\n${r(u, !!o)}</${n}>\n`; }(e)); else { const u = i(e, n); c = `\n\n<${n}${u}>\n${r(e, !!o)}</${n}>\n`; } return c; } return e = n.converter._dispatch('lists.before', e, t, n), e += '¨0', e = n.gListLevel ? e.replace(/^(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(¨0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm, ((e, t, n) => { const r = n.search(/[*+-]/g) > -1 ? 'ul' : 'ol'; return o(t, r, !0); })) : e.replace(/(\n\n|^\n?)(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(¨0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm, ((e, t, n, r) => { const i = r.search(/[*+-]/g) > -1 ? 'ul' : 'ol'; return o(n, i, !1); })), e = e.replace(/¨0/, ''), e = n.converter._dispatch('lists.after', e, t, n), e;
      })), a.subParser('metadata', ((e, t, n) => {
        if (!t.metadata) return e; function r(e) { n.metadata.raw = e, e = e.replace(/&/g, '&amp;').replace(/"/g, '&quot;'), e = e.replace(/\n {4}/g, ' '), e.replace(/^([\S ]+): +([\s\S]+?)$/gm, ((e, t, r) => (n.metadata.parsed[t] = r, ''))); } return e = n.converter._dispatch('metadata.before', e, t, n), e = e.replace(/^\s*«««+(\S*?)\n([\s\S]+?)\n»»»+\n/, ((e, t, n) => (r(n), '¨M'))), e = e.replace(/^\s*---+(\S*?)\n([\s\S]+?)\n---+\n/, ((e, t, i) => (t && (n.metadata.format = t), r(i), '¨M'))), e = e.replace(/¨M/g, ''), e = n.converter._dispatch('metadata.after', e, t, n), e;
      })), a.subParser('outdent', ((e, t, n) => (e = n.converter._dispatch('outdent.before', e, t, n), e = e.replace(/^(\t|[ ]{1,4})/gm, '¨0'), e = e.replace(/¨0/g, ''), e = n.converter._dispatch('outdent.after', e, t, n), e))), a.subParser('paragraphs', ((e, t, n) => {
        e = n.converter._dispatch('paragraphs.before', e, t, n), e = e.replace(/^\n+/g, ''), e = e.replace(/\n+$/g, ''); for (var r = e.split(/\n{2,}/g), i = [], o = r.length, s = 0; s < o; s++) { let l = r[s]; l.search(/¨(K|G)(\d+)\1/g) >= 0 ? i.push(l) : l.search(/\S/) >= 0 && (l = a.subParser('spanGamut')(l, t, n), l = l.replace(/^([ \t]*)/g, '<p>'), l += '</p>', i.push(l)); } for (o = i.length, s = 0; s < o; s++) { let c = ''; let u = i[s]; let f = !1; while (/¨(K|G)(\d+)\1/.test(u)) { const d = RegExp.$1; const h = RegExp.$2; c = d === 'K' ? n.gHtmlBlocks[h] : f ? a.subParser('encodeCode')(n.ghCodeBlocks[h].text, t, n) : n.ghCodeBlocks[h].codeblock, c = c.replace(/\$/g, '$$$$'), u = u.replace(/(\n\n)?¨(K|G)\d+\2(\n\n)?/, c), /^<pre\b[^>]*>\s*<code\b[^>]*>/.test(u) && (f = !0); }i[s] = u; } return e = i.join('\n'), e = e.replace(/^\n+/g, ''), e = e.replace(/\n+$/g, ''), n.converter._dispatch('paragraphs.after', e, t, n);
      })), a.subParser('runExtension', ((e, t, n, r) => {
        if (e.filter)t = e.filter(t, r.converter, n); else if (e.regex) { let i = e.regex; i instanceof RegExp || (i = new RegExp(i, 'g')), t = t.replace(i, e.replace); } return t;
      })), a.subParser('spanGamut', ((e, t, n) => (e = n.converter._dispatch('spanGamut.before', e, t, n), e = a.subParser('codeSpans')(e, t, n), e = a.subParser('escapeSpecialCharsWithinTagAttributes')(e, t, n), e = a.subParser('encodeBackslashEscapes')(e, t, n), e = a.subParser('images')(e, t, n), e = a.subParser('anchors')(e, t, n), e = a.subParser('autoLinks')(e, t, n), e = a.subParser('simplifiedAutoLinks')(e, t, n), e = a.subParser('emoji')(e, t, n), e = a.subParser('underline')(e, t, n), e = a.subParser('italicsAndBold')(e, t, n), e = a.subParser('strikethrough')(e, t, n), e = a.subParser('ellipsis')(e, t, n), e = a.subParser('hashHTMLSpans')(e, t, n), e = a.subParser('encodeAmpsAndAngles')(e, t, n), t.simpleLineBreaks ? /\n\n¨K/.test(e) || (e = e.replace(/\n+/g, '<br />\n')) : e = e.replace(/  +\n/g, '<br />\n'), e = n.converter._dispatch('spanGamut.after', e, t, n), e))), a.subParser('strikethrough', ((e, t, n) => {
        function r(e) { return t.simplifiedAutoLink && (e = a.subParser('simplifiedAutoLinks')(e, t, n)), `<del>${e}</del>`; } return t.strikethrough && (e = n.converter._dispatch('strikethrough.before', e, t, n), e = e.replace(/(?:~){2}([\s\S]+?)(?:~){2}/g, ((e, t) => r(t))), e = n.converter._dispatch('strikethrough.after', e, t, n)), e;
      })), a.subParser('stripLinkDefinitions', ((e, t, n) => {
        const r = /^ {0,3}\[(.+)]:[ \t]*\n?[ \t]*<?([^>\s]+)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n+|(?=¨0))/gm; const i = /^ {0,3}\[(.+)]:[ \t]*\n?[ \t]*<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n\n|(?=¨0)|(?=\n\[))/gm; e += '¨0'; const o = function (e, r, i, o, s, l, c) { return r = r.toLowerCase(), i.match(/^data:.+?\/.+?;base64,/) ? n.gUrls[r] = i.replace(/\s/g, '') : n.gUrls[r] = a.subParser('encodeAmpsAndAngles')(i, t, n), l ? l + c : (c && (n.gTitles[r] = c.replace(/"|'/g, '&quot;')), t.parseImgDimensions && o && s && (n.gDimensions[r] = { width: o, height: s }), ''); }; return e = e.replace(i, o), e = e.replace(r, o), e = e.replace(/¨0/, ''), e;
      })), a.subParser('tables', ((e, t, n) => {
        if (!t.tables) return e; const r = /^ {0,3}\|?.+\|.+\n {0,3}\|?[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*:?[ \t]*(?:[-=]){2,}[\s\S]+?(?:\n\n|¨0)/gm; const i = /^ {0,3}\|.+\|[ \t]*\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n( {0,3}\|.+\|[ \t]*\n)*(?:\n|¨0)/gm; function o(e) { return /^:[ \t]*--*$/.test(e) ? ' style="text-align:left;"' : /^--*[ \t]*:[ \t]*$/.test(e) ? ' style="text-align:right;"' : /^:[ \t]*--*[ \t]*:$/.test(e) ? ' style="text-align:center;"' : ''; } function s(e, r) { let i = ''; return e = e.trim(), (t.tablesHeaderId || t.tableHeaderId) && (i = ` id="${e.replace(/ /g, '_').toLowerCase()}"`), e = a.subParser('spanGamut')(e, t, n), `<th${i}${r}>${e}</th>\n`; } function l(e, r) { const i = a.subParser('spanGamut')(e, t, n); return `<td${r}>${i}</td>\n`; } function c(e, t) { for (var n = '<table>\n<thead>\n<tr>\n', r = e.length, i = 0; i < r; ++i)n += e[i]; for (n += '</tr>\n</thead>\n<tbody>\n', i = 0; i < t.length; ++i) { n += '<tr>\n'; for (let o = 0; o < r; ++o)n += t[i][o]; n += '</tr>\n'; } return n += '</tbody>\n</table>\n', n; } function u(e) { let r; const i = e.split('\n'); for (r = 0; r < i.length; ++r)/^ {0,3}\|/.test(i[r]) && (i[r] = i[r].replace(/^ {0,3}\|/, '')), /\|[ \t]*$/.test(i[r]) && (i[r] = i[r].replace(/\|[ \t]*$/, '')), i[r] = a.subParser('codeSpans')(i[r], t, n); const u = i[0].split('|').map(((e) => e.trim())); const f = i[1].split('|').map(((e) => e.trim())); const d = []; const h = []; const p = []; const m = []; for (i.shift(), i.shift(), r = 0; r < i.length; ++r)i[r].trim() !== '' && d.push(i[r].split('|').map(((e) => e.trim()))); if (u.length < f.length) return e; for (r = 0; r < f.length; ++r)p.push(o(f[r])); for (r = 0; r < u.length; ++r)a.helper.isUndefined(p[r]) && (p[r] = ''), h.push(s(u[r], p[r])); for (r = 0; r < d.length; ++r) { for (var g = [], v = 0; v < h.length; ++v)a.helper.isUndefined(d[r][v]), g.push(l(d[r][v], p[v])); m.push(g); } return c(h, m); } return e = n.converter._dispatch('tables.before', e, t, n), e = e.replace(/\\(\|)/g, a.helper.escapeCharactersCallback), e = e.replace(r, u), e = e.replace(i, u), e = n.converter._dispatch('tables.after', e, t, n), e;
      })), a.subParser('underline', ((e, t, n) => (t.underline ? (e = n.converter._dispatch('underline.before', e, t, n), t.literalMidWordUnderscores ? (e = e.replace(/\b___(\S[\s\S]*?)___\b/g, ((e, t) => `<u>${t}</u>`)), e = e.replace(/\b__(\S[\s\S]*?)__\b/g, ((e, t) => `<u>${t}</u>`))) : (e = e.replace(/___(\S[\s\S]*?)___/g, ((e, t) => (/\S$/.test(t) ? `<u>${t }</u>` : e))), e = e.replace(/__(\S[\s\S]*?)__/g, ((e, t) => (/\S$/.test(t) ? `<u>${t }</u>` : e)))), e = e.replace(/(_)/g, a.helper.escapeCharactersCallback), e = n.converter._dispatch('underline.after', e, t, n), e) : e))), a.subParser('unescapeSpecialChars', ((e, t, n) => (e = n.converter._dispatch('unescapeSpecialChars.before', e, t, n), e = e.replace(/¨E(\d+)E/g, ((e, t) => { const n = parseInt(t); return String.fromCharCode(n); })), e = n.converter._dispatch('unescapeSpecialChars.after', e, t, n), e))), a.subParser('makeMarkdown.blockquote', ((e, t) => {
        let n = ''; if (e.hasChildNodes()) for (let r = e.childNodes, i = r.length, o = 0; o < i; ++o) { const s = a.subParser('makeMarkdown.node')(r[o], t); s !== '' && (n += s); } return n = n.trim(), n = `> ${n.split('\n').join('\n> ')}`, n;
      })), a.subParser('makeMarkdown.codeBlock', ((e, t) => {
        const n = e.getAttribute('language'); const r = e.getAttribute('precodenum'); return `\`\`\`${n}\n${t.preList[r]}\n\`\`\``;
      })), a.subParser('makeMarkdown.codeSpan', ((e) => `\`${e.innerHTML}\``)), a.subParser('makeMarkdown.emphasis', ((e, t) => {
        let n = ''; if (e.hasChildNodes()) { n += '*'; for (let r = e.childNodes, i = r.length, o = 0; o < i; ++o)n += a.subParser('makeMarkdown.node')(r[o], t); n += '*'; } return n;
      })), a.subParser('makeMarkdown.header', ((e, t, n) => {
        const r = new Array(n + 1).join('#'); let i = ''; if (e.hasChildNodes()) { i = `${r} `; for (let o = e.childNodes, s = o.length, l = 0; l < s; ++l)i += a.subParser('makeMarkdown.node')(o[l], t); } return i;
      })), a.subParser('makeMarkdown.hr', (() => '---')), a.subParser('makeMarkdown.image', ((e) => {
        let t = ''; return e.hasAttribute('src') && (t += `![${e.getAttribute('alt')}](`, t += `<${e.getAttribute('src')}>`, e.hasAttribute('width') && e.hasAttribute('height') && (t += ` =${e.getAttribute('width')}x${e.getAttribute('height')}`), e.hasAttribute('title') && (t += ` "${e.getAttribute('title')}"`), t += ')'), t;
      })), a.subParser('makeMarkdown.links', ((e, t) => {
        let n = ''; if (e.hasChildNodes() && e.hasAttribute('href')) { const r = e.childNodes; const i = r.length; n = '['; for (let o = 0; o < i; ++o)n += a.subParser('makeMarkdown.node')(r[o], t); n += '](', n += `<${e.getAttribute('href')}>`, e.hasAttribute('title') && (n += ` "${e.getAttribute('title')}"`), n += ')'; } return n;
      })), a.subParser('makeMarkdown.list', ((e, t, n) => {
        let r = ''; if (!e.hasChildNodes()) return ''; for (let i = e.childNodes, o = i.length, s = e.getAttribute('start') || 1, l = 0; l < o; ++l) if (typeof i[l].tagName !== 'undefined' && i[l].tagName.toLowerCase() === 'li') { let c = ''; c = n === 'ol' ? `${s.toString()}. ` : '- ', r += c + a.subParser('makeMarkdown.listItem')(i[l], t), ++s; } return r += '\n\x3c!-- --\x3e\n', r.trim();
      })), a.subParser('makeMarkdown.listItem', ((e, t) => {
        for (var n = '', r = e.childNodes, i = r.length, o = 0; o < i; ++o)n += a.subParser('makeMarkdown.node')(r[o], t); return /\n$/.test(n) ? n = n.split('\n').join('\n    ').replace(/^ {4}$/gm, '').replace(/\n\n+/g, '\n\n') : n += '\n', n;
      })), a.subParser('makeMarkdown.node', ((e, t, n) => {
        n = n || !1; let r = ''; if (e.nodeType === 3) return a.subParser('makeMarkdown.txt')(e, t); if (e.nodeType === 8) return `\x3c!--${e.data}--\x3e\n\n`; if (e.nodeType !== 1) return ''; const i = e.tagName.toLowerCase(); switch (i) { case 'h1': n || (r = `${a.subParser('makeMarkdown.header')(e, t, 1)}\n\n`); break; case 'h2': n || (r = `${a.subParser('makeMarkdown.header')(e, t, 2)}\n\n`); break; case 'h3': n || (r = `${a.subParser('makeMarkdown.header')(e, t, 3)}\n\n`); break; case 'h4': n || (r = `${a.subParser('makeMarkdown.header')(e, t, 4)}\n\n`); break; case 'h5': n || (r = `${a.subParser('makeMarkdown.header')(e, t, 5)}\n\n`); break; case 'h6': n || (r = `${a.subParser('makeMarkdown.header')(e, t, 6)}\n\n`); break; case 'p': n || (r = `${a.subParser('makeMarkdown.paragraph')(e, t)}\n\n`); break; case 'blockquote': n || (r = `${a.subParser('makeMarkdown.blockquote')(e, t)}\n\n`); break; case 'hr': n || (r = `${a.subParser('makeMarkdown.hr')(e, t)}\n\n`); break; case 'ol': n || (r = `${a.subParser('makeMarkdown.list')(e, t, 'ol')}\n\n`); break; case 'ul': n || (r = `${a.subParser('makeMarkdown.list')(e, t, 'ul')}\n\n`); break; case 'precode': n || (r = `${a.subParser('makeMarkdown.codeBlock')(e, t)}\n\n`); break; case 'pre': n || (r = `${a.subParser('makeMarkdown.pre')(e, t)}\n\n`); break; case 'table': n || (r = `${a.subParser('makeMarkdown.table')(e, t)}\n\n`); break; case 'code': r = a.subParser('makeMarkdown.codeSpan')(e, t); break; case 'em': case 'i': r = a.subParser('makeMarkdown.emphasis')(e, t); break; case 'strong': case 'b': r = a.subParser('makeMarkdown.strong')(e, t); break; case 'del': r = a.subParser('makeMarkdown.strikethrough')(e, t); break; case 'a': r = a.subParser('makeMarkdown.links')(e, t); break; case 'img': r = a.subParser('makeMarkdown.image')(e, t); break; default: r = `${e.outerHTML}\n\n`; } return r;
      })), a.subParser('makeMarkdown.paragraph', ((e, t) => {
        let n = ''; if (e.hasChildNodes()) for (let r = e.childNodes, i = r.length, o = 0; o < i; ++o)n += a.subParser('makeMarkdown.node')(r[o], t); return n = n.trim(), n;
      })), a.subParser('makeMarkdown.pre', ((e, t) => {
        const n = e.getAttribute('prenum'); return `<pre>${t.preList[n]}</pre>`;
      })), a.subParser('makeMarkdown.strikethrough', ((e, t) => {
        let n = ''; if (e.hasChildNodes()) { n += '~~'; for (let r = e.childNodes, i = r.length, o = 0; o < i; ++o)n += a.subParser('makeMarkdown.node')(r[o], t); n += '~~'; } return n;
      })), a.subParser('makeMarkdown.strong', ((e, t) => {
        let n = ''; if (e.hasChildNodes()) { n += '**'; for (let r = e.childNodes, i = r.length, o = 0; o < i; ++o)n += a.subParser('makeMarkdown.node')(r[o], t); n += '**'; } return n;
      })), a.subParser('makeMarkdown.table', ((e, t) => {
        let n; let r; let i = ''; const o = [[], []]; const s = e.querySelectorAll('thead>tr>th'); const l = e.querySelectorAll('tbody>tr'); for (n = 0; n < s.length; ++n) { const c = a.subParser('makeMarkdown.tableCell')(s[n], t); let u = '---'; if (s[n].hasAttribute('style')) { const f = s[n].getAttribute('style').toLowerCase().replace(/\s/g, ''); switch (f) { case 'text-align:left;': u = ':---'; break; case 'text-align:right;': u = '---:'; break; case 'text-align:center;': u = ':---:'; break; } }o[0][n] = c.trim(), o[1][n] = u; } for (n = 0; n < l.length; ++n) { const d = o.push([]) - 1; const h = l[n].getElementsByTagName('td'); for (r = 0; r < s.length; ++r) { let p = ' '; typeof h[r] !== 'undefined' && (p = a.subParser('makeMarkdown.tableCell')(h[r], t)), o[d].push(p); } } let m = 3; for (n = 0; n < o.length; ++n) for (r = 0; r < o[n].length; ++r) { const g = o[n][r].length; g > m && (m = g); } for (n = 0; n < o.length; ++n) { for (r = 0; r < o[n].length; ++r)n === 1 ? o[n][r].slice(-1) === ':' ? o[n][r] = `${a.helper.padEnd(o[n][r].slice(-1), m - 1, '-')}:` : o[n][r] = a.helper.padEnd(o[n][r], m, '-') : o[n][r] = a.helper.padEnd(o[n][r], m); i += `| ${o[n].join(' | ')} |\n`; } return i.trim();
      })), a.subParser('makeMarkdown.tableCell', ((e, t) => {
        let n = ''; if (!e.hasChildNodes()) return ''; for (let r = e.childNodes, i = r.length, o = 0; o < i; ++o)n += a.subParser('makeMarkdown.node')(r[o], t, !0); return n.trim();
      })), a.subParser('makeMarkdown.txt', ((e) => {
        let t = e.nodeValue; return t = t.replace(/ +/g, ' '), t = t.replace(/¨NBSP;/g, ' '), t = a.helper.unescapeHTMLEntities(t), t = t.replace(/([*_~|`])/g, '\\$1'), t = t.replace(/^(\s*)>/g, '\\$1>'), t = t.replace(/^#/gm, '\\#'), t = t.replace(/^(\s*)([-=]{3,})(\s*)$/, '$1\\$2$3'), t = t.replace(/^( {0,3}\d+)\./gm, '$1\\.'), t = t.replace(/^( {0,3})([+-])/gm, '$1\\$2'), t = t.replace(/]([\s]*)\(/g, '\\]$1\\('), t = t.replace(/^ {0,3}\[([\S \t]*?)]:/gm, '\\[$1]:'), t;
      })); r = function () {
        return a;
      }.call(t, n, t, e), void 0 === r || (e.exports = r);
    }).call(this);
  },
  '342f': function (e, t, n) { const r = n('d066'); e.exports = r('navigator', 'userAgent') || ''; },
  '35a1': function (e, t, n) { const r = n('f5df'); const i = n('3f8c'); const o = n('b622'); const a = o('iterator'); e.exports = function (e) { if (void 0 != e) return e[a] || e['@@iterator'] || i[r(e)]; }; },
  '37e8': function (e, t, n) { const r = n('83ab'); const i = n('9bf2'); const o = n('825a'); const a = n('df75'); e.exports = r ? Object.defineProperties : function (e, t) { o(e); let n; const r = a(t); const s = r.length; let l = 0; while (s > l)i.f(e, n = r[l++], t[n]); return e; }; },
  '3bbe': function (e, t, n) { const r = n('861d'); e.exports = function (e) { if (!r(e) && e !== null) throw TypeError(`Can't set ${String(e)} as a prototype`); return e; }; },
  '3ca3': function (e, t, n) {
    const r = n('6547').charAt; const i = n('69f3'); const o = n('7dd0'); const a = 'String Iterator'; const s = i.set; const l = i.getterFor(a); o(String, 'String', (function (e) { s(this, { type: a, string: String(e), index: 0 }); }), (function () { let e; const t = l(this); const n = t.string; const i = t.index; return i >= n.length ? { value: void 0, done: !0 } : (e = r(n, i), t.index += e.length, { value: e, done: !1 }); }));
  },
  '3f4e': function (e, t, n) {
    n.d(t, 'setupDevtoolsPlugin', (() => o)); const r = n('abc5'); const i = n('b774'); function o(e, t) { const n = Object(r.a)(); if (n)n.emit(i.a, e, t); else { const n = Object(r.b)(); const i = n.__VUE_DEVTOOLS_PLUGINS__ = n.__VUE_DEVTOOLS_PLUGINS__ || []; i.push({ pluginDescriptor: e, setupFn: t }); } }
  },
  '3f8c': function (e, t) { e.exports = {}; },
  4121(e, t, n) {},
  '428f': function (e, t, n) { const r = n('da84'); e.exports = r; },
  4498(e, t, n) {},
  '44a0': function (e, t, n) {
    (function (e) { e(n('56b3'), n('959b'), n('9eb9')); }(((e) => {
      const t = /^((?:(?:aaas?|about|acap|adiumxtra|af[ps]|aim|apt|attachment|aw|beshare|bitcoin|bolo|callto|cap|chrome(?:-extension)?|cid|coap|com-eventbrite-attendee|content|crid|cvs|data|dav|dict|dlna-(?:playcontainer|playsingle)|dns|doi|dtn|dvb|ed2k|facetime|feed|file|finger|fish|ftp|geo|gg|git|gizmoproject|go|gopher|gtalk|h323|hcp|https?|iax|icap|icon|im|imap|info|ipn|ipp|irc[6s]?|iris(?:\.beep|\.lwz|\.xpc|\.xpcs)?|itms|jar|javascript|jms|keyparc|lastfm|ldaps?|magnet|mailto|maps|market|message|mid|mms|ms-help|msnim|msrps?|mtqp|mumble|mupdate|mvn|news|nfs|nih?|nntp|notes|oid|opaquelocktoken|palm|paparazzi|platform|pop|pres|proxy|psyc|query|res(?:ource)?|rmi|rsync|rtmp|rtsp|secondlife|service|session|sftp|sgn|shttp|sieve|sips?|skype|sm[bs]|snmp|soap\.beeps?|soldat|spotify|ssh|steam|svn|tag|teamspeak|tel(?:net)?|tftp|things|thismessage|tip|tn3270|tv|udp|unreal|urn|ut2004|vemmi|ventrilo|view-source|webcal|wss?|wtai|wyciwyg|xcon(?:-userid)?|xfire|xmlrpc\.beeps?|xmpp|xri|ymsgr|z39\.50[rs]?):(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]|\([^\s()<>]*\))+(?:\([^\s()<>]*\)|[^\s`*!()\[\]{};:'".,<>?«»“”‘’]))/i; e.defineMode('gfm', ((n, r) => {
        let i = 0; function o(e) { return e.code = !1, null; } const a = {
          startState() { return { code: !1, codeBlock: !1, ateSpace: !1 }; }, copyState(e) { return { code: e.code, codeBlock: e.codeBlock, ateSpace: e.ateSpace }; }, token(e, n) { if (n.combineTokens = null, n.codeBlock) return e.match(/^```+/) ? (n.codeBlock = !1, null) : (e.skipToEnd(), null); if (e.sol() && (n.code = !1), e.sol() && e.match(/^```+/)) return e.skipToEnd(), n.codeBlock = !0, null; if (e.peek() === '`') { e.next(); const o = e.pos; e.eatWhile('`'); const a = 1 + e.pos - o; return n.code ? a === i && (n.code = !1) : (i = a, n.code = !0), null; } if (n.code) return e.next(), null; if (e.eatSpace()) return n.ateSpace = !0, null; if ((e.sol() || n.ateSpace) && (n.ateSpace = !1, !1 !== r.gitHubSpice)) { if (e.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+@)?(?=.{0,6}\d)(?:[a-f0-9]{7,40}\b)/)) return n.combineTokens = !0, 'link'; if (e.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+)?#[0-9]+\b/)) return n.combineTokens = !0, 'link'; } return e.match(t) && e.string.slice(e.start - 2, e.start) != '](' && (e.start == 0 || /\W/.test(e.string.charAt(e.start - 1))) ? (n.combineTokens = !0, 'link') : (e.next(), null); }, blankLine: o,
        }; const s = { taskLists: !0, strikethrough: !0, emoji: !0 }; for (const l in r)s[l] = r[l]; return s.name = 'markdown', e.overlayMode(e.getMode(n, s), a);
      }), 'markdown'), e.defineMIME('text/x-gfm', 'gfm');
    })));
  },
  '44ad': function (e, t, n) { const r = n('d039'); const i = n('c6b6'); const o = ''.split; e.exports = r((() => !Object('z').propertyIsEnumerable(0))) ? function (e) { return i(e) == 'String' ? o.call(e, '') : Object(e); } : Object; },
  '44d2': function (e, t, n) { const r = n('b622'); const i = n('7c73'); const o = n('9bf2'); const a = r('unscopables'); const s = Array.prototype; void 0 == s[a] && o.f(s, a, { configurable: !0, value: i(null) }), e.exports = function (e) { s[a][e] = !0; }; },
  '44de': function (e, t, n) { const r = n('da84'); e.exports = function (e, t) { const n = r.console; n && n.error && (arguments.length === 1 ? n.error(e) : n.error(e, t)); }; },
  4840(e, t, n) { const r = n('825a'); const i = n('1c0b'); const o = n('b622'); const a = o('species'); e.exports = function (e, t) { let n; const o = r(e).constructor; return void 0 === o || void 0 == (n = r(o)[a]) ? t : i(n); }; },
  4930(e, t, n) { const r = n('2d00'); const i = n('d039'); e.exports = !!Object.getOwnPropertySymbols && !i((() => { const e = Symbol(); return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && r && r < 41; })); },
  '4d64': function (e, t, n) { const r = n('fc6a'); const i = n('50c4'); const o = n('23cb'); const a = function (e) { return function (t, n, a) { let s; const l = r(t); const c = i(l.length); let u = o(a, c); if (e && n != n) { while (c > u) if (s = l[u++], s != s) return !0; } else for (;c > u; u++) if ((e || u in l) && l[u] === n) return e || u || 0; return !e && -1; }; }; e.exports = { includes: a(!0), indexOf: a(!1) }; },
  '50c4': function (e, t, n) { const r = n('a691'); const i = Math.min; e.exports = function (e) { return e > 0 ? i(r(e), 9007199254740991) : 0; }; },
  5135(e, t, n) { const r = n('7b0b'); const i = {}.hasOwnProperty; e.exports = Object.hasOwn || function (e, t) { return i.call(r(e), t); }; },
  5502(e, t, n) {
    n.d(t, 'a', (() => G)); const r = n('7a23'); const i = n('3f4e'); const o = 'store'; function a(e, t) { Object.keys(e).forEach(((n) => t(e[n], n))); } function s(e) { return e !== null && typeof e === 'object'; } function l(e) { return e && typeof e.then === 'function'; } function c(e, t) { if (!e) throw new Error(`[vuex] ${t}`); } function u(e, t) { return function () { return e(t); }; } function f(e, t, n) { return t.indexOf(e) < 0 && (n && n.prepend ? t.unshift(e) : t.push(e)), function () { const n = t.indexOf(e); n > -1 && t.splice(n, 1); }; } function d(e, t) { e._actions = Object.create(null), e._mutations = Object.create(null), e._wrappedGetters = Object.create(null), e._modulesNamespaceMap = Object.create(null); const n = e.state; p(e, n, [], e._modules.root, !0), h(e, n, t); } function h(e, t, n) { const i = e._state; e.getters = {}, e._makeLocalGettersCache = Object.create(null); const o = e._wrappedGetters; const s = {}; a(o, ((t, n) => { s[n] = u(t, e), Object.defineProperty(e.getters, n, { get() { return s[n](); }, enumerable: !0 }); })), e._state = Object(r.q)({ data: t }), e.strict && w(e), i && n && e._withCommit((() => { i.data = null; })); } function p(e, t, n, r, i) { const o = !n.length; const a = e._modules.getNamespace(n); if (r.namespaced && (e._modulesNamespaceMap[a] && console.error(`[vuex] duplicate namespace ${a} for the namespaced module ${n.join('/')}`), e._modulesNamespaceMap[a] = r), !o && !i) { const s = x(t, n.slice(0, -1)); const l = n[n.length - 1]; e._withCommit((() => { l in s && console.warn(`[vuex] state field "${l}" was overridden by a module with the same name at "${n.join('.')}"`), s[l] = r.state; })); } const c = r.context = m(e, a, n); r.forEachMutation(((t, n) => { const r = a + n; v(e, r, t, c); })), r.forEachAction(((t, n) => { const r = t.root ? n : a + n; const i = t.handler || t; b(e, r, i, c); })), r.forEachGetter(((t, n) => { const r = a + n; y(e, r, t, c); })), r.forEachChild(((r, o) => { p(e, t, n.concat(o), r, i); })); } function m(e, t, n) { const r = t === ''; const i = { dispatch: r ? e.dispatch : function (n, r, i) { const o = k(n, r, i); const a = o.payload; const s = o.options; let l = o.type; if (s && s.root || (l = t + l, e._actions[l])) return e.dispatch(l, a); console.error(`[vuex] unknown local action type: ${o.type}, global type: ${l}`); }, commit: r ? e.commit : function (n, r, i) { const o = k(n, r, i); const a = o.payload; const s = o.options; let l = o.type; s && s.root || (l = t + l, e._mutations[l]) ? e.commit(l, a, s) : console.error(`[vuex] unknown local mutation type: ${o.type}, global type: ${l}`); } }; return Object.defineProperties(i, { getters: { get: r ? function () { return e.getters; } : function () { return g(e, t); } }, state: { get() { return x(e.state, n); } } }), i; } function g(e, t) { if (!e._makeLocalGettersCache[t]) { const n = {}; const r = t.length; Object.keys(e.getters).forEach(((i) => { if (i.slice(0, r) === t) { const o = i.slice(r); Object.defineProperty(n, o, { get() { return e.getters[i]; }, enumerable: !0 }); } })), e._makeLocalGettersCache[t] = n; } return e._makeLocalGettersCache[t]; } function v(e, t, n, r) { const i = e._mutations[t] || (e._mutations[t] = []); i.push(((t) => { n.call(e, r.state, t); })); } function b(e, t, n, r) {
      const i = e._actions[t] || (e._actions[t] = []); i.push(((t) => {
        let i = n.call(e, {
          dispatch: r.dispatch, commit: r.commit, getters: r.getters, state: r.state, rootGetters: e.getters, rootState: e.state,
        }, t); return l(i) || (i = Promise.resolve(i)), e._devtoolHook ? i.catch(((t) => { throw e._devtoolHook.emit('vuex:error', t), t; })) : i;
      }));
    } function y(e, t, n, r) { e._wrappedGetters[t] ? console.error(`[vuex] duplicate getter key: ${t}`) : e._wrappedGetters[t] = function (e) { return n(r.state, r.getters, e.state, e.getters); }; } function w(e) { Object(r.v)((() => e._state.data), (() => { c(e._committing, 'do not mutate vuex store state outside mutation handlers.'); }), { deep: !0, flush: 'sync' }); } function x(e, t) { return t.reduce(((e, t) => e[t]), e); } function k(e, t, n) { return s(e) && e.type && (n = t, t = e, e = e.type), c(typeof e === 'string', `expects string as the type, but found ${typeof e}.`), { type: e, payload: t, options: n }; } const _ = 'vuex bindings'; const C = 'vuex:mutations'; const S = 'vuex:actions'; const O = 'vuex'; let j = 0; function L(e, t) {
      Object(i.setupDevtoolsPlugin)({
        id: 'org.vuejs.vuex', app: e, label: 'Vuex', homepage: 'https://next.vuex.vuejs.org/', logo: 'https://vuejs.org/images/icons/favicon-96x96.png', packageName: 'vuex', componentStateTypes: [_],
      }, ((n) => {
        n.addTimelineLayer({ id: C, label: 'Vuex Mutations', color: T }), n.addTimelineLayer({ id: S, label: 'Vuex Actions', color: T }), n.addInspector({
          id: O, label: 'Vuex', icon: 'storage', treeFilterPlaceholder: 'Filter stores...',
        }), n.on.getInspectorTree(((n) => { if (n.app === e && n.inspectorId === O) if (n.filter) { const r = []; N(r, t._modules.root, n.filter, ''), n.rootNodes = r; } else n.rootNodes = [D(t._modules.root, '')]; })), n.on.getInspectorState(((n) => { if (n.app === e && n.inspectorId === O) { const r = n.nodeId; g(t, r), n.state = F(z(t._modules, r), t._makeLocalGettersCache, r); } })), n.on.editInspectorState(((n) => { if (n.app === e && n.inspectorId === O) { const r = n.nodeId; let i = n.path; r !== 'root' && (i = r.split('/').filter(Boolean).concat(i)), t._withCommit((() => { n.set(t._state.data, i, n.state.value); })); } })), t.subscribe(((e, t) => { const r = {}; e.payload && (r.payload = e.payload), r.state = t, n.notifyComponentUpdate(), n.sendInspectorTree(O), n.sendInspectorState(O), n.addTimelineEvent({ layerId: C, event: { time: Date.now(), title: e.type, data: r } }); })), t.subscribeAction({
          before(e, t) {
            const r = {}; e.payload && (r.payload = e.payload), e._id = j++, e._time = Date.now(), r.state = t, n.addTimelineEvent({
              layerId: S,
              event: {
                time: e._time, title: e.type, groupId: e._id, subtitle: 'start', data: r,
              },
            });
          },
          after(e, t) {
            const r = {}; const i = Date.now() - e._time; r.duration = {
              _custom: {
                type: 'duration', display: `${i}ms`, tooltip: 'Action duration', value: i,
              },
            }, e.payload && (r.payload = e.payload), r.state = t, n.addTimelineEvent({
              layerId: S,
              event: {
                time: Date.now(), title: e.type, groupId: e._id, subtitle: 'end', data: r,
              },
            });
          },
        });
      }));
    } var T = 8702998; const M = 6710886; const A = 16777215; const E = { label: 'namespaced', textColor: A, backgroundColor: M }; function P(e) { return e && e !== 'root' ? e.split('/').slice(-2, -1)[0] : 'Root'; } function D(e, t) {
      return {
        id: t || 'root', label: P(t), tags: e.namespaced ? [E] : [], children: Object.keys(e._children).map(((n) => D(e._children[n], `${t + n}/`))),
      };
    } function N(e, t, n, r) { r.includes(n) && e.push({ id: r || 'root', label: r.endsWith('/') ? r.slice(0, r.length - 1) : r || 'Root', tags: t.namespaced ? [E] : [] }), Object.keys(t._children).forEach(((i) => { N(e, t._children[i], n, `${r + i}/`); })); } function F(e, t, n) { t = n === 'root' ? t : t[n]; const r = Object.keys(t); const i = { state: Object.keys(e.state).map(((t) => ({ key: t, editable: !0, value: e.state[t] }))) }; return r.length && (i.getters = r.map(((e) => ({ key: e.endsWith('/') ? P(e) : e, editable: !1, value: t[e] })))), i; } function z(e, t) { const n = t.split('/').filter(((e) => e)); return n.reduce(((e, r, i) => { const o = e[r]; if (!o) throw new Error(`Missing module "${r}" for path "${t}".`); return i === n.length - 1 ? o : o._children; }), t === 'root' ? e : e.root._children); } const I = function (e, t) { this.runtime = t, this._children = Object.create(null), this._rawModule = e; const n = e.state; this.state = (typeof n === 'function' ? n() : n) || {}; }; const B = { namespaced: { configurable: !0 } }; B.namespaced.get = function () { return !!this._rawModule.namespaced; }, I.prototype.addChild = function (e, t) { this._children[e] = t; }, I.prototype.removeChild = function (e) { delete this._children[e]; }, I.prototype.getChild = function (e) { return this._children[e]; }, I.prototype.hasChild = function (e) { return e in this._children; }, I.prototype.update = function (e) { this._rawModule.namespaced = e.namespaced, e.actions && (this._rawModule.actions = e.actions), e.mutations && (this._rawModule.mutations = e.mutations), e.getters && (this._rawModule.getters = e.getters); }, I.prototype.forEachChild = function (e) { a(this._children, e); }, I.prototype.forEachGetter = function (e) { this._rawModule.getters && a(this._rawModule.getters, e); }, I.prototype.forEachAction = function (e) { this._rawModule.actions && a(this._rawModule.actions, e); }, I.prototype.forEachMutation = function (e) { this._rawModule.mutations && a(this._rawModule.mutations, e); }, Object.defineProperties(I.prototype, B); const H = function (e) { this.register([], e, !1); }; function R(e, t, n) { if (V(e, n), t.update(n), n.modules) for (const r in n.modules) { if (!t.getChild(r)) return void console.warn(`[vuex] trying to add a new module '${r}' on hot reloading, manual reload is needed`); R(e.concat(r), t.getChild(r), n.modules[r]); } }H.prototype.get = function (e) { return e.reduce(((e, t) => e.getChild(t)), this.root); }, H.prototype.getNamespace = function (e) { let t = this.root; return e.reduce(((e, n) => (t = t.getChild(n), e + (t.namespaced ? `${n}/` : ''))), ''); }, H.prototype.update = function (e) { R([], this.root, e); }, H.prototype.register = function (e, t, n) { const r = this; void 0 === n && (n = !0), V(e, t); const i = new I(t, n); if (e.length === 0) this.root = i; else { const o = this.get(e.slice(0, -1)); o.addChild(e[e.length - 1], i); }t.modules && a(t.modules, ((t, i) => { r.register(e.concat(i), t, n); })); }, H.prototype.unregister = function (e) { const t = this.get(e.slice(0, -1)); const n = e[e.length - 1]; const r = t.getChild(n); r ? r.runtime && t.removeChild(n) : console.warn(`[vuex] trying to unregister module '${n}', which is not registered`); }, H.prototype.isRegistered = function (e) { const t = this.get(e.slice(0, -1)); const n = e[e.length - 1]; return !!t && t.hasChild(n); }; const W = { assert(e) { return typeof e === 'function'; }, expected: 'function' }; const q = { assert(e) { return typeof e === 'function' || typeof e === 'object' && typeof e.handler === 'function'; }, expected: 'function or object with "handler" function' }; const $ = { getters: W, mutations: W, actions: q }; function V(e, t) { Object.keys($).forEach(((n) => { if (t[n]) { const r = $[n]; a(t[n], ((t, i) => { c(r.assert(t), U(e, n, i, t, r.expected)); })); } })); } function U(e, t, n, r, i) { let o = `${t} should be ${i} but "${t}.${n}"`; return e.length > 0 && (o += ` in module "${e.join('.')}"`), o += ` is ${JSON.stringify(r)}.`, o; } function G(e) { return new K(e); } var K = function e(t) { const n = this; void 0 === t && (t = {}), c(typeof Promise !== 'undefined', 'vuex requires a Promise polyfill in this browser.'), c(this instanceof e, 'store must be called with the new operator.'); let r = t.plugins; void 0 === r && (r = []); let i = t.strict; void 0 === i && (i = !1); const o = t.devtools; this._committing = !1, this._actions = Object.create(null), this._actionSubscribers = [], this._mutations = Object.create(null), this._wrappedGetters = Object.create(null), this._modules = new H(t), this._modulesNamespaceMap = Object.create(null), this._subscribers = [], this._makeLocalGettersCache = Object.create(null), this._devtools = o; const a = this; const s = this; const l = s.dispatch; const u = s.commit; this.dispatch = function (e, t) { return l.call(a, e, t); }, this.commit = function (e, t, n) { return u.call(a, e, t, n); }, this.strict = i; const f = this._modules.root.state; p(this, f, [], this._modules.root), h(this, f), r.forEach(((e) => e(n))); }; const X = { state: { configurable: !0 } }; K.prototype.install = function (e, t) { e.provide(t || o, this), e.config.globalProperties.$store = this; const n = void 0 === this._devtools || this._devtools; n && L(e, this); }, X.state.get = function () { return this._state.data; }, X.state.set = function (e) { c(!1, 'use store.replaceState() to explicit replace store state.'); }, K.prototype.commit = function (e, t, n) { const r = this; const i = k(e, t, n); const o = i.type; const a = i.payload; const s = i.options; const l = { type: o, payload: a }; const c = this._mutations[o]; c ? (this._withCommit((() => { c.forEach(((e) => { e(a); })); })), this._subscribers.slice().forEach(((e) => e(l, r.state))), s && s.silent && console.warn(`[vuex] mutation type: ${o}. Silent option has been removed. Use the filter functionality in the vue-devtools`)) : console.error(`[vuex] unknown mutation type: ${o}`); }, K.prototype.dispatch = function (e, t) { const n = this; const r = k(e, t); const i = r.type; const o = r.payload; const a = { type: i, payload: o }; const s = this._actions[i]; if (s) { try { this._actionSubscribers.slice().filter(((e) => e.before)).forEach(((e) => e.before(a, n.state))); } catch (c) { console.warn('[vuex] error in before action subscribers: '), console.error(c); } const l = s.length > 1 ? Promise.all(s.map(((e) => e(o)))) : s[0](o); return new Promise((((e, t) => { l.then(((t) => { try { n._actionSubscribers.filter(((e) => e.after)).forEach(((e) => e.after(a, n.state))); } catch (c) { console.warn('[vuex] error in after action subscribers: '), console.error(c); }e(t); }), ((e) => { try { n._actionSubscribers.filter(((e) => e.error)).forEach(((t) => t.error(a, n.state, e))); } catch (c) { console.warn('[vuex] error in error action subscribers: '), console.error(c); }t(e); })); }))); }console.error(`[vuex] unknown action type: ${i}`); }, K.prototype.subscribe = function (e, t) { return f(e, this._subscribers, t); }, K.prototype.subscribeAction = function (e, t) { const n = typeof e === 'function' ? { before: e } : e; return f(n, this._actionSubscribers, t); }, K.prototype.watch = function (e, t, n) { const i = this; return c(typeof e === 'function', 'store.watch only accepts a function.'), Object(r.v)((() => e(i.state, i.getters)), t, { ...n }); }, K.prototype.replaceState = function (e) { const t = this; this._withCommit((() => { t._state.data = e; })); }, K.prototype.registerModule = function (e, t, n) { void 0 === n && (n = {}), typeof e === 'string' && (e = [e]), c(Array.isArray(e), 'module path must be a string or an Array.'), c(e.length > 0, 'cannot register the root module by using registerModule.'), this._modules.register(e, t), p(this, this.state, e, this._modules.get(e), n.preserveState), h(this, this.state); }, K.prototype.unregisterModule = function (e) { const t = this; typeof e === 'string' && (e = [e]), c(Array.isArray(e), 'module path must be a string or an Array.'), this._modules.unregister(e), this._withCommit((() => { const n = x(t.state, e.slice(0, -1)); delete n[e[e.length - 1]]; })), d(this); }, K.prototype.hasModule = function (e) { return typeof e === 'string' && (e = [e]), c(Array.isArray(e), 'module path must be a string or an Array.'), this._modules.isRegistered(e); }, K.prototype.hotUpdate = function (e) { this._modules.update(e), d(this, !0); }, K.prototype._withCommit = function (e) { const t = this._committing; this._committing = !0, e(), this._committing = t; }, Object.defineProperties(K.prototype, X); J(((e, t) => { const n = {}; return Z(t) || console.error('[vuex] mapState: mapper parameter must be either an Array or an Object'), Y(t).forEach(((t) => { const r = t.key; const i = t.val; n[r] = function () { let t = this.$store.state; let n = this.$store.getters; if (e) { const r = Q(this.$store, 'mapState', e); if (!r) return; t = r.context.state, n = r.context.getters; } return typeof i === 'function' ? i.call(this, t, n) : t[i]; }, n[r].vuex = !0; })), n; })), J(((e, t) => { const n = {}; return Z(t) || console.error('[vuex] mapMutations: mapper parameter must be either an Array or an Object'), Y(t).forEach(((t) => { const r = t.key; const i = t.val; n[r] = function () { const t = []; let n = arguments.length; while (n--)t[n] = arguments[n]; let r = this.$store.commit; if (e) { const o = Q(this.$store, 'mapMutations', e); if (!o) return; r = o.context.commit; } return typeof i === 'function' ? i.apply(this, [r].concat(t)) : r.apply(this.$store, [i].concat(t)); }; })), n; })), J(((e, t) => { const n = {}; return Z(t) || console.error('[vuex] mapGetters: mapper parameter must be either an Array or an Object'), Y(t).forEach(((t) => { const r = t.key; let i = t.val; i = e + i, n[r] = function () { if (!e || Q(this.$store, 'mapGetters', e)) { if (i in this.$store.getters) return this.$store.getters[i]; console.error(`[vuex] unknown getter: ${i}`); } }, n[r].vuex = !0; })), n; })), J(((e, t) => { const n = {}; return Z(t) || console.error('[vuex] mapActions: mapper parameter must be either an Array or an Object'), Y(t).forEach(((t) => { const r = t.key; const i = t.val; n[r] = function () { const t = []; let n = arguments.length; while (n--)t[n] = arguments[n]; let r = this.$store.dispatch; if (e) { const o = Q(this.$store, 'mapActions', e); if (!o) return; r = o.context.dispatch; } return typeof i === 'function' ? i.apply(this, [r].concat(t)) : r.apply(this.$store, [i].concat(t)); }; })), n; })); function Y(e) { return Z(e) ? Array.isArray(e) ? e.map(((e) => ({ key: e, val: e }))) : Object.keys(e).map(((t) => ({ key: t, val: e[t] }))) : []; } function Z(e) { return Array.isArray(e) || s(e); } function J(e) { return function (t, n) { return typeof t !== 'string' ? (n = t, t = '') : t.charAt(t.length - 1) !== '/' && (t += '/'), e(t, n); }; } function Q(e, t, n) { const r = e._modulesNamespaceMap[n]; return r || console.error(`[vuex] module namespace not found in ${t}(): ${n}`), r; }
  },
  5692(e, t, n) { const r = n('c430'); const i = n('c6cd'); (e.exports = function (e, t) { return i[e] || (i[e] = void 0 !== t ? t : {}); })('versions', []).push({ version: '3.14.0', mode: r ? 'pure' : 'global', copyright: '© 2021 Denis Pushkarev (zloirock.ru)' }); },
  '56b3': function (e, t, n) {
    (function (t, n) { e.exports = n(); }(0, (() => {
      const e = navigator.userAgent; const t = navigator.platform; const n = /gecko\/\d/i.test(e); const r = /MSIE \d/.test(e); const i = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(e); const o = /Edge\/(\d+)/.exec(e); const a = r || i || o; const s = a && (r ? document.documentMode || 6 : +(o || i)[1]); let l = !o && /WebKit\//.test(e); const c = l && /Qt\/\d+\.\d+/.test(e); const u = !o && /Chrome\//.test(e); let f = /Opera\//.test(e); const d = /Apple Computer/.test(navigator.vendor); const h = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(e); const p = /PhantomJS/.test(e); const m = d && (/Mobile\/\w+/.test(e) || navigator.maxTouchPoints > 2); const g = /Android/.test(e); const v = m || g || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(e); const b = m || /Mac/.test(t); const y = /\bCrOS\b/.test(e); const w = /win/i.test(t); let x = f && e.match(/Version\/(\d*\.\d*)/); x && (x = Number(x[1])), x && x >= 15 && (f = !1, l = !0); const k = b && (c || f && (x == null || x < 12.11)); const _ = n || a && s >= 9; function C(e) { return new RegExp(`(^|\\s)${e}(?:$|\\s)\\s*`); } let S; const O = function (e, t) { const n = e.className; const r = C(t).exec(n); if (r) { const i = n.slice(r.index + r[0].length); e.className = n.slice(0, r.index) + (i ? r[1] + i : ''); } }; function j(e) { for (let t = e.childNodes.length; t > 0; --t)e.removeChild(e.firstChild); return e; } function L(e, t) { return j(e).appendChild(t); } function T(e, t, n, r) { const i = document.createElement(e); if (n && (i.className = n), r && (i.style.cssText = r), typeof t === 'string')i.appendChild(document.createTextNode(t)); else if (t) for (let o = 0; o < t.length; ++o)i.appendChild(t[o]); return i; } function M(e, t, n, r) { const i = T(e, t, n, r); return i.setAttribute('role', 'presentation'), i; } function A(e, t) { if (t.nodeType == 3 && (t = t.parentNode), e.contains) return e.contains(t); do { if (t.nodeType == 11 && (t = t.host), t == e) return !0; } while (t = t.parentNode); } function E() { let e; try { e = document.activeElement; } catch (t) { e = document.body || null; } while (e && e.shadowRoot && e.shadowRoot.activeElement)e = e.shadowRoot.activeElement; return e; } function P(e, t) { const n = e.className; C(t).test(n) || (e.className += (n ? ' ' : '') + t); } function D(e, t) { for (let n = e.split(' '), r = 0; r < n.length; r++)n[r] && !C(n[r]).test(t) && (t += ` ${n[r]}`); return t; }S = document.createRange ? function (e, t, n, r) { const i = document.createRange(); return i.setEnd(r || e, n), i.setStart(e, t), i; } : function (e, t, n) { const r = document.body.createTextRange(); try { r.moveToElementText(e.parentNode); } catch (i) { return r; } return r.collapse(!0), r.moveEnd('character', n), r.moveStart('character', t), r; }; let N = function (e) { e.select(); }; function F(e) { const t = Array.prototype.slice.call(arguments, 1); return function () { return e.apply(null, t); }; } function z(e, t, n) { for (const r in t || (t = {}), e)!e.hasOwnProperty(r) || !1 === n && t.hasOwnProperty(r) || (t[r] = e[r]); return t; } function I(e, t, n, r, i) { t == null && (t = e.search(/[^\s\u00a0]/), t == -1 && (t = e.length)); for (let o = r || 0, a = i || 0; ;) { const s = e.indexOf('\t', o); if (s < 0 || s >= t) return a + (t - o); a += s - o, a += n - a % n, o = s + 1; } }m ? N = function (e) { e.selectionStart = 0, e.selectionEnd = e.value.length; } : a && (N = function (e) { try { e.select(); } catch (t) {} }); const B = function () { this.id = null, this.f = null, this.time = 0, this.handler = F(this.onTimeout, this); }; function H(e, t) { for (let n = 0; n < e.length; ++n) if (e[n] == t) return n; return -1; }B.prototype.onTimeout = function (e) { e.id = 0, e.time <= +new Date() ? e.f() : setTimeout(e.handler, e.time - +new Date()); }, B.prototype.set = function (e, t) { this.f = t; const n = +new Date() + e; (!this.id || n < this.time) && (clearTimeout(this.id), this.id = setTimeout(this.handler, e), this.time = n); }; const R = 50; const W = { toString() { return 'CodeMirror.Pass'; } }; const q = { scroll: !1 }; const $ = { origin: '*mouse' }; const V = { origin: '+move' }; function U(e, t, n) { for (let r = 0, i = 0; ;) { let o = e.indexOf('\t', r); o == -1 && (o = e.length); const a = o - r; if (o == e.length || i + a >= t) return r + Math.min(a, t - i); if (i += o - r, i += n - i % n, r = o + 1, i >= t) return r; } } const G = ['']; function K(e) { while (G.length <= e)G.push(`${X(G)} `); return G[e]; } function X(e) { return e[e.length - 1]; } function Y(e, t) { for (var n = [], r = 0; r < e.length; r++)n[r] = t(e[r], r); return n; } function Z(e, t, n) { let r = 0; const i = n(t); while (r < e.length && n(e[r]) <= i)r++; e.splice(r, 0, t); } function J() {} function Q(e, t) { let n; return Object.create ? n = Object.create(e) : (J.prototype = e, n = new J()), t && z(t, n), n; } const ee = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/; function te(e) { return /\w/.test(e) || e > '' && (e.toUpperCase() != e.toLowerCase() || ee.test(e)); } function ne(e, t) { return t ? !!(t.source.indexOf('\\w') > -1 && te(e)) || t.test(e) : te(e); } function re(e) { for (const t in e) if (e.hasOwnProperty(t) && e[t]) return !1; return !0; } const ie = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/; function oe(e) { return e.charCodeAt(0) >= 768 && ie.test(e); } function ae(e, t, n) { while ((n < 0 ? t > 0 : t < e.length) && oe(e.charAt(t)))t += n; return t; } function se(e, t, n) { for (let r = t > n ? -1 : 1; ;) { if (t == n) return t; const i = (t + n) / 2; const o = r < 0 ? Math.ceil(i) : Math.floor(i); if (o == t) return e(o) ? t : n; e(o) ? n = o : t = o + r; } } function le(e, t, n, r) { if (!e) return r(t, n, 'ltr', 0); for (var i = !1, o = 0; o < e.length; ++o) { const a = e[o]; (a.from < n && a.to > t || t == n && a.to == t) && (r(Math.max(a.from, t), Math.min(a.to, n), a.level == 1 ? 'rtl' : 'ltr', o), i = !0); }i || r(t, n, 'ltr'); } let ce = null; function ue(e, t, n) { let r; ce = null; for (let i = 0; i < e.length; ++i) { const o = e[i]; if (o.from < t && o.to > t) return i; o.to == t && (o.from != o.to && n == 'before' ? r = i : ce = i), o.from == t && (o.from != o.to && n != 'before' ? r = i : ce = i); } return r != null ? r : ce; } const fe = (function () { const e = 'bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN'; const t = 'nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111'; function n(n) { return n <= 247 ? e.charAt(n) : n >= 1424 && n <= 1524 ? 'R' : n >= 1536 && n <= 1785 ? t.charAt(n - 1536) : n >= 1774 && n <= 2220 ? 'r' : n >= 8192 && n <= 8203 ? 'w' : n == 8204 ? 'b' : 'L'; } const r = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/; const i = /[stwN]/; const o = /[LRr]/; const a = /[Lb1n]/; const s = /[1n]/; function l(e, t, n) { this.level = e, this.from = t, this.to = n; } return function (e, t) { const c = t == 'ltr' ? 'L' : 'R'; if (e.length == 0 || t == 'ltr' && !r.test(e)) return !1; for (var u = e.length, f = [], d = 0; d < u; ++d)f.push(n(e.charCodeAt(d))); for (let h = 0, p = c; h < u; ++h) { const m = f[h]; m == 'm' ? f[h] = p : p = m; } for (let g = 0, v = c; g < u; ++g) { const b = f[g]; b == '1' && v == 'r' ? f[g] = 'n' : o.test(b) && (v = b, b == 'r' && (f[g] = 'R')); } for (let y = 1, w = f[0]; y < u - 1; ++y) { const x = f[y]; x == '+' && w == '1' && f[y + 1] == '1' ? f[y] = '1' : x != ',' || w != f[y + 1] || w != '1' && w != 'n' || (f[y] = w), w = x; } for (let k = 0; k < u; ++k) { const _ = f[k]; if (_ == ',')f[k] = 'N'; else if (_ == '%') { let C = void 0; for (C = k + 1; C < u && f[C] == '%'; ++C);for (let S = k && f[k - 1] == '!' || C < u && f[C] == '1' ? '1' : 'N', O = k; O < C; ++O)f[O] = S; k = C - 1; } } for (let j = 0, L = c; j < u; ++j) { const T = f[j]; L == 'L' && T == '1' ? f[j] = 'L' : o.test(T) && (L = T); } for (let M = 0; M < u; ++M) if (i.test(f[M])) { let A = void 0; for (A = M + 1; A < u && i.test(f[A]); ++A);for (let E = (M ? f[M - 1] : c) == 'L', P = (A < u ? f[A] : c) == 'L', D = E == P ? E ? 'L' : 'R' : c, N = M; N < A; ++N)f[N] = D; M = A - 1; } for (var F, z = [], I = 0; I < u;) if (a.test(f[I])) { const B = I; for (++I; I < u && a.test(f[I]); ++I);z.push(new l(0, B, I)); } else { let H = I; let R = z.length; const W = t == 'rtl' ? 1 : 0; for (++I; I < u && f[I] != 'L'; ++I);for (let q = H; q < I;) if (s.test(f[q])) { H < q && (z.splice(R, 0, new l(1, H, q)), R += W); const $ = q; for (++q; q < I && s.test(f[q]); ++q);z.splice(R, 0, new l(2, $, q)), R += W, H = q; } else ++q; H < I && z.splice(R, 0, new l(1, H, I)); } return t == 'ltr' && (z[0].level == 1 && (F = e.match(/^\s+/)) && (z[0].from = F[0].length, z.unshift(new l(0, 0, F[0].length))), X(z).level == 1 && (F = e.match(/\s+$/)) && (X(z).to -= F[0].length, z.push(new l(0, u - F[0].length, u)))), t == 'rtl' ? z.reverse() : z; }; }()); function de(e, t) { let n = e.order; return n == null && (n = e.order = fe(e.text, t)), n; } const he = []; const pe = function (e, t, n) { if (e.addEventListener)e.addEventListener(t, n, !1); else if (e.attachEvent)e.attachEvent(`on${t}`, n); else { const r = e._handlers || (e._handlers = {}); r[t] = (r[t] || he).concat(n); } }; function me(e, t) { return e._handlers && e._handlers[t] || he; } function ge(e, t, n) { if (e.removeEventListener)e.removeEventListener(t, n, !1); else if (e.detachEvent)e.detachEvent(`on${t}`, n); else { const r = e._handlers; const i = r && r[t]; if (i) { const o = H(i, n); o > -1 && (r[t] = i.slice(0, o).concat(i.slice(o + 1))); } } } function ve(e, t) { const n = me(e, t); if (n.length) for (let r = Array.prototype.slice.call(arguments, 2), i = 0; i < n.length; ++i)n[i].apply(null, r); } function be(e, t, n) { return typeof t === 'string' && (t = { type: t, preventDefault() { this.defaultPrevented = !0; } }), ve(e, n || t.type, e, t), Ce(t) || t.codemirrorIgnore; } function ye(e) { const t = e._handlers && e._handlers.cursorActivity; if (t) for (let n = e.curOp.cursorActivityHandlers || (e.curOp.cursorActivityHandlers = []), r = 0; r < t.length; ++r)H(n, t[r]) == -1 && n.push(t[r]); } function we(e, t) { return me(e, t).length > 0; } function xe(e) { e.prototype.on = function (e, t) { pe(this, e, t); }, e.prototype.off = function (e, t) { ge(this, e, t); }; } function ke(e) { e.preventDefault ? e.preventDefault() : e.returnValue = !1; } function _e(e) { e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0; } function Ce(e) { return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == 0; } function Se(e) { ke(e), _e(e); } function Oe(e) { return e.target || e.srcElement; } function je(e) { let t = e.which; return t == null && (1 & e.button ? t = 1 : 2 & e.button ? t = 3 : 4 & e.button && (t = 2)), b && e.ctrlKey && t == 1 && (t = 3), t; } let Le; let Te; const Me = (function () { if (a && s < 9) return !1; const e = T('div'); return 'draggable' in e || 'dragDrop' in e; }()); function Ae(e) { if (Le == null) { const t = T('span', '​'); L(e, T('span', [t, document.createTextNode('x')])), e.firstChild.offsetHeight != 0 && (Le = t.offsetWidth <= 1 && t.offsetHeight > 2 && !(a && s < 8)); } const n = Le ? T('span', '​') : T('span', ' ', null, 'display: inline-block; width: 1px; margin-right: -1px'); return n.setAttribute('cm-text', ''), n; } function Ee(e) { if (Te != null) return Te; const t = L(e, document.createTextNode('AخA')); const n = S(t, 0, 1).getBoundingClientRect(); const r = S(t, 1, 2).getBoundingClientRect(); return j(e), !(!n || n.left == n.right) && (Te = r.right - n.right < 3); } const Pe = '\n\nb'.split(/\n/).length != 3 ? function (e) { let t = 0; const n = []; const r = e.length; while (t <= r) { let i = e.indexOf('\n', t); i == -1 && (i = e.length); const o = e.slice(t, e.charAt(i - 1) == '\r' ? i - 1 : i); const a = o.indexOf('\r'); a != -1 ? (n.push(o.slice(0, a)), t += a + 1) : (n.push(o), t = i + 1); } return n; } : function (e) { return e.split(/\r\n?|\n/); }; const De = window.getSelection ? function (e) { try { return e.selectionStart != e.selectionEnd; } catch (t) { return !1; } } : function (e) { let t; try { t = e.ownerDocument.selection.createRange(); } catch (n) {} return !(!t || t.parentElement() != e) && t.compareEndPoints('StartToEnd', t) != 0; }; const Ne = (function () { const e = T('div'); return 'oncopy' in e || (e.setAttribute('oncopy', 'return;'), typeof e.oncopy === 'function'); }()); let Fe = null; function ze(e) { if (Fe != null) return Fe; const t = L(e, T('span', 'x')); const n = t.getBoundingClientRect(); const r = S(t, 0, 1).getBoundingClientRect(); return Fe = Math.abs(n.left - r.left) > 1; } const Ie = {}; const Be = {}; function He(e, t) { arguments.length > 2 && (t.dependencies = Array.prototype.slice.call(arguments, 2)), Ie[e] = t; } function Re(e, t) { Be[e] = t; } function We(e) { if (typeof e === 'string' && Be.hasOwnProperty(e))e = Be[e]; else if (e && typeof e.name === 'string' && Be.hasOwnProperty(e.name)) { let t = Be[e.name]; typeof t === 'string' && (t = { name: t }), e = Q(t, e), e.name = t.name; } else { if (typeof e === 'string' && /^[\w\-]+\/[\w\-]+\+xml$/.test(e)) return We('application/xml'); if (typeof e === 'string' && /^[\w\-]+\/[\w\-]+\+json$/.test(e)) return We('application/json'); } return typeof e === 'string' ? { name: e } : e || { name: 'null' }; } function qe(e, t) { t = We(t); const n = Ie[t.name]; if (!n) return qe(e, 'text/plain'); const r = n(e, t); if ($e.hasOwnProperty(t.name)) { const i = $e[t.name]; for (const o in i)i.hasOwnProperty(o) && (r.hasOwnProperty(o) && (r[`_${o}`] = r[o]), r[o] = i[o]); } if (r.name = t.name, t.helperType && (r.helperType = t.helperType), t.modeProps) for (const a in t.modeProps)r[a] = t.modeProps[a]; return r; } var $e = {}; function Ve(e, t) { const n = $e.hasOwnProperty(e) ? $e[e] : $e[e] = {}; z(t, n); } function Ue(e, t) { if (!0 === t) return t; if (e.copyState) return e.copyState(t); const n = {}; for (const r in t) { let i = t[r]; i instanceof Array && (i = i.concat([])), n[r] = i; } return n; } function Ge(e, t) { let n; while (e.innerMode) { if (n = e.innerMode(t), !n || n.mode == e) break; t = n.state, e = n.mode; } return n || { mode: e, state: t }; } function Ke(e, t, n) { return !e.startState || e.startState(t, n); } const Xe = function (e, t, n) { this.pos = this.start = 0, this.string = e, this.tabSize = t || 8, this.lastColumnPos = this.lastColumnValue = 0, this.lineStart = 0, this.lineOracle = n; }; function Ye(e, t) { if (t -= e.first, t < 0 || t >= e.size) throw new Error(`There is no line ${t + e.first} in the document.`); let n = e; while (!n.lines) for (let r = 0; ;++r) { const i = n.children[r]; const o = i.chunkSize(); if (t < o) { n = i; break; }t -= o; } return n.lines[t]; } function Ze(e, t, n) { const r = []; let i = t.line; return e.iter(t.line, n.line + 1, ((e) => { let o = e.text; i == n.line && (o = o.slice(0, n.ch)), i == t.line && (o = o.slice(t.ch)), r.push(o), ++i; })), r; } function Je(e, t, n) { const r = []; return e.iter(t, n, ((e) => { r.push(e.text); })), r; } function Qe(e, t) { const n = t - e.height; if (n) for (let r = e; r; r = r.parent)r.height += n; } function et(e) { if (e.parent == null) return null; for (var t = e.parent, n = H(t.lines, e), r = t.parent; r; t = r, r = r.parent) for (let i = 0; ;++i) { if (r.children[i] == t) break; n += r.children[i].chunkSize(); } return n + t.first; } function tt(e, t) { let n = e.first; e:do { for (let r = 0; r < e.children.length; ++r) { const i = e.children[r]; const o = i.height; if (t < o) { e = i; continue e; }t -= o, n += i.chunkSize(); } return n; } while (!e.lines);for (var a = 0; a < e.lines.length; ++a) { const s = e.lines[a]; const l = s.height; if (t < l) break; t -= l; } return n + a; } function nt(e, t) { return t >= e.first && t < e.first + e.size; } function rt(e, t) { return String(e.lineNumberFormatter(t + e.firstLineNumber)); } function it(e, t, n) { if (void 0 === n && (n = null), !(this instanceof it)) return new it(e, t, n); this.line = e, this.ch = t, this.sticky = n; } function ot(e, t) { return e.line - t.line || e.ch - t.ch; } function at(e, t) { return e.sticky == t.sticky && ot(e, t) == 0; } function st(e) { return it(e.line, e.ch); } function lt(e, t) { return ot(e, t) < 0 ? t : e; } function ct(e, t) { return ot(e, t) < 0 ? e : t; } function ut(e, t) { return Math.max(e.first, Math.min(t, e.first + e.size - 1)); } function ft(e, t) { if (t.line < e.first) return it(e.first, 0); const n = e.first + e.size - 1; return t.line > n ? it(n, Ye(e, n).text.length) : dt(t, Ye(e, t.line).text.length); } function dt(e, t) { const n = e.ch; return n == null || n > t ? it(e.line, t) : n < 0 ? it(e.line, 0) : e; } function ht(e, t) { for (var n = [], r = 0; r < t.length; r++)n[r] = ft(e, t[r]); return n; }Xe.prototype.eol = function () { return this.pos >= this.string.length; }, Xe.prototype.sol = function () { return this.pos == this.lineStart; }, Xe.prototype.peek = function () { return this.string.charAt(this.pos) || void 0; }, Xe.prototype.next = function () { if (this.pos < this.string.length) return this.string.charAt(this.pos++); }, Xe.prototype.eat = function (e) { let t; const n = this.string.charAt(this.pos); if (t = typeof e === 'string' ? n == e : n && (e.test ? e.test(n) : e(n)), t) return ++this.pos, n; }, Xe.prototype.eatWhile = function (e) { const t = this.pos; while (this.eat(e));return this.pos > t; }, Xe.prototype.eatSpace = function () { const e = this.pos; while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))++this.pos; return this.pos > e; }, Xe.prototype.skipToEnd = function () { this.pos = this.string.length; }, Xe.prototype.skipTo = function (e) { const t = this.string.indexOf(e, this.pos); if (t > -1) return this.pos = t, !0; }, Xe.prototype.backUp = function (e) { this.pos -= e; }, Xe.prototype.column = function () { return this.lastColumnPos < this.start && (this.lastColumnValue = I(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? I(this.string, this.lineStart, this.tabSize) : 0); }, Xe.prototype.indentation = function () { return I(this.string, null, this.tabSize) - (this.lineStart ? I(this.string, this.lineStart, this.tabSize) : 0); }, Xe.prototype.match = function (e, t, n) { if (typeof e !== 'string') { const r = this.string.slice(this.pos).match(e); return r && r.index > 0 ? null : (r && !1 !== t && (this.pos += r[0].length), r); } const i = function (e) { return n ? e.toLowerCase() : e; }; const o = this.string.substr(this.pos, e.length); if (i(o) == i(e)) return !1 !== t && (this.pos += e.length), !0; }, Xe.prototype.current = function () { return this.string.slice(this.start, this.pos); }, Xe.prototype.hideFirstChars = function (e, t) { this.lineStart += e; try { return t(); } finally { this.lineStart -= e; } }, Xe.prototype.lookAhead = function (e) { const t = this.lineOracle; return t && t.lookAhead(e); }, Xe.prototype.baseToken = function () { const e = this.lineOracle; return e && e.baseToken(this.pos); }; const pt = function (e, t) { this.state = e, this.lookAhead = t; }; const mt = function (e, t, n, r) { this.state = t, this.doc = e, this.line = n, this.maxLookAhead = r || 0, this.baseTokens = null, this.baseTokenPos = 1; }; function gt(e, t, n, r) { const i = [e.state.modeGen]; const o = {}; St(e, t.text, e.doc.mode, n, ((e, t) => i.push(e, t)), o, r); for (var a = n.state, s = function (r) { n.baseTokens = i; const s = e.state.overlays[r]; let l = 1; let c = 0; n.state = !0, St(e, t.text, s.mode, n, ((e, t) => { let n = l; while (c < e) { const r = i[l]; r > e && i.splice(l, 1, e, i[l + 1], r), l += 2, c = Math.min(e, r); } if (t) if (s.opaque)i.splice(n, l - n, e, `overlay ${t}`), l = n + 2; else for (;n < l; n += 2) { const o = i[n + 1]; i[n + 1] = `${o ? `${o} ` : ''}overlay ${t}`; } }), o), n.state = a, n.baseTokens = null, n.baseTokenPos = 1; }, l = 0; l < e.state.overlays.length; ++l)s(l); return { styles: i, classes: o.bgClass || o.textClass ? o : null }; } function vt(e, t, n) { if (!t.styles || t.styles[0] != e.state.modeGen) { const r = bt(e, et(t)); const i = t.text.length > e.options.maxHighlightLength && Ue(e.doc.mode, r.state); const o = gt(e, t, r); i && (r.state = i), t.stateAfter = r.save(!i), t.styles = o.styles, o.classes ? t.styleClasses = o.classes : t.styleClasses && (t.styleClasses = null), n === e.doc.highlightFrontier && (e.doc.modeFrontier = Math.max(e.doc.modeFrontier, ++e.doc.highlightFrontier)); } return t.styles; } function bt(e, t, n) { const r = e.doc; const i = e.display; if (!r.mode.startState) return new mt(r, !0, t); const o = Ot(e, t, n); const a = o > r.first && Ye(r, o - 1).stateAfter; const s = a ? mt.fromSaved(r, a, o) : new mt(r, Ke(r.mode), o); return r.iter(o, t, ((n) => { yt(e, n.text, s); const r = s.line; n.stateAfter = r == t - 1 || r % 5 == 0 || r >= i.viewFrom && r < i.viewTo ? s.save() : null, s.nextLine(); })), n && (r.modeFrontier = s.line), s; } function yt(e, t, n, r) { const i = e.doc.mode; const o = new Xe(t, e.options.tabSize, n); o.start = o.pos = r || 0, t == '' && wt(i, n.state); while (!o.eol())xt(i, o, n.state), o.start = o.pos; } function wt(e, t) { if (e.blankLine) return e.blankLine(t); if (e.innerMode) { const n = Ge(e, t); return n.mode.blankLine ? n.mode.blankLine(n.state) : void 0; } } function xt(e, t, n, r) { for (let i = 0; i < 10; i++) { r && (r[0] = Ge(e, n).mode); const o = e.token(t, n); if (t.pos > t.start) return o; } throw new Error(`Mode ${e.name} failed to advance stream.`); }mt.prototype.lookAhead = function (e) { const t = this.doc.getLine(this.line + e); return t != null && e > this.maxLookAhead && (this.maxLookAhead = e), t; }, mt.prototype.baseToken = function (e) { if (!this.baseTokens) return null; while (this.baseTokens[this.baseTokenPos] <= e) this.baseTokenPos += 2; const t = this.baseTokens[this.baseTokenPos + 1]; return { type: t && t.replace(/( |^)overlay .*/, ''), size: this.baseTokens[this.baseTokenPos] - e }; }, mt.prototype.nextLine = function () { this.line++, this.maxLookAhead > 0 && this.maxLookAhead--; }, mt.fromSaved = function (e, t, n) { return t instanceof pt ? new mt(e, Ue(e.mode, t.state), n, t.lookAhead) : new mt(e, Ue(e.mode, t), n); }, mt.prototype.save = function (e) { const t = !1 !== e ? Ue(this.doc.mode, this.state) : this.state; return this.maxLookAhead > 0 ? new pt(t, this.maxLookAhead) : t; }; const kt = function (e, t, n) { this.start = e.start, this.end = e.pos, this.string = e.current(), this.type = t || null, this.state = n; }; function _t(e, t, n, r) { let i; const o = e.doc; const a = o.mode; t = ft(o, t); let s; const l = Ye(o, t.line); const c = bt(e, t.line, n); const u = new Xe(l.text, e.options.tabSize, c); r && (s = []); while ((r || u.pos < t.ch) && !u.eol())u.start = u.pos, i = xt(a, u, c.state), r && s.push(new kt(u, i, Ue(o.mode, c.state))); return r ? s : new kt(u, i, c.state); } function Ct(e, t) { if (e) for (;;) { const n = e.match(/(?:^|\s+)line-(background-)?(\S+)/); if (!n) break; e = e.slice(0, n.index) + e.slice(n.index + n[0].length); const r = n[1] ? 'bgClass' : 'textClass'; t[r] == null ? t[r] = n[2] : new RegExp(`(?:^|\\s)${n[2]}(?:$|\\s)`).test(t[r]) || (t[r] += ` ${n[2]}`); } return e; } function St(e, t, n, r, i, o, a) { let s = n.flattenSpans; s == null && (s = e.options.flattenSpans); let l; let c = 0; let u = null; const f = new Xe(t, e.options.tabSize, r); const d = e.options.addModeClass && [null]; t == '' && Ct(wt(n, r.state), o); while (!f.eol()) { if (f.pos > e.options.maxHighlightLength ? (s = !1, a && yt(e, t, r, f.pos), f.pos = t.length, l = null) : l = Ct(xt(n, f, r.state, d), o), d) { const h = d[0].name; h && (l = `m-${l ? `${h} ${l}` : h}`); } if (!s || u != l) { while (c < f.start)c = Math.min(f.start, c + 5e3), i(c, u); u = l; }f.start = f.pos; } while (c < f.pos) { const p = Math.min(f.pos, c + 5e3); i(p, u), c = p; } } function Ot(e, t, n) { for (var r, i, o = e.doc, a = n ? -1 : t - (e.doc.mode.innerMode ? 1e3 : 100), s = t; s > a; --s) { if (s <= o.first) return o.first; const l = Ye(o, s - 1); const c = l.stateAfter; if (c && (!n || s + (c instanceof pt ? c.lookAhead : 0) <= o.modeFrontier)) return s; const u = I(l.text, null, e.options.tabSize); (i == null || r > u) && (i = s - 1, r = u); } return i; } function jt(e, t) { if (e.modeFrontier = Math.min(e.modeFrontier, t), !(e.highlightFrontier < t - 10)) { for (var n = e.first, r = t - 1; r > n; r--) { const i = Ye(e, r).stateAfter; if (i && (!(i instanceof pt) || r + i.lookAhead < t)) { n = r + 1; break; } }e.highlightFrontier = Math.min(e.highlightFrontier, n); } } let Lt = !1; let Tt = !1; function Mt() { Lt = !0; } function At() { Tt = !0; } function Et(e, t, n) { this.marker = e, this.from = t, this.to = n; } function Pt(e, t) { if (e) for (let n = 0; n < e.length; ++n) { const r = e[n]; if (r.marker == t) return r; } } function Dt(e, t) { for (var n, r = 0; r < e.length; ++r)e[r] != t && (n || (n = [])).push(e[r]); return n; } function Nt(e, t, n) { const r = n && window.WeakSet && (n.markedSpans || (n.markedSpans = new WeakSet())); r && r.has(e.markedSpans) ? e.markedSpans.push(t) : (e.markedSpans = e.markedSpans ? e.markedSpans.concat([t]) : [t], r && r.add(e.markedSpans)), t.marker.attachLine(e); } function Ft(e, t, n) { let r; if (e) for (let i = 0; i < e.length; ++i) { const o = e[i]; const a = o.marker; const s = o.from == null || (a.inclusiveLeft ? o.from <= t : o.from < t); if (s || o.from == t && a.type == 'bookmark' && (!n || !o.marker.insertLeft)) { const l = o.to == null || (a.inclusiveRight ? o.to >= t : o.to > t); (r || (r = [])).push(new Et(a, o.from, l ? null : o.to)); } } return r; } function zt(e, t, n) { let r; if (e) for (let i = 0; i < e.length; ++i) { const o = e[i]; const a = o.marker; const s = o.to == null || (a.inclusiveRight ? o.to >= t : o.to > t); if (s || o.from == t && a.type == 'bookmark' && (!n || o.marker.insertLeft)) { const l = o.from == null || (a.inclusiveLeft ? o.from <= t : o.from < t); (r || (r = [])).push(new Et(a, l ? null : o.from - t, o.to == null ? null : o.to - t)); } } return r; } function It(e, t) { if (t.full) return null; const n = nt(e, t.from.line) && Ye(e, t.from.line).markedSpans; const r = nt(e, t.to.line) && Ye(e, t.to.line).markedSpans; if (!n && !r) return null; const i = t.from.ch; const o = t.to.ch; const a = ot(t.from, t.to) == 0; let s = Ft(n, i, a); let l = zt(r, o, a); const c = t.text.length == 1; const u = X(t.text).length + (c ? i : 0); if (s) for (let f = 0; f < s.length; ++f) { const d = s[f]; if (d.to == null) { const h = Pt(l, d.marker); h ? c && (d.to = h.to == null ? null : h.to + u) : d.to = i; } } if (l) for (let p = 0; p < l.length; ++p) { const m = l[p]; if (m.to != null && (m.to += u), m.from == null) { const g = Pt(s, m.marker); g || (m.from = u, c && (s || (s = [])).push(m)); } else m.from += u, c && (s || (s = [])).push(m); }s && (s = Bt(s)), l && l != s && (l = Bt(l)); const v = [s]; if (!c) { let b; const y = t.text.length - 2; if (y > 0 && s) for (let w = 0; w < s.length; ++w)s[w].to == null && (b || (b = [])).push(new Et(s[w].marker, null, null)); for (let x = 0; x < y; ++x)v.push(b); v.push(l); } return v; } function Bt(e) { for (let t = 0; t < e.length; ++t) { const n = e[t]; n.from != null && n.from == n.to && !1 !== n.marker.clearWhenEmpty && e.splice(t--, 1); } return e.length ? e : null; } function Ht(e, t, n) { let r = null; if (e.iter(t.line, n.line + 1, ((e) => { if (e.markedSpans) for (let t = 0; t < e.markedSpans.length; ++t) { const n = e.markedSpans[t].marker; !n.readOnly || r && H(r, n) != -1 || (r || (r = [])).push(n); } })), !r) return null; for (var i = [{ from: t, to: n }], o = 0; o < r.length; ++o) for (let a = r[o], s = a.find(0), l = 0; l < i.length; ++l) { const c = i[l]; if (!(ot(c.to, s.from) < 0 || ot(c.from, s.to) > 0)) { const u = [l, 1]; const f = ot(c.from, s.from); const d = ot(c.to, s.to); (f < 0 || !a.inclusiveLeft && !f) && u.push({ from: c.from, to: s.from }), (d > 0 || !a.inclusiveRight && !d) && u.push({ from: s.to, to: c.to }), i.splice.apply(i, u), l += u.length - 3; } } return i; } function Rt(e) { const t = e.markedSpans; if (t) { for (let n = 0; n < t.length; ++n)t[n].marker.detachLine(e); e.markedSpans = null; } } function Wt(e, t) { if (t) { for (let n = 0; n < t.length; ++n)t[n].marker.attachLine(e); e.markedSpans = t; } } function qt(e) { return e.inclusiveLeft ? -1 : 0; } function $t(e) { return e.inclusiveRight ? 1 : 0; } function Vt(e, t) { const n = e.lines.length - t.lines.length; if (n != 0) return n; const r = e.find(); const i = t.find(); const o = ot(r.from, i.from) || qt(e) - qt(t); if (o) return -o; const a = ot(r.to, i.to) || $t(e) - $t(t); return a || t.id - e.id; } function Ut(e, t) { let n; const r = Tt && e.markedSpans; if (r) for (let i = void 0, o = 0; o < r.length; ++o)i = r[o], i.marker.collapsed && (t ? i.from : i.to) == null && (!n || Vt(n, i.marker) < 0) && (n = i.marker); return n; } function Gt(e) { return Ut(e, !0); } function Kt(e) { return Ut(e, !1); } function Xt(e, t) { let n; const r = Tt && e.markedSpans; if (r) for (let i = 0; i < r.length; ++i) { const o = r[i]; o.marker.collapsed && (o.from == null || o.from < t) && (o.to == null || o.to > t) && (!n || Vt(n, o.marker) < 0) && (n = o.marker); } return n; } function Yt(e, t, n, r, i) { const o = Ye(e, t); const a = Tt && o.markedSpans; if (a) for (let s = 0; s < a.length; ++s) { const l = a[s]; if (l.marker.collapsed) { const c = l.marker.find(0); const u = ot(c.from, n) || qt(l.marker) - qt(i); const f = ot(c.to, r) || $t(l.marker) - $t(i); if (!(u >= 0 && f <= 0 || u <= 0 && f >= 0) && (u <= 0 && (l.marker.inclusiveRight && i.inclusiveLeft ? ot(c.to, n) >= 0 : ot(c.to, n) > 0) || u >= 0 && (l.marker.inclusiveRight && i.inclusiveLeft ? ot(c.from, r) <= 0 : ot(c.from, r) < 0))) return !0; } } } function Zt(e) { let t; while (t = Gt(e))e = t.find(-1, !0).line; return e; } function Jt(e) { let t; while (t = Kt(e))e = t.find(1, !0).line; return e; } function Qt(e) { let t; let n; while (t = Kt(e))e = t.find(1, !0).line, (n || (n = [])).push(e); return n; } function en(e, t) { const n = Ye(e, t); const r = Zt(n); return n == r ? t : et(r); } function tn(e, t) { if (t > e.lastLine()) return t; let n; let r = Ye(e, t); if (!nn(e, r)) return t; while (n = Kt(r))r = n.find(1, !0).line; return et(r) + 1; } function nn(e, t) { const n = Tt && t.markedSpans; if (n) for (let r = void 0, i = 0; i < n.length; ++i) if (r = n[i], r.marker.collapsed) { if (r.from == null) return !0; if (!r.marker.widgetNode && r.from == 0 && r.marker.inclusiveLeft && rn(e, t, r)) return !0; } } function rn(e, t, n) { if (n.to == null) { const r = n.marker.find(1, !0); return rn(e, r.line, Pt(r.line.markedSpans, n.marker)); } if (n.marker.inclusiveRight && n.to == t.text.length) return !0; for (let i = void 0, o = 0; o < t.markedSpans.length; ++o) if (i = t.markedSpans[o], i.marker.collapsed && !i.marker.widgetNode && i.from == n.to && (i.to == null || i.to != n.from) && (i.marker.inclusiveLeft || n.marker.inclusiveRight) && rn(e, t, i)) return !0; } function on(e) { e = Zt(e); for (var t = 0, n = e.parent, r = 0; r < n.lines.length; ++r) { const i = n.lines[r]; if (i == e) break; t += i.height; } for (let o = n.parent; o; n = o, o = n.parent) for (let a = 0; a < o.children.length; ++a) { const s = o.children[a]; if (s == n) break; t += s.height; } return t; } function an(e) { if (e.height == 0) return 0; let t; let n = e.text.length; let r = e; while (t = Gt(r)) { const i = t.find(0, !0); r = i.from.line, n += i.from.ch - i.to.ch; }r = e; while (t = Kt(r)) { const o = t.find(0, !0); n -= r.text.length - o.from.ch, r = o.to.line, n += r.text.length - o.to.ch; } return n; } function sn(e) { const t = e.display; const n = e.doc; t.maxLine = Ye(n, n.first), t.maxLineLength = an(t.maxLine), t.maxLineChanged = !0, n.iter(((e) => { const n = an(e); n > t.maxLineLength && (t.maxLineLength = n, t.maxLine = e); })); } const ln = function (e, t, n) { this.text = e, Wt(this, t), this.height = n ? n(this) : 1; }; function cn(e, t, n, r) { e.text = t, e.stateAfter && (e.stateAfter = null), e.styles && (e.styles = null), e.order != null && (e.order = null), Rt(e), Wt(e, n); const i = r ? r(e) : 1; i != e.height && Qe(e, i); } function un(e) { e.parent = null, Rt(e); }ln.prototype.lineNo = function () { return et(this); }, xe(ln); const fn = {}; const dn = {}; function hn(e, t) { if (!e || /^\s*$/.test(e)) return null; const n = t.addModeClass ? dn : fn; return n[e] || (n[e] = e.replace(/\S+/g, 'cm-$&')); } function pn(e, t) {
        const n = M('span', null, null, l ? 'padding-right: .1px' : null); const r = {
          pre: M('pre', [n], 'CodeMirror-line'), content: n, col: 0, pos: 0, cm: e, trailingSpace: !1, splitSpaces: e.getOption('lineWrapping'),
        }; t.measure = {}; for (let i = 0; i <= (t.rest ? t.rest.length : 0); i++) { const o = i ? t.rest[i - 1] : t.line; let a = void 0; r.pos = 0, r.addToken = gn, Ee(e.display.measure) && (a = de(o, e.doc.direction)) && (r.addToken = bn(r.addToken, a)), r.map = []; const s = t != e.display.externalMeasured && et(o); wn(o, r, vt(e, o, s)), o.styleClasses && (o.styleClasses.bgClass && (r.bgClass = D(o.styleClasses.bgClass, r.bgClass || '')), o.styleClasses.textClass && (r.textClass = D(o.styleClasses.textClass, r.textClass || ''))), r.map.length == 0 && r.map.push(0, 0, r.content.appendChild(Ae(e.display.measure))), i == 0 ? (t.measure.map = r.map, t.measure.cache = {}) : ((t.measure.maps || (t.measure.maps = [])).push(r.map), (t.measure.caches || (t.measure.caches = [])).push({})); } if (l) { const c = r.content.lastChild; (/\bcm-tab\b/.test(c.className) || c.querySelector && c.querySelector('.cm-tab')) && (r.content.className = 'cm-tab-wrap-hack'); } return ve(e, 'renderLine', e, t.line, r.pre), r.pre.className && (r.textClass = D(r.pre.className, r.textClass || '')), r;
      } function mn(e) { const t = T('span', '•', 'cm-invalidchar'); return t.title = `\\u${e.charCodeAt(0).toString(16)}`, t.setAttribute('aria-label', t.title), t; } function gn(e, t, n, r, i, o, l) { if (t) { let c; const u = e.splitSpaces ? vn(t, e.trailingSpace) : t; const f = e.cm.state.specialChars; let d = !1; if (f.test(t)) { c = document.createDocumentFragment(); let h = 0; while (1) { f.lastIndex = h; const p = f.exec(t); const m = p ? p.index - h : t.length - h; if (m) { const g = document.createTextNode(u.slice(h, h + m)); a && s < 9 ? c.appendChild(T('span', [g])) : c.appendChild(g), e.map.push(e.pos, e.pos + m, g), e.col += m, e.pos += m; } if (!p) break; h += m + 1; let v = void 0; if (p[0] == '\t') { const b = e.cm.options.tabSize; const y = b - e.col % b; v = c.appendChild(T('span', K(y), 'cm-tab')), v.setAttribute('role', 'presentation'), v.setAttribute('cm-text', '\t'), e.col += y; } else p[0] == '\r' || p[0] == '\n' ? (v = c.appendChild(T('span', p[0] == '\r' ? '␍' : '␤', 'cm-invalidchar')), v.setAttribute('cm-text', p[0]), e.col += 1) : (v = e.cm.options.specialCharPlaceholder(p[0]), v.setAttribute('cm-text', p[0]), a && s < 9 ? c.appendChild(T('span', [v])) : c.appendChild(v), e.col += 1); e.map.push(e.pos, e.pos + 1, v), e.pos++; } } else e.col += t.length, c = document.createTextNode(u), e.map.push(e.pos, e.pos + t.length, c), a && s < 9 && (d = !0), e.pos += t.length; if (e.trailingSpace = u.charCodeAt(t.length - 1) == 32, n || r || i || d || o || l) { let w = n || ''; r && (w += r), i && (w += i); const x = T('span', [c], w, o); if (l) for (const k in l)l.hasOwnProperty(k) && k != 'style' && k != 'class' && x.setAttribute(k, l[k]); return e.content.appendChild(x); }e.content.appendChild(c); } } function vn(e, t) { if (e.length > 1 && !/ {2}/.test(e)) return e; for (var n = t, r = '', i = 0; i < e.length; i++) { let o = e.charAt(i); o != ' ' || !n || i != e.length - 1 && e.charCodeAt(i + 1) != 32 || (o = ' '), r += o, n = o == ' '; } return r; } function bn(e, t) { return function (n, r, i, o, a, s, l) { i = i ? `${i} cm-force-border` : 'cm-force-border'; for (let c = n.pos, u = c + r.length; ;) { for (var f = void 0, d = 0; d < t.length; d++) if (f = t[d], f.to > c && f.from <= c) break; if (f.to >= u) return e(n, r, i, o, a, s, l); e(n, r.slice(0, f.to - c), i, o, null, s, l), o = null, r = r.slice(f.to - c), c = f.to; } }; } function yn(e, t, n, r) { let i = !r && n.widgetNode; i && e.map.push(e.pos, e.pos + t, i), !r && e.cm.display.input.needsContentAttribute && (i || (i = e.content.appendChild(document.createElement('span'))), i.setAttribute('cm-marker', n.id)), i && (e.cm.display.input.setUneditable(i), e.content.appendChild(i)), e.pos += t, e.trailingSpace = !1; } function wn(e, t, n) { const r = e.markedSpans; const i = e.text; let o = 0; if (r) for (var a, s, l, c, u, f, d, h = i.length, p = 0, m = 1, g = '', v = 0; ;) { if (v == p) { l = c = u = s = '', d = null, f = null, v = 1 / 0; for (var b = [], y = void 0, w = 0; w < r.length; ++w) { const x = r[w]; const k = x.marker; if (k.type == 'bookmark' && x.from == p && k.widgetNode)b.push(k); else if (x.from <= p && (x.to == null || x.to > p || k.collapsed && x.to == p && x.from == p)) { if (x.to != null && x.to != p && v > x.to && (v = x.to, c = ''), k.className && (l += ` ${k.className}`), k.css && (s = (s ? `${s};` : '') + k.css), k.startStyle && x.from == p && (u += ` ${k.startStyle}`), k.endStyle && x.to == v && (y || (y = [])).push(k.endStyle, x.to), k.title && ((d || (d = {})).title = k.title), k.attributes) for (const _ in k.attributes)(d || (d = {}))[_] = k.attributes[_]; k.collapsed && (!f || Vt(f.marker, k) < 0) && (f = x); } else x.from > p && v > x.from && (v = x.from); } if (y) for (let C = 0; C < y.length; C += 2)y[C + 1] == v && (c += ` ${y[C]}`); if (!f || f.from == p) for (let S = 0; S < b.length; ++S)yn(t, 0, b[S]); if (f && (f.from || 0) == p) { if (yn(t, (f.to == null ? h + 1 : f.to) - p, f.marker, f.from == null), f.to == null) return; f.to == p && (f = !1); } } if (p >= h) break; const O = Math.min(h, v); while (1) { if (g) { const j = p + g.length; if (!f) { const L = j > O ? g.slice(0, O - p) : g; t.addToken(t, L, a ? a + l : l, u, p + L.length == v ? c : '', s, d); } if (j >= O) { g = g.slice(O - p), p = O; break; }p = j, u = ''; }g = i.slice(o, o = n[m++]), a = hn(n[m++], t.cm.options); } } else for (let T = 1; T < n.length; T += 2)t.addToken(t, i.slice(o, o = n[T]), hn(n[T + 1], t.cm.options)); } function xn(e, t, n) { this.line = t, this.rest = Qt(t), this.size = this.rest ? et(X(this.rest)) - n + 1 : 1, this.node = this.text = null, this.hidden = nn(e, t); } function kn(e, t, n) { for (var r, i = [], o = t; o < n; o = r) { const a = new xn(e.doc, Ye(e.doc, o), o); r = o + a.size, i.push(a); } return i; } let _n = null; function Cn(e) { _n ? _n.ops.push(e) : e.ownsGroup = _n = { ops: [e], delayedCallbacks: [] }; } function Sn(e) { const t = e.delayedCallbacks; let n = 0; do { for (;n < t.length; n++)t[n].call(null); for (let r = 0; r < e.ops.length; r++) { const i = e.ops[r]; if (i.cursorActivityHandlers) while (i.cursorActivityCalled < i.cursorActivityHandlers.length)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null, i.cm); } } while (n < t.length); } function On(e, t) { const n = e.ownsGroup; if (n) try { Sn(n); } finally { _n = null, t(n); } } let jn = null; function Ln(e, t) { const n = me(e, t); if (n.length) { let r; const i = Array.prototype.slice.call(arguments, 2); _n ? r = _n.delayedCallbacks : jn ? r = jn : (r = jn = [], setTimeout(Tn, 0)); for (let o = function (e) { r.push((() => n[e].apply(null, i))); }, a = 0; a < n.length; ++a)o(a); } } function Tn() { const e = jn; jn = null; for (let t = 0; t < e.length; ++t)e[t](); } function Mn(e, t, n, r) { for (let i = 0; i < t.changes.length; i++) { const o = t.changes[i]; o == 'text' ? Dn(e, t) : o == 'gutter' ? Fn(e, t, n, r) : o == 'class' ? Nn(e, t) : o == 'widget' && zn(e, t, r); }t.changes = null; } function An(e) { return e.node == e.text && (e.node = T('div', null, null, 'position: relative'), e.text.parentNode && e.text.parentNode.replaceChild(e.node, e.text), e.node.appendChild(e.text), a && s < 8 && (e.node.style.zIndex = 2)), e.node; } function En(e, t) { let n = t.bgClass ? `${t.bgClass} ${t.line.bgClass || ''}` : t.line.bgClass; if (n && (n += ' CodeMirror-linebackground'), t.background)n ? t.background.className = n : (t.background.parentNode.removeChild(t.background), t.background = null); else if (n) { const r = An(t); t.background = r.insertBefore(T('div', null, n), r.firstChild), e.display.input.setUneditable(t.background); } } function Pn(e, t) { const n = e.display.externalMeasured; return n && n.line == t.line ? (e.display.externalMeasured = null, t.measure = n.measure, n.built) : pn(e, t); } function Dn(e, t) { const n = t.text.className; const r = Pn(e, t); t.text == t.node && (t.node = r.pre), t.text.parentNode.replaceChild(r.pre, t.text), t.text = r.pre, r.bgClass != t.bgClass || r.textClass != t.textClass ? (t.bgClass = r.bgClass, t.textClass = r.textClass, Nn(e, t)) : n && (t.text.className = n); } function Nn(e, t) { En(e, t), t.line.wrapClass ? An(t).className = t.line.wrapClass : t.node != t.text && (t.node.className = ''); const n = t.textClass ? `${t.textClass} ${t.line.textClass || ''}` : t.line.textClass; t.text.className = n || ''; } function Fn(e, t, n, r) { if (t.gutter && (t.node.removeChild(t.gutter), t.gutter = null), t.gutterBackground && (t.node.removeChild(t.gutterBackground), t.gutterBackground = null), t.line.gutterClass) { const i = An(t); t.gutterBackground = T('div', null, `CodeMirror-gutter-background ${t.line.gutterClass}`, `left: ${e.options.fixedGutter ? r.fixedPos : -r.gutterTotalWidth}px; width: ${r.gutterTotalWidth}px`), e.display.input.setUneditable(t.gutterBackground), i.insertBefore(t.gutterBackground, t.text); } const o = t.line.gutterMarkers; if (e.options.lineNumbers || o) { const a = An(t); const s = t.gutter = T('div', null, 'CodeMirror-gutter-wrapper', `left: ${e.options.fixedGutter ? r.fixedPos : -r.gutterTotalWidth}px`); if (s.setAttribute('aria-hidden', 'true'), e.display.input.setUneditable(s), a.insertBefore(s, t.text), t.line.gutterClass && (s.className += ` ${t.line.gutterClass}`), !e.options.lineNumbers || o && o['CodeMirror-linenumbers'] || (t.lineNumber = s.appendChild(T('div', rt(e.options, n), 'CodeMirror-linenumber CodeMirror-gutter-elt', `left: ${r.gutterLeft['CodeMirror-linenumbers']}px; width: ${e.display.lineNumInnerWidth}px`))), o) for (let l = 0; l < e.display.gutterSpecs.length; ++l) { const c = e.display.gutterSpecs[l].className; const u = o.hasOwnProperty(c) && o[c]; u && s.appendChild(T('div', [u], 'CodeMirror-gutter-elt', `left: ${r.gutterLeft[c]}px; width: ${r.gutterWidth[c]}px`)); } } } function zn(e, t, n) { t.alignable && (t.alignable = null); for (let r = C('CodeMirror-linewidget'), i = t.node.firstChild, o = void 0; i; i = o)o = i.nextSibling, r.test(i.className) && t.node.removeChild(i); Bn(e, t, n); } function In(e, t, n, r) { const i = Pn(e, t); return t.text = t.node = i.pre, i.bgClass && (t.bgClass = i.bgClass), i.textClass && (t.textClass = i.textClass), Nn(e, t), Fn(e, t, n, r), Bn(e, t, r), t.node; } function Bn(e, t, n) { if (Hn(e, t.line, t, n, !0), t.rest) for (let r = 0; r < t.rest.length; r++)Hn(e, t.rest[r], t, n, !1); } function Hn(e, t, n, r, i) { if (t.widgets) for (let o = An(n), a = 0, s = t.widgets; a < s.length; ++a) { const l = s[a]; const c = T('div', [l.node], `CodeMirror-linewidget${l.className ? ` ${l.className}` : ''}`); l.handleMouseEvents || c.setAttribute('cm-ignore-events', 'true'), Rn(l, c, n, r), e.display.input.setUneditable(c), i && l.above ? o.insertBefore(c, n.gutter || n.text) : o.appendChild(c), Ln(l, 'redraw'); } } function Rn(e, t, n, r) { if (e.noHScroll) { (n.alignable || (n.alignable = [])).push(t); let i = r.wrapperWidth; t.style.left = `${r.fixedPos}px`, e.coverGutter || (i -= r.gutterTotalWidth, t.style.paddingLeft = `${r.gutterTotalWidth}px`), t.style.width = `${i}px`; }e.coverGutter && (t.style.zIndex = 5, t.style.position = 'relative', e.noHScroll || (t.style.marginLeft = `${-r.gutterTotalWidth}px`)); } function Wn(e) { if (e.height != null) return e.height; const t = e.doc.cm; if (!t) return 0; if (!A(document.body, e.node)) { let n = 'position: relative;'; e.coverGutter && (n += `margin-left: -${t.display.gutters.offsetWidth}px;`), e.noHScroll && (n += `width: ${t.display.wrapper.clientWidth}px;`), L(t.display.measure, T('div', [e.node], null, n)); } return e.height = e.node.parentNode.offsetHeight; } function qn(e, t) { for (let n = Oe(t); n != e.wrapper; n = n.parentNode) if (!n || n.nodeType == 1 && n.getAttribute('cm-ignore-events') == 'true' || n.parentNode == e.sizer && n != e.mover) return !0; } function $n(e) { return e.lineSpace.offsetTop; } function Vn(e) { return e.mover.offsetHeight - e.lineSpace.offsetHeight; } function Un(e) { if (e.cachedPaddingH) return e.cachedPaddingH; const t = L(e.measure, T('pre', 'x', 'CodeMirror-line-like')); const n = window.getComputedStyle ? window.getComputedStyle(t) : t.currentStyle; const r = { left: parseInt(n.paddingLeft), right: parseInt(n.paddingRight) }; return isNaN(r.left) || isNaN(r.right) || (e.cachedPaddingH = r), r; } function Gn(e) { return R - e.display.nativeBarWidth; } function Kn(e) { return e.display.scroller.clientWidth - Gn(e) - e.display.barWidth; } function Xn(e) { return e.display.scroller.clientHeight - Gn(e) - e.display.barHeight; } function Yn(e, t, n) { const r = e.options.lineWrapping; const i = r && Kn(e); if (!t.measure.heights || r && t.measure.width != i) { const o = t.measure.heights = []; if (r) { t.measure.width = i; for (let a = t.text.firstChild.getClientRects(), s = 0; s < a.length - 1; s++) { const l = a[s]; const c = a[s + 1]; Math.abs(l.bottom - c.bottom) > 2 && o.push((l.bottom + c.top) / 2 - n.top); } }o.push(n.bottom - n.top); } } function Zn(e, t, n) { if (e.line == t) return { map: e.measure.map, cache: e.measure.cache }; for (let r = 0; r < e.rest.length; r++) if (e.rest[r] == t) return { map: e.measure.maps[r], cache: e.measure.caches[r] }; for (let i = 0; i < e.rest.length; i++) if (et(e.rest[i]) > n) return { map: e.measure.maps[i], cache: e.measure.caches[i], before: !0 }; } function Jn(e, t) { t = Zt(t); const n = et(t); const r = e.display.externalMeasured = new xn(e.doc, t, n); r.lineN = n; const i = r.built = pn(e, r); return r.text = i.pre, L(e.display.lineMeasure, i.pre), r; } function Qn(e, t, n, r) { return nr(e, tr(e, t), n, r); } function er(e, t) { if (t >= e.display.viewFrom && t < e.display.viewTo) return e.display.view[Nr(e, t)]; const n = e.display.externalMeasured; return n && t >= n.lineN && t < n.lineN + n.size ? n : void 0; } function tr(e, t) {
        const n = et(t); let r = er(e, n); r && !r.text ? r = null : r && r.changes && (Mn(e, r, n, Mr(e)), e.curOp.forceUpdate = !0), r || (r = Jn(e, t)); const i = Zn(r, t, n); return {
          line: t, view: r, rect: null, map: i.map, cache: i.cache, before: i.before, hasHeights: !1,
        };
      } function nr(e, t, n, r, i) {
        t.before && (n = -1); let o; const a = n + (r || ''); return t.cache.hasOwnProperty(a) ? o = t.cache[a] : (t.rect || (t.rect = t.view.text.getBoundingClientRect()), t.hasHeights || (Yn(e, t.view, t.rect), t.hasHeights = !0), o = sr(e, t, n, r), o.bogus || (t.cache[a] = o)), {
          left: o.left, right: o.right, top: i ? o.rtop : o.top, bottom: i ? o.rbottom : o.bottom,
        };
      } let rr; const ir = {
        left: 0, right: 0, top: 0, bottom: 0,
      }; function or(e, t, n) {
        for (var r, i, o, a, s, l, c = 0; c < e.length; c += 3) if (s = e[c], l = e[c + 1], t < s ? (i = 0, o = 1, a = 'left') : t < l ? (i = t - s, o = i + 1) : (c == e.length - 3 || t == l && e[c + 3] > t) && (o = l - s, i = o - 1, t >= l && (a = 'right')), i != null) { if (r = e[c + 2], s == l && n == (r.insertLeft ? 'left' : 'right') && (a = n), n == 'left' && i == 0) while (c && e[c - 2] == e[c - 3] && e[c - 1].insertLeft)r = e[2 + (c -= 3)], a = 'left'; if (n == 'right' && i == l - s) while (c < e.length - 3 && e[c + 3] == e[c + 4] && !e[c + 5].insertLeft)r = e[(c += 3) + 2], a = 'right'; break; } return {
          node: r, start: i, end: o, collapse: a, coverStart: s, coverEnd: l,
        };
      } function ar(e, t) { let n = ir; if (t == 'left') { for (let r = 0; r < e.length; r++) if ((n = e[r]).left != n.right) break; } else for (let i = e.length - 1; i >= 0; i--) if ((n = e[i]).left != n.right) break; return n; } function sr(e, t, n, r) {
        let i; const o = or(t.map, n, r); const l = o.node; let c = o.start; let u = o.end; let f = o.collapse; if (l.nodeType == 3) { for (let d = 0; d < 4; d++) { while (c && oe(t.line.text.charAt(o.coverStart + c)))--c; while (o.coverStart + u < o.coverEnd && oe(t.line.text.charAt(o.coverStart + u)))++u; if (i = a && s < 9 && c == 0 && u == o.coverEnd - o.coverStart ? l.parentNode.getBoundingClientRect() : ar(S(l, c, u).getClientRects(), r), i.left || i.right || c == 0) break; u = c, c -= 1, f = 'right'; }a && s < 11 && (i = lr(e.display.measure, i)); } else { let h; c > 0 && (f = r = 'right'), i = e.options.lineWrapping && (h = l.getClientRects()).length > 1 ? h[r == 'right' ? h.length - 1 : 0] : l.getBoundingClientRect(); } if (a && s < 9 && !c && (!i || !i.left && !i.right)) {
          const p = l.parentNode.getClientRects()[0]; i = p ? {
            left: p.left, right: p.left + Tr(e.display), top: p.top, bottom: p.bottom,
          } : ir;
        } for (var m = i.top - t.rect.top, g = i.bottom - t.rect.top, v = (m + g) / 2, b = t.view.measure.heights, y = 0; y < b.length - 1; y++) if (v < b[y]) break; const w = y ? b[y - 1] : 0; const x = b[y]; const k = {
          left: (f == 'right' ? i.right : i.left) - t.rect.left, right: (f == 'left' ? i.left : i.right) - t.rect.left, top: w, bottom: x,
        }; return i.left || i.right || (k.bogus = !0), e.options.singleCursorHeightPerLine || (k.rtop = m, k.rbottom = g), k;
      } function lr(e, t) {
        if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !ze(e)) return t; const n = screen.logicalXDPI / screen.deviceXDPI; const r = screen.logicalYDPI / screen.deviceYDPI; return {
          left: t.left * n, right: t.right * n, top: t.top * r, bottom: t.bottom * r,
        };
      } function cr(e) { if (e.measure && (e.measure.cache = {}, e.measure.heights = null, e.rest)) for (let t = 0; t < e.rest.length; t++)e.measure.caches[t] = {}; } function ur(e) { e.display.externalMeasure = null, j(e.display.lineMeasure); for (let t = 0; t < e.display.view.length; t++)cr(e.display.view[t]); } function fr(e) { ur(e), e.display.cachedCharWidth = e.display.cachedTextHeight = e.display.cachedPaddingH = null, e.options.lineWrapping || (e.display.maxLineChanged = !0), e.display.lineNumChars = null; } function dr() { return u && g ? -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) : window.pageXOffset || (document.documentElement || document.body).scrollLeft; } function hr() { return u && g ? -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) : window.pageYOffset || (document.documentElement || document.body).scrollTop; } function pr(e) { let t = 0; if (e.widgets) for (let n = 0; n < e.widgets.length; ++n)e.widgets[n].above && (t += Wn(e.widgets[n])); return t; } function mr(e, t, n, r, i) { if (!i) { const o = pr(t); n.top += o, n.bottom += o; } if (r == 'line') return n; r || (r = 'local'); let a = on(t); if (r == 'local' ? a += $n(e.display) : a -= e.display.viewOffset, r == 'page' || r == 'window') { const s = e.display.lineSpace.getBoundingClientRect(); a += s.top + (r == 'window' ? 0 : hr()); const l = s.left + (r == 'window' ? 0 : dr()); n.left += l, n.right += l; } return n.top += a, n.bottom += a, n; } function gr(e, t, n) { if (n == 'div') return t; let r = t.left; let i = t.top; if (n == 'page')r -= dr(), i -= hr(); else if (n == 'local' || !n) { const o = e.display.sizer.getBoundingClientRect(); r += o.left, i += o.top; } const a = e.display.lineSpace.getBoundingClientRect(); return { left: r - a.left, top: i - a.top }; } function vr(e, t, n, r, i) { return r || (r = Ye(e.doc, t.line)), mr(e, r, Qn(e, r, t.ch, i), n); } function br(e, t, n, r, i, o) { function a(t, a) { const s = nr(e, i, t, a ? 'right' : 'left', o); return a ? s.left = s.right : s.right = s.left, mr(e, r, s, n); }r = r || Ye(e.doc, t.line), i || (i = tr(e, r)); const s = de(r, e.doc.direction); let l = t.ch; let c = t.sticky; if (l >= r.text.length ? (l = r.text.length, c = 'before') : l <= 0 && (l = 0, c = 'after'), !s) return a(c == 'before' ? l - 1 : l, c == 'before'); function u(e, t, n) { const r = s[t]; const i = r.level == 1; return a(n ? e - 1 : e, i != n); } const f = ue(s, l, c); const d = ce; const h = u(l, f, c == 'before'); return d != null && (h.other = u(l, d, c != 'before')), h; } function yr(e, t) {
        let n = 0; t = ft(e.doc, t), e.options.lineWrapping || (n = Tr(e.display) * t.ch); const r = Ye(e.doc, t.line); const i = on(r) + $n(e.display); return {
          left: n, right: n, top: i, bottom: i + r.height,
        };
      } function wr(e, t, n, r, i) { const o = it(e, t, n); return o.xRel = i, r && (o.outside = r), o; } function xr(e, t, n) { const r = e.doc; if (n += e.display.viewOffset, n < 0) return wr(r.first, 0, null, -1, -1); let i = tt(r, n); const o = r.first + r.size - 1; if (i > o) return wr(r.first + r.size - 1, Ye(r, o).text.length, null, 1, 1); t < 0 && (t = 0); for (let a = Ye(r, i); ;) { const s = Sr(e, a, i, t, n); const l = Xt(a, s.ch + (s.xRel > 0 || s.outside > 0 ? 1 : 0)); if (!l) return s; const c = l.find(1); if (c.line == i) return c; a = Ye(r, i = c.line); } } function kr(e, t, n, r) { r -= pr(t); let i = t.text.length; const o = se(((t) => nr(e, n, t - 1).bottom <= r), i, 0); return i = se(((t) => nr(e, n, t).top > r), o, i), { begin: o, end: i }; } function _r(e, t, n, r) { n || (n = tr(e, t)); const i = mr(e, t, nr(e, n, r), 'line').top; return kr(e, t, n, i); } function Cr(e, t, n, r) { return !(e.bottom <= n) && (e.top > n || (r ? e.left : e.right) > t); } function Sr(e, t, n, r, i) { i -= on(t); const o = tr(e, t); const a = pr(t); let s = 0; let l = t.text.length; let c = !0; const u = de(t, e.doc.direction); if (u) { const f = (e.options.lineWrapping ? jr : Or)(e, t, n, o, u, r, i); c = f.level != 1, s = c ? f.from : f.to - 1, l = c ? f.to : f.from - 1; } let d; let h; let p = null; let m = null; let g = se(((t) => { const n = nr(e, o, t); return n.top += a, n.bottom += a, !!Cr(n, r, i, !1) && (n.top <= i && n.left <= r && (p = t, m = n), !0); }), s, l); let v = !1; if (m) { const b = r - m.left < m.right - r; const y = b == c; g = p + (y ? 0 : 1), h = y ? 'after' : 'before', d = b ? m.left : m.right; } else { c || g != l && g != s || g++, h = g == 0 ? 'after' : g == t.text.length ? 'before' : nr(e, o, g - (c ? 1 : 0)).bottom + a <= i == c ? 'after' : 'before'; const w = br(e, it(n, g, h), 'line', t, o); d = w.left, v = i < w.top ? -1 : i >= w.bottom ? 1 : 0; } return g = ae(t.text, g, 1), wr(n, g, h, v, r - d); } function Or(e, t, n, r, i, o, a) { const s = se(((s) => { const l = i[s]; const c = l.level != 1; return Cr(br(e, it(n, c ? l.to : l.from, c ? 'before' : 'after'), 'line', t, r), o, a, !0); }), 0, i.length - 1); let l = i[s]; if (s > 0) { const c = l.level != 1; const u = br(e, it(n, c ? l.from : l.to, c ? 'after' : 'before'), 'line', t, r); Cr(u, o, a, !0) && u.top > a && (l = i[s - 1]); } return l; } function jr(e, t, n, r, i, o, a) { const s = kr(e, t, r, a); const l = s.begin; let c = s.end; /\s/.test(t.text.charAt(c - 1)) && c--; for (var u = null, f = null, d = 0; d < i.length; d++) { const h = i[d]; if (!(h.from >= c || h.to <= l)) { const p = h.level != 1; const m = nr(e, r, p ? Math.min(c, h.to) - 1 : Math.max(l, h.from)).right; const g = m < o ? o - m + 1e9 : m - o; (!u || f > g) && (u = h, f = g); } } return u || (u = i[i.length - 1]), u.from < l && (u = { from: l, to: u.to, level: u.level }), u.to > c && (u = { from: u.from, to: c, level: u.level }), u; } function Lr(e) { if (e.cachedTextHeight != null) return e.cachedTextHeight; if (rr == null) { rr = T('pre', null, 'CodeMirror-line-like'); for (let t = 0; t < 49; ++t)rr.appendChild(document.createTextNode('x')), rr.appendChild(T('br')); rr.appendChild(document.createTextNode('x')); }L(e.measure, rr); const n = rr.offsetHeight / 50; return n > 3 && (e.cachedTextHeight = n), j(e.measure), n || 1; } function Tr(e) { if (e.cachedCharWidth != null) return e.cachedCharWidth; const t = T('span', 'xxxxxxxxxx'); const n = T('pre', [t], 'CodeMirror-line-like'); L(e.measure, n); const r = t.getBoundingClientRect(); const i = (r.right - r.left) / 10; return i > 2 && (e.cachedCharWidth = i), i || 10; } function Mr(e) {
        for (var t = e.display, n = {}, r = {}, i = t.gutters.clientLeft, o = t.gutters.firstChild, a = 0; o; o = o.nextSibling, ++a) { const s = e.display.gutterSpecs[a].className; n[s] = o.offsetLeft + o.clientLeft + i, r[s] = o.clientWidth; } return {
          fixedPos: Ar(t), gutterTotalWidth: t.gutters.offsetWidth, gutterLeft: n, gutterWidth: r, wrapperWidth: t.wrapper.clientWidth,
        };
      } function Ar(e) { return e.scroller.getBoundingClientRect().left - e.sizer.getBoundingClientRect().left; } function Er(e) { const t = Lr(e.display); const n = e.options.lineWrapping; const r = n && Math.max(5, e.display.scroller.clientWidth / Tr(e.display) - 3); return function (i) { if (nn(e.doc, i)) return 0; let o = 0; if (i.widgets) for (let a = 0; a < i.widgets.length; a++)i.widgets[a].height && (o += i.widgets[a].height); return n ? o + (Math.ceil(i.text.length / r) || 1) * t : o + t; }; } function Pr(e) { const t = e.doc; const n = Er(e); t.iter(((e) => { const t = n(e); t != e.height && Qe(e, t); })); } function Dr(e, t, n, r) { const i = e.display; if (!n && Oe(t).getAttribute('cm-not-content') == 'true') return null; let o; let a; const s = i.lineSpace.getBoundingClientRect(); try { o = t.clientX - s.left, a = t.clientY - s.top; } catch (f) { return null; } let l; let c = xr(e, o, a); if (r && c.xRel > 0 && (l = Ye(e.doc, c.line).text).length == c.ch) { const u = I(l, l.length, e.options.tabSize) - l.length; c = it(c.line, Math.max(0, Math.round((o - Un(e.display).left) / Tr(e.display)) - u)); } return c; } function Nr(e, t) { if (t >= e.display.viewTo) return null; if (t -= e.display.viewFrom, t < 0) return null; for (let n = e.display.view, r = 0; r < n.length; r++) if (t -= n[r].size, t < 0) return r; } function Fr(e, t, n, r) { t == null && (t = e.doc.first), n == null && (n = e.doc.first + e.doc.size), r || (r = 0); const i = e.display; if (r && n < i.viewTo && (i.updateLineNumbers == null || i.updateLineNumbers > t) && (i.updateLineNumbers = t), e.curOp.viewChanged = !0, t >= i.viewTo)Tt && en(e.doc, t) < i.viewTo && Ir(e); else if (n <= i.viewFrom)Tt && tn(e.doc, n + r) > i.viewFrom ? Ir(e) : (i.viewFrom += r, i.viewTo += r); else if (t <= i.viewFrom && n >= i.viewTo)Ir(e); else if (t <= i.viewFrom) { const o = Br(e, n, n + r, 1); o ? (i.view = i.view.slice(o.index), i.viewFrom = o.lineN, i.viewTo += r) : Ir(e); } else if (n >= i.viewTo) { const a = Br(e, t, t, -1); a ? (i.view = i.view.slice(0, a.index), i.viewTo = a.lineN) : Ir(e); } else { const s = Br(e, t, t, -1); const l = Br(e, n, n + r, 1); s && l ? (i.view = i.view.slice(0, s.index).concat(kn(e, s.lineN, l.lineN)).concat(i.view.slice(l.index)), i.viewTo += r) : Ir(e); } const c = i.externalMeasured; c && (n < c.lineN ? c.lineN += r : t < c.lineN + c.size && (i.externalMeasured = null)); } function zr(e, t, n) { e.curOp.viewChanged = !0; const r = e.display; const i = e.display.externalMeasured; if (i && t >= i.lineN && t < i.lineN + i.size && (r.externalMeasured = null), !(t < r.viewFrom || t >= r.viewTo)) { const o = r.view[Nr(e, t)]; if (o.node != null) { const a = o.changes || (o.changes = []); H(a, n) == -1 && a.push(n); } } } function Ir(e) { e.display.viewFrom = e.display.viewTo = e.doc.first, e.display.view = [], e.display.viewOffset = 0; } function Br(e, t, n, r) { let i; let o = Nr(e, t); const a = e.display.view; if (!Tt || n == e.doc.first + e.doc.size) return { index: o, lineN: n }; for (var s = e.display.viewFrom, l = 0; l < o; l++)s += a[l].size; if (s != t) { if (r > 0) { if (o == a.length - 1) return null; i = s + a[o].size - t, o++; } else i = s - t; t += i, n += i; } while (en(e.doc, n) != n) { if (o == (r < 0 ? 0 : a.length - 1)) return null; n += r * a[o - (r < 0 ? 1 : 0)].size, o += r; } return { index: o, lineN: n }; } function Hr(e, t, n) { const r = e.display; const i = r.view; i.length == 0 || t >= r.viewTo || n <= r.viewFrom ? (r.view = kn(e, t, n), r.viewFrom = t) : (r.viewFrom > t ? r.view = kn(e, t, r.viewFrom).concat(r.view) : r.viewFrom < t && (r.view = r.view.slice(Nr(e, t))), r.viewFrom = t, r.viewTo < n ? r.view = r.view.concat(kn(e, r.viewTo, n)) : r.viewTo > n && (r.view = r.view.slice(0, Nr(e, n)))), r.viewTo = n; } function Rr(e) { for (var t = e.display.view, n = 0, r = 0; r < t.length; r++) { const i = t[r]; i.hidden || i.node && !i.changes || ++n; } return n; } function Wr(e) { e.display.input.showSelection(e.display.input.prepareSelection()); } function qr(e, t) { void 0 === t && (t = !0); for (var n = e.doc, r = {}, i = r.cursors = document.createDocumentFragment(), o = r.selection = document.createDocumentFragment(), a = 0; a < n.sel.ranges.length; a++) if (t || a != n.sel.primIndex) { const s = n.sel.ranges[a]; if (!(s.from().line >= e.display.viewTo || s.to().line < e.display.viewFrom)) { const l = s.empty(); (l || e.options.showCursorWhenSelecting) && $r(e, s.head, i), l || Ur(e, s, o); } } return r; } function $r(e, t, n) { const r = br(e, t, 'div', null, null, !e.options.singleCursorHeightPerLine); const i = n.appendChild(T('div', ' ', 'CodeMirror-cursor')); if (i.style.left = `${r.left}px`, i.style.top = `${r.top}px`, i.style.height = `${Math.max(0, r.bottom - r.top) * e.options.cursorHeight}px`, r.other) { const o = n.appendChild(T('div', ' ', 'CodeMirror-cursor CodeMirror-secondarycursor')); o.style.display = '', o.style.left = `${r.other.left}px`, o.style.top = `${r.other.top}px`, o.style.height = `${0.85 * (r.other.bottom - r.other.top)}px`; } } function Vr(e, t) { return e.top - t.top || e.left - t.left; } function Ur(e, t, n) { const r = e.display; const i = e.doc; const o = document.createDocumentFragment(); const a = Un(e.display); const s = a.left; const l = Math.max(r.sizerWidth, Kn(e) - r.sizer.offsetLeft) - a.right; const c = i.direction == 'ltr'; function u(e, t, n, r) { t < 0 && (t = 0), t = Math.round(t), r = Math.round(r), o.appendChild(T('div', null, 'CodeMirror-selected', `position: absolute; left: ${e}px;\n                             top: ${t}px; width: ${n == null ? l - e : n}px;\n                             height: ${r - t}px`)); } function f(t, n, r) { let o; let a; const f = Ye(i, t); const d = f.text.length; function h(n, r) { return vr(e, it(t, n), 'div', f, r); } function p(t, n, r) { const i = _r(e, f, null, t); const o = n == 'ltr' == (r == 'after') ? 'left' : 'right'; const a = r == 'after' ? i.begin : i.end - (/\s/.test(f.text.charAt(i.end - 1)) ? 2 : 1); return h(a, o)[o]; } const m = de(f, i.direction); return le(m, n || 0, r == null ? d : r, ((e, t, i, f) => { const g = i == 'ltr'; const v = h(e, g ? 'left' : 'right'); const b = h(t - 1, g ? 'right' : 'left'); const y = n == null && e == 0; const w = r == null && t == d; const x = f == 0; const k = !m || f == m.length - 1; if (b.top - v.top <= 3) { const _ = (c ? y : w) && x; const C = (c ? w : y) && k; const S = _ ? s : (g ? v : b).left; const O = C ? l : (g ? b : v).right; u(S, v.top, O - S, v.bottom); } else { let j; let L; let T; let M; g ? (j = c && y && x ? s : v.left, L = c ? l : p(e, i, 'before'), T = c ? s : p(t, i, 'after'), M = c && w && k ? l : b.right) : (j = c ? p(e, i, 'before') : s, L = !c && y && x ? l : v.right, T = !c && w && k ? s : b.left, M = c ? p(t, i, 'after') : l), u(j, v.top, L - j, v.bottom), v.bottom < b.top && u(s, v.bottom, null, b.top), u(T, b.top, M - T, b.bottom); }(!o || Vr(v, o) < 0) && (o = v), Vr(b, o) < 0 && (o = b), (!a || Vr(v, a) < 0) && (a = v), Vr(b, a) < 0 && (a = b); })), { start: o, end: a }; } const d = t.from(); const h = t.to(); if (d.line == h.line)f(d.line, d.ch, h.ch); else { const p = Ye(i, d.line); const m = Ye(i, h.line); const g = Zt(p) == Zt(m); const v = f(d.line, d.ch, g ? p.text.length + 1 : null).end; const b = f(h.line, g ? 0 : null, h.ch).start; g && (v.top < b.top - 2 ? (u(v.right, v.top, null, v.bottom), u(s, b.top, b.left, b.bottom)) : u(v.right, v.top, b.left - v.right, v.bottom)), v.bottom < b.top && u(s, v.bottom, null, b.top); }n.appendChild(o); } function Gr(e) { if (e.state.focused) { const t = e.display; clearInterval(t.blinker); let n = !0; t.cursorDiv.style.visibility = '', e.options.cursorBlinkRate > 0 ? t.blinker = setInterval((() => { e.hasFocus() || Zr(e), t.cursorDiv.style.visibility = (n = !n) ? '' : 'hidden'; }), e.options.cursorBlinkRate) : e.options.cursorBlinkRate < 0 && (t.cursorDiv.style.visibility = 'hidden'); } } function Kr(e) { e.hasFocus() || (e.display.input.focus(), e.state.focused || Yr(e)); } function Xr(e) { e.state.delayingBlurEvent = !0, setTimeout((() => { e.state.delayingBlurEvent && (e.state.delayingBlurEvent = !1, e.state.focused && Zr(e)); }), 100); } function Yr(e, t) { e.state.delayingBlurEvent && !e.state.draggingText && (e.state.delayingBlurEvent = !1), e.options.readOnly != 'nocursor' && (e.state.focused || (ve(e, 'focus', e, t), e.state.focused = !0, P(e.display.wrapper, 'CodeMirror-focused'), e.curOp || e.display.selForContextMenu == e.doc.sel || (e.display.input.reset(), l && setTimeout((() => e.display.input.reset(!0)), 20)), e.display.input.receivedFocus()), Gr(e)); } function Zr(e, t) { e.state.delayingBlurEvent || (e.state.focused && (ve(e, 'blur', e, t), e.state.focused = !1, O(e.display.wrapper, 'CodeMirror-focused')), clearInterval(e.display.blinker), setTimeout((() => { e.state.focused || (e.display.shift = !1); }), 150)); } function Jr(e) { for (let t = e.display, n = t.lineDiv.offsetTop, r = 0; r < t.view.length; r++) { const i = t.view[r]; const o = e.options.lineWrapping; let l = void 0; let c = 0; if (!i.hidden) { if (a && s < 8) { const u = i.node.offsetTop + i.node.offsetHeight; l = u - n, n = u; } else { const f = i.node.getBoundingClientRect(); l = f.bottom - f.top, !o && i.text.firstChild && (c = i.text.firstChild.getBoundingClientRect().right - f.left - 1); } const d = i.line.height - l; if ((d > 0.005 || d < -0.005) && (Qe(i.line, l), Qr(i.line), i.rest)) for (let h = 0; h < i.rest.length; h++)Qr(i.rest[h]); if (c > e.display.sizerWidth) { const p = Math.ceil(c / Tr(e.display)); p > e.display.maxLineLength && (e.display.maxLineLength = p, e.display.maxLine = i.line, e.display.maxLineChanged = !0); } } } } function Qr(e) { if (e.widgets) for (let t = 0; t < e.widgets.length; ++t) { const n = e.widgets[t]; const r = n.node.parentNode; r && (n.height = r.offsetHeight); } } function ei(e, t, n) { let r = n && n.top != null ? Math.max(0, n.top) : e.scroller.scrollTop; r = Math.floor(r - $n(e)); const i = n && n.bottom != null ? n.bottom : r + e.wrapper.clientHeight; let o = tt(t, r); let a = tt(t, i); if (n && n.ensure) { const s = n.ensure.from.line; const l = n.ensure.to.line; s < o ? (o = s, a = tt(t, on(Ye(t, s)) + e.wrapper.clientHeight)) : Math.min(l, t.lastLine()) >= a && (o = tt(t, on(Ye(t, l)) - e.wrapper.clientHeight), a = l); } return { from: o, to: Math.max(a, o + 1) }; } function ti(e, t) { if (!be(e, 'scrollCursorIntoView')) { const n = e.display; const r = n.sizer.getBoundingClientRect(); let i = null; if (t.top + r.top < 0 ? i = !0 : t.bottom + r.top > (window.innerHeight || document.documentElement.clientHeight) && (i = !1), i != null && !p) { const o = T('div', '​', null, `position: absolute;\n                         top: ${t.top - n.viewOffset - $n(e.display)}px;\n                         height: ${t.bottom - t.top + Gn(e) + n.barHeight}px;\n                         left: ${t.left}px; width: ${Math.max(2, t.right - t.left)}px;`); e.display.lineSpace.appendChild(o), o.scrollIntoView(i), e.display.lineSpace.removeChild(o); } } } function ni(e, t, n, r) {
        let i; r == null && (r = 0), e.options.lineWrapping || t != n || (n = t.sticky == 'before' ? it(t.line, t.ch + 1, 'before') : t, t = t.ch ? it(t.line, t.sticky == 'before' ? t.ch - 1 : t.ch, 'after') : t); for (let o = 0; o < 5; o++) {
          let a = !1; const s = br(e, t); const l = n && n != t ? br(e, n) : s; i = {
            left: Math.min(s.left, l.left), top: Math.min(s.top, l.top) - r, right: Math.max(s.left, l.left), bottom: Math.max(s.bottom, l.bottom) + r,
          }; const c = ii(e, i); const u = e.doc.scrollTop; const f = e.doc.scrollLeft; if (c.scrollTop != null && (fi(e, c.scrollTop), Math.abs(e.doc.scrollTop - u) > 1 && (a = !0)), c.scrollLeft != null && (hi(e, c.scrollLeft), Math.abs(e.doc.scrollLeft - f) > 1 && (a = !0)), !a) break;
        } return i;
      } function ri(e, t) { const n = ii(e, t); n.scrollTop != null && fi(e, n.scrollTop), n.scrollLeft != null && hi(e, n.scrollLeft); } function ii(e, t) { const n = e.display; const r = Lr(e.display); t.top < 0 && (t.top = 0); const i = e.curOp && e.curOp.scrollTop != null ? e.curOp.scrollTop : n.scroller.scrollTop; const o = Xn(e); const a = {}; t.bottom - t.top > o && (t.bottom = t.top + o); const s = e.doc.height + Vn(n); const l = t.top < r; const c = t.bottom > s - r; if (t.top < i)a.scrollTop = l ? 0 : t.top; else if (t.bottom > i + o) { const u = Math.min(t.top, (c ? s : t.bottom) - o); u != i && (a.scrollTop = u); } const f = e.options.fixedGutter ? 0 : n.gutters.offsetWidth; const d = e.curOp && e.curOp.scrollLeft != null ? e.curOp.scrollLeft : n.scroller.scrollLeft - f; const h = Kn(e) - n.gutters.offsetWidth; const p = t.right - t.left > h; return p && (t.right = t.left + h), t.left < 10 ? a.scrollLeft = 0 : t.left < d ? a.scrollLeft = Math.max(0, t.left + f - (p ? 0 : 10)) : t.right > h + d - 3 && (a.scrollLeft = t.right + (p ? 0 : 10) - h), a; } function oi(e, t) { t != null && (ci(e), e.curOp.scrollTop = (e.curOp.scrollTop == null ? e.doc.scrollTop : e.curOp.scrollTop) + t); } function ai(e) { ci(e); const t = e.getCursor(); e.curOp.scrollToPos = { from: t, to: t, margin: e.options.cursorScrollMargin }; } function si(e, t, n) { t == null && n == null || ci(e), t != null && (e.curOp.scrollLeft = t), n != null && (e.curOp.scrollTop = n); } function li(e, t) { ci(e), e.curOp.scrollToPos = t; } function ci(e) { const t = e.curOp.scrollToPos; if (t) { e.curOp.scrollToPos = null; const n = yr(e, t.from); const r = yr(e, t.to); ui(e, n, r, t.margin); } } function ui(e, t, n, r) {
        const i = ii(e, {
          left: Math.min(t.left, n.left), top: Math.min(t.top, n.top) - r, right: Math.max(t.right, n.right), bottom: Math.max(t.bottom, n.bottom) + r,
        }); si(e, i.scrollLeft, i.scrollTop);
      } function fi(e, t) { Math.abs(e.doc.scrollTop - t) < 2 || (n || Wi(e, { top: t }), di(e, t, !0), n && Wi(e), Di(e, 100)); } function di(e, t, n) { t = Math.max(0, Math.min(e.display.scroller.scrollHeight - e.display.scroller.clientHeight, t)), (e.display.scroller.scrollTop != t || n) && (e.doc.scrollTop = t, e.display.scrollbars.setScrollTop(t), e.display.scroller.scrollTop != t && (e.display.scroller.scrollTop = t)); } function hi(e, t, n, r) { t = Math.max(0, Math.min(t, e.display.scroller.scrollWidth - e.display.scroller.clientWidth)), (n ? t == e.doc.scrollLeft : Math.abs(e.doc.scrollLeft - t) < 2) && !r || (e.doc.scrollLeft = t, Ui(e), e.display.scroller.scrollLeft != t && (e.display.scroller.scrollLeft = t), e.display.scrollbars.setScrollLeft(t)); } function pi(e) {
        const t = e.display; const n = t.gutters.offsetWidth; const r = Math.round(e.doc.height + Vn(e.display)); return {
          clientHeight: t.scroller.clientHeight, viewHeight: t.wrapper.clientHeight, scrollWidth: t.scroller.scrollWidth, clientWidth: t.scroller.clientWidth, viewWidth: t.wrapper.clientWidth, barLeft: e.options.fixedGutter ? n : 0, docHeight: r, scrollHeight: r + Gn(e) + t.barHeight, nativeBarWidth: t.nativeBarWidth, gutterWidth: n,
        };
      } const mi = function (e, t, n) { this.cm = n; const r = this.vert = T('div', [T('div', null, null, 'min-width: 1px')], 'CodeMirror-vscrollbar'); const i = this.horiz = T('div', [T('div', null, null, 'height: 100%; min-height: 1px')], 'CodeMirror-hscrollbar'); r.tabIndex = i.tabIndex = -1, e(r), e(i), pe(r, 'scroll', (() => { r.clientHeight && t(r.scrollTop, 'vertical'); })), pe(i, 'scroll', (() => { i.clientWidth && t(i.scrollLeft, 'horizontal'); })), this.checkedZeroWidth = !1, a && s < 8 && (this.horiz.style.minHeight = this.vert.style.minWidth = '18px'); }; mi.prototype.update = function (e) { const t = e.scrollWidth > e.clientWidth + 1; const n = e.scrollHeight > e.clientHeight + 1; const r = e.nativeBarWidth; if (n) { this.vert.style.display = 'block', this.vert.style.bottom = t ? `${r}px` : '0'; const i = e.viewHeight - (t ? r : 0); this.vert.firstChild.style.height = `${Math.max(0, e.scrollHeight - e.clientHeight + i)}px`; } else this.vert.style.display = '', this.vert.firstChild.style.height = '0'; if (t) { this.horiz.style.display = 'block', this.horiz.style.right = n ? `${r}px` : '0', this.horiz.style.left = `${e.barLeft}px`; const o = e.viewWidth - e.barLeft - (n ? r : 0); this.horiz.firstChild.style.width = `${Math.max(0, e.scrollWidth - e.clientWidth + o)}px`; } else this.horiz.style.display = '', this.horiz.firstChild.style.width = '0'; return !this.checkedZeroWidth && e.clientHeight > 0 && (r == 0 && this.zeroWidthHack(), this.checkedZeroWidth = !0), { right: n ? r : 0, bottom: t ? r : 0 }; }, mi.prototype.setScrollLeft = function (e) { this.horiz.scrollLeft != e && (this.horiz.scrollLeft = e), this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz, 'horiz'); }, mi.prototype.setScrollTop = function (e) { this.vert.scrollTop != e && (this.vert.scrollTop = e), this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert, 'vert'); }, mi.prototype.zeroWidthHack = function () { const e = b && !h ? '12px' : '18px'; this.horiz.style.height = this.vert.style.width = e, this.horiz.style.pointerEvents = this.vert.style.pointerEvents = 'none', this.disableHoriz = new B(), this.disableVert = new B(); }, mi.prototype.enableZeroWidthBar = function (e, t, n) { function r() { const i = e.getBoundingClientRect(); const o = n == 'vert' ? document.elementFromPoint(i.right - 1, (i.top + i.bottom) / 2) : document.elementFromPoint((i.right + i.left) / 2, i.bottom - 1); o != e ? e.style.pointerEvents = 'none' : t.set(1e3, r); }e.style.pointerEvents = 'auto', t.set(1e3, r); }, mi.prototype.clear = function () { const e = this.horiz.parentNode; e.removeChild(this.horiz), e.removeChild(this.vert); }; const gi = function () {}; function vi(e, t) { t || (t = pi(e)); let n = e.display.barWidth; let r = e.display.barHeight; bi(e, t); for (let i = 0; i < 4 && n != e.display.barWidth || r != e.display.barHeight; i++)n != e.display.barWidth && e.options.lineWrapping && Jr(e), bi(e, pi(e)), n = e.display.barWidth, r = e.display.barHeight; } function bi(e, t) { const n = e.display; const r = n.scrollbars.update(t); n.sizer.style.paddingRight = `${n.barWidth = r.right}px`, n.sizer.style.paddingBottom = `${n.barHeight = r.bottom}px`, n.heightForcer.style.borderBottom = `${r.bottom}px solid transparent`, r.right && r.bottom ? (n.scrollbarFiller.style.display = 'block', n.scrollbarFiller.style.height = `${r.bottom}px`, n.scrollbarFiller.style.width = `${r.right}px`) : n.scrollbarFiller.style.display = '', r.bottom && e.options.coverGutterNextToScrollbar && e.options.fixedGutter ? (n.gutterFiller.style.display = 'block', n.gutterFiller.style.height = `${r.bottom}px`, n.gutterFiller.style.width = `${t.gutterWidth}px`) : n.gutterFiller.style.display = ''; }gi.prototype.update = function () { return { bottom: 0, right: 0 }; }, gi.prototype.setScrollLeft = function () {}, gi.prototype.setScrollTop = function () {}, gi.prototype.clear = function () {}; const yi = { native: mi, null: gi }; function wi(e) { e.display.scrollbars && (e.display.scrollbars.clear(), e.display.scrollbars.addClass && O(e.display.wrapper, e.display.scrollbars.addClass)), e.display.scrollbars = new yi[e.options.scrollbarStyle]((((t) => { e.display.wrapper.insertBefore(t, e.display.scrollbarFiller), pe(t, 'mousedown', (() => { e.state.focused && setTimeout((() => e.display.input.focus()), 0); })), t.setAttribute('cm-not-content', 'true'); })), (((t, n) => { n == 'horizontal' ? hi(e, t) : fi(e, t); })), e), e.display.scrollbars.addClass && P(e.display.wrapper, e.display.scrollbars.addClass); } let xi = 0; function ki(e) {
        e.curOp = {
          cm: e, viewChanged: !1, startHeight: e.doc.height, forceUpdate: !1, updateInput: 0, typing: !1, changeObjs: null, cursorActivityHandlers: null, cursorActivityCalled: 0, selectionChanged: !1, updateMaxLine: !1, scrollLeft: null, scrollTop: null, scrollToPos: null, focus: !1, id: ++xi, markArrays: null,
        }, Cn(e.curOp);
      } function _i(e) { const t = e.curOp; t && On(t, ((e) => { for (let t = 0; t < e.ops.length; t++)e.ops[t].cm.curOp = null; Ci(e); })); } function Ci(e) { for (var t = e.ops, n = 0; n < t.length; n++)Si(t[n]); for (let r = 0; r < t.length; r++)Oi(t[r]); for (let i = 0; i < t.length; i++)ji(t[i]); for (let o = 0; o < t.length; o++)Li(t[o]); for (let a = 0; a < t.length; a++)Ti(t[a]); } function Si(e) { const t = e.cm; const n = t.display; zi(t), e.updateMaxLine && sn(t), e.mustUpdate = e.viewChanged || e.forceUpdate || e.scrollTop != null || e.scrollToPos && (e.scrollToPos.from.line < n.viewFrom || e.scrollToPos.to.line >= n.viewTo) || n.maxLineChanged && t.options.lineWrapping, e.update = e.mustUpdate && new Fi(t, e.mustUpdate && { top: e.scrollTop, ensure: e.scrollToPos }, e.forceUpdate); } function Oi(e) { e.updatedDisplay = e.mustUpdate && Hi(e.cm, e.update); } function ji(e) { const t = e.cm; const n = t.display; e.updatedDisplay && Jr(t), e.barMeasure = pi(t), n.maxLineChanged && !t.options.lineWrapping && (e.adjustWidthTo = Qn(t, n.maxLine, n.maxLine.text.length).left + 3, t.display.sizerWidth = e.adjustWidthTo, e.barMeasure.scrollWidth = Math.max(n.scroller.clientWidth, n.sizer.offsetLeft + e.adjustWidthTo + Gn(t) + t.display.barWidth), e.maxScrollLeft = Math.max(0, n.sizer.offsetLeft + e.adjustWidthTo - Kn(t))), (e.updatedDisplay || e.selectionChanged) && (e.preparedSelection = n.input.prepareSelection()); } function Li(e) { const t = e.cm; e.adjustWidthTo != null && (t.display.sizer.style.minWidth = `${e.adjustWidthTo}px`, e.maxScrollLeft < t.doc.scrollLeft && hi(t, Math.min(t.display.scroller.scrollLeft, e.maxScrollLeft), !0), t.display.maxLineChanged = !1); const n = e.focus && e.focus == E(); e.preparedSelection && t.display.input.showSelection(e.preparedSelection, n), (e.updatedDisplay || e.startHeight != t.doc.height) && vi(t, e.barMeasure), e.updatedDisplay && Vi(t, e.barMeasure), e.selectionChanged && Gr(t), t.state.focused && e.updateInput && t.display.input.reset(e.typing), n && Kr(e.cm); } function Ti(e) { const t = e.cm; const n = t.display; const r = t.doc; if (e.updatedDisplay && Ri(t, e.update), n.wheelStartX == null || e.scrollTop == null && e.scrollLeft == null && !e.scrollToPos || (n.wheelStartX = n.wheelStartY = null), e.scrollTop != null && di(t, e.scrollTop, e.forceScroll), e.scrollLeft != null && hi(t, e.scrollLeft, !0, !0), e.scrollToPos) { const i = ni(t, ft(r, e.scrollToPos.from), ft(r, e.scrollToPos.to), e.scrollToPos.margin); ti(t, i); } const o = e.maybeHiddenMarkers; const a = e.maybeUnhiddenMarkers; if (o) for (let s = 0; s < o.length; ++s)o[s].lines.length || ve(o[s], 'hide'); if (a) for (let l = 0; l < a.length; ++l)a[l].lines.length && ve(a[l], 'unhide'); n.wrapper.offsetHeight && (r.scrollTop = t.display.scroller.scrollTop), e.changeObjs && ve(t, 'changes', t, e.changeObjs), e.update && e.update.finish(); } function Mi(e, t) { if (e.curOp) return t(); ki(e); try { return t(); } finally { _i(e); } } function Ai(e, t) { return function () { if (e.curOp) return t.apply(e, arguments); ki(e); try { return t.apply(e, arguments); } finally { _i(e); } }; } function Ei(e) { return function () { if (this.curOp) return e.apply(this, arguments); ki(this); try { return e.apply(this, arguments); } finally { _i(this); } }; } function Pi(e) { return function () { const t = this.cm; if (!t || t.curOp) return e.apply(this, arguments); ki(t); try { return e.apply(this, arguments); } finally { _i(t); } }; } function Di(e, t) { e.doc.highlightFrontier < e.display.viewTo && e.state.highlight.set(t, F(Ni, e)); } function Ni(e) { const t = e.doc; if (!(t.highlightFrontier >= e.display.viewTo)) { const n = +new Date() + e.options.workTime; const r = bt(e, t.highlightFrontier); const i = []; t.iter(r.line, Math.min(t.first + t.size, e.display.viewTo + 500), ((o) => { if (r.line >= e.display.viewFrom) { const a = o.styles; const s = o.text.length > e.options.maxHighlightLength ? Ue(t.mode, r.state) : null; const l = gt(e, o, r, !0); s && (r.state = s), o.styles = l.styles; const c = o.styleClasses; const u = l.classes; u ? o.styleClasses = u : c && (o.styleClasses = null); for (var f = !a || a.length != o.styles.length || c != u && (!c || !u || c.bgClass != u.bgClass || c.textClass != u.textClass), d = 0; !f && d < a.length; ++d)f = a[d] != o.styles[d]; f && i.push(r.line), o.stateAfter = r.save(), r.nextLine(); } else o.text.length <= e.options.maxHighlightLength && yt(e, o.text, r), o.stateAfter = r.line % 5 == 0 ? r.save() : null, r.nextLine(); if (+new Date() > n) return Di(e, e.options.workDelay), !0; })), t.highlightFrontier = r.line, t.modeFrontier = Math.max(t.modeFrontier, r.line), i.length && Mi(e, (() => { for (let t = 0; t < i.length; t++)zr(e, i[t], 'text'); })); } } var Fi = function (e, t, n) { const r = e.display; this.viewport = t, this.visible = ei(r, e.doc, t), this.editorIsHidden = !r.wrapper.offsetWidth, this.wrapperHeight = r.wrapper.clientHeight, this.wrapperWidth = r.wrapper.clientWidth, this.oldDisplayWidth = Kn(e), this.force = n, this.dims = Mr(e), this.events = []; }; function zi(e) { const t = e.display; !t.scrollbarsClipped && t.scroller.offsetWidth && (t.nativeBarWidth = t.scroller.offsetWidth - t.scroller.clientWidth, t.heightForcer.style.height = `${Gn(e)}px`, t.sizer.style.marginBottom = `${-t.nativeBarWidth}px`, t.sizer.style.borderRightWidth = `${Gn(e)}px`, t.scrollbarsClipped = !0); } function Ii(e) { if (e.hasFocus()) return null; const t = E(); if (!t || !A(e.display.lineDiv, t)) return null; const n = { activeElt: t }; if (window.getSelection) { const r = window.getSelection(); r.anchorNode && r.extend && A(e.display.lineDiv, r.anchorNode) && (n.anchorNode = r.anchorNode, n.anchorOffset = r.anchorOffset, n.focusNode = r.focusNode, n.focusOffset = r.focusOffset); } return n; } function Bi(e) { if (e && e.activeElt && e.activeElt != E() && (e.activeElt.focus(), !/^(INPUT|TEXTAREA)$/.test(e.activeElt.nodeName) && e.anchorNode && A(document.body, e.anchorNode) && A(document.body, e.focusNode))) { const t = window.getSelection(); const n = document.createRange(); n.setEnd(e.anchorNode, e.anchorOffset), n.collapse(!1), t.removeAllRanges(), t.addRange(n), t.extend(e.focusNode, e.focusOffset); } } function Hi(e, t) { const n = e.display; const r = e.doc; if (t.editorIsHidden) return Ir(e), !1; if (!t.force && t.visible.from >= n.viewFrom && t.visible.to <= n.viewTo && (n.updateLineNumbers == null || n.updateLineNumbers >= n.viewTo) && n.renderedView == n.view && Rr(e) == 0) return !1; Gi(e) && (Ir(e), t.dims = Mr(e)); const i = r.first + r.size; let o = Math.max(t.visible.from - e.options.viewportMargin, r.first); let a = Math.min(i, t.visible.to + e.options.viewportMargin); n.viewFrom < o && o - n.viewFrom < 20 && (o = Math.max(r.first, n.viewFrom)), n.viewTo > a && n.viewTo - a < 20 && (a = Math.min(i, n.viewTo)), Tt && (o = en(e.doc, o), a = tn(e.doc, a)); const s = o != n.viewFrom || a != n.viewTo || n.lastWrapHeight != t.wrapperHeight || n.lastWrapWidth != t.wrapperWidth; Hr(e, o, a), n.viewOffset = on(Ye(e.doc, n.viewFrom)), e.display.mover.style.top = `${n.viewOffset}px`; const l = Rr(e); if (!s && l == 0 && !t.force && n.renderedView == n.view && (n.updateLineNumbers == null || n.updateLineNumbers >= n.viewTo)) return !1; const c = Ii(e); return l > 4 && (n.lineDiv.style.display = 'none'), qi(e, n.updateLineNumbers, t.dims), l > 4 && (n.lineDiv.style.display = ''), n.renderedView = n.view, Bi(c), j(n.cursorDiv), j(n.selectionDiv), n.gutters.style.height = n.sizer.style.minHeight = 0, s && (n.lastWrapHeight = t.wrapperHeight, n.lastWrapWidth = t.wrapperWidth, Di(e, 400)), n.updateLineNumbers = null, !0; } function Ri(e, t) { for (let n = t.viewport, r = !0; ;r = !1) { if (r && e.options.lineWrapping && t.oldDisplayWidth != Kn(e))r && (t.visible = ei(e.display, e.doc, n)); else if (n && n.top != null && (n = { top: Math.min(e.doc.height + Vn(e.display) - Xn(e), n.top) }), t.visible = ei(e.display, e.doc, n), t.visible.from >= e.display.viewFrom && t.visible.to <= e.display.viewTo) break; if (!Hi(e, t)) break; Jr(e); const i = pi(e); Wr(e), vi(e, i), Vi(e, i), t.force = !1; }t.signal(e, 'update', e), e.display.viewFrom == e.display.reportedViewFrom && e.display.viewTo == e.display.reportedViewTo || (t.signal(e, 'viewportChange', e, e.display.viewFrom, e.display.viewTo), e.display.reportedViewFrom = e.display.viewFrom, e.display.reportedViewTo = e.display.viewTo); } function Wi(e, t) { const n = new Fi(e, t); if (Hi(e, n)) { Jr(e), Ri(e, n); const r = pi(e); Wr(e), vi(e, r), Vi(e, r), n.finish(); } } function qi(e, t, n) { const r = e.display; const i = e.options.lineNumbers; const o = r.lineDiv; let a = o.firstChild; function s(t) { const n = t.nextSibling; return l && b && e.display.currentWheelTarget == t ? t.style.display = 'none' : t.parentNode.removeChild(t), n; } for (let c = r.view, u = r.viewFrom, f = 0; f < c.length; f++) { const d = c[f]; if (d.hidden);else if (d.node && d.node.parentNode == o) { while (a != d.node)a = s(a); let h = i && t != null && t <= u && d.lineNumber; d.changes && (H(d.changes, 'gutter') > -1 && (h = !1), Mn(e, d, u, n)), h && (j(d.lineNumber), d.lineNumber.appendChild(document.createTextNode(rt(e.options, u)))), a = d.node.nextSibling; } else { const p = In(e, d, u, n); o.insertBefore(p, a); }u += d.size; } while (a)a = s(a); } function $i(e) { const t = e.gutters.offsetWidth; e.sizer.style.marginLeft = `${t}px`, Ln(e, 'gutterChanged', e); } function Vi(e, t) { e.display.sizer.style.minHeight = `${t.docHeight}px`, e.display.heightForcer.style.top = `${t.docHeight}px`, e.display.gutters.style.height = `${t.docHeight + e.display.barHeight + Gn(e)}px`; } function Ui(e) { const t = e.display; const n = t.view; if (t.alignWidgets || t.gutters.firstChild && e.options.fixedGutter) { for (var r = Ar(t) - t.scroller.scrollLeft + e.doc.scrollLeft, i = t.gutters.offsetWidth, o = `${r}px`, a = 0; a < n.length; a++) if (!n[a].hidden) { e.options.fixedGutter && (n[a].gutter && (n[a].gutter.style.left = o), n[a].gutterBackground && (n[a].gutterBackground.style.left = o)); const s = n[a].alignable; if (s) for (let l = 0; l < s.length; l++)s[l].style.left = o; }e.options.fixedGutter && (t.gutters.style.left = `${r + i}px`); } } function Gi(e) { if (!e.options.lineNumbers) return !1; const t = e.doc; const n = rt(e.options, t.first + t.size - 1); const r = e.display; if (n.length != r.lineNumChars) { const i = r.measure.appendChild(T('div', [T('div', n)], 'CodeMirror-linenumber CodeMirror-gutter-elt')); const o = i.firstChild.offsetWidth; const a = i.offsetWidth - o; return r.lineGutter.style.width = '', r.lineNumInnerWidth = Math.max(o, r.lineGutter.offsetWidth - a) + 1, r.lineNumWidth = r.lineNumInnerWidth + a, r.lineNumChars = r.lineNumInnerWidth ? n.length : -1, r.lineGutter.style.width = `${r.lineNumWidth}px`, $i(e.display), !0; } return !1; } function Ki(e, t) { for (var n = [], r = !1, i = 0; i < e.length; i++) { let o = e[i]; let a = null; if (typeof o !== 'string' && (a = o.style, o = o.className), o == 'CodeMirror-linenumbers') { if (!t) continue; r = !0; }n.push({ className: o, style: a }); } return t && !r && n.push({ className: 'CodeMirror-linenumbers', style: null }), n; } function Xi(e) { const t = e.gutters; const n = e.gutterSpecs; j(t), e.lineGutter = null; for (let r = 0; r < n.length; ++r) { const i = n[r]; const o = i.className; const a = i.style; const s = t.appendChild(T('div', null, `CodeMirror-gutter ${o}`)); a && (s.style.cssText = a), o == 'CodeMirror-linenumbers' && (e.lineGutter = s, s.style.width = `${e.lineNumWidth || 1}px`); }t.style.display = n.length ? '' : 'none', $i(e); } function Yi(e) { Xi(e.display), Fr(e), Ui(e); } function Zi(e, t, r, i) { const o = this; this.input = r, o.scrollbarFiller = T('div', null, 'CodeMirror-scrollbar-filler'), o.scrollbarFiller.setAttribute('cm-not-content', 'true'), o.gutterFiller = T('div', null, 'CodeMirror-gutter-filler'), o.gutterFiller.setAttribute('cm-not-content', 'true'), o.lineDiv = M('div', null, 'CodeMirror-code'), o.selectionDiv = T('div', null, null, 'position: relative; z-index: 1'), o.cursorDiv = T('div', null, 'CodeMirror-cursors'), o.measure = T('div', null, 'CodeMirror-measure'), o.lineMeasure = T('div', null, 'CodeMirror-measure'), o.lineSpace = M('div', [o.measure, o.lineMeasure, o.selectionDiv, o.cursorDiv, o.lineDiv], null, 'position: relative; outline: none'); const c = M('div', [o.lineSpace], 'CodeMirror-lines'); o.mover = T('div', [c], null, 'position: relative'), o.sizer = T('div', [o.mover], 'CodeMirror-sizer'), o.sizerWidth = null, o.heightForcer = T('div', null, null, `position: absolute; height: ${R}px; width: 1px;`), o.gutters = T('div', null, 'CodeMirror-gutters'), o.lineGutter = null, o.scroller = T('div', [o.sizer, o.heightForcer, o.gutters], 'CodeMirror-scroll'), o.scroller.setAttribute('tabIndex', '-1'), o.wrapper = T('div', [o.scrollbarFiller, o.gutterFiller, o.scroller], 'CodeMirror'), a && s < 8 && (o.gutters.style.zIndex = -1, o.scroller.style.paddingRight = 0), l || n && v || (o.scroller.draggable = !0), e && (e.appendChild ? e.appendChild(o.wrapper) : e(o.wrapper)), o.viewFrom = o.viewTo = t.first, o.reportedViewFrom = o.reportedViewTo = t.first, o.view = [], o.renderedView = null, o.externalMeasured = null, o.viewOffset = 0, o.lastWrapHeight = o.lastWrapWidth = 0, o.updateLineNumbers = null, o.nativeBarWidth = o.barHeight = o.barWidth = 0, o.scrollbarsClipped = !1, o.lineNumWidth = o.lineNumInnerWidth = o.lineNumChars = null, o.alignWidgets = !1, o.cachedCharWidth = o.cachedTextHeight = o.cachedPaddingH = null, o.maxLine = null, o.maxLineLength = 0, o.maxLineChanged = !1, o.wheelDX = o.wheelDY = o.wheelStartX = o.wheelStartY = null, o.shift = !1, o.selForContextMenu = null, o.activeTouch = null, o.gutterSpecs = Ki(i.gutters, i.lineNumbers), Xi(o), r.init(o); }Fi.prototype.signal = function (e, t) { we(e, t) && this.events.push(arguments); }, Fi.prototype.finish = function () { for (let e = 0; e < this.events.length; e++)ve.apply(null, this.events[e]); }; let Ji = 0; let Qi = null; function eo(e) { let t = e.wheelDeltaX; let n = e.wheelDeltaY; return t == null && e.detail && e.axis == e.HORIZONTAL_AXIS && (t = e.detail), n == null && e.detail && e.axis == e.VERTICAL_AXIS ? n = e.detail : n == null && (n = e.wheelDelta), { x: t, y: n }; } function to(e) { const t = eo(e); return t.x *= Qi, t.y *= Qi, t; } function no(e, t) { const r = eo(t); const i = r.x; const o = r.y; const a = e.display; const s = a.scroller; const c = s.scrollWidth > s.clientWidth; const u = s.scrollHeight > s.clientHeight; if (i && c || o && u) { if (o && b && l)e:for (let d = t.target, h = a.view; d != s; d = d.parentNode) for (let p = 0; p < h.length; p++) if (h[p].node == d) { e.display.currentWheelTarget = d; break e; } if (i && !n && !f && Qi != null) return o && u && fi(e, Math.max(0, s.scrollTop + o * Qi)), hi(e, Math.max(0, s.scrollLeft + i * Qi)), (!o || o && u) && ke(t), void (a.wheelStartX = null); if (o && Qi != null) { const m = o * Qi; let g = e.doc.scrollTop; let v = g + a.wrapper.clientHeight; m < 0 ? g = Math.max(0, g + m - 50) : v = Math.min(e.doc.height, v + m + 50), Wi(e, { top: g, bottom: v }); }Ji < 20 && (a.wheelStartX == null ? (a.wheelStartX = s.scrollLeft, a.wheelStartY = s.scrollTop, a.wheelDX = i, a.wheelDY = o, setTimeout((() => { if (a.wheelStartX != null) { const e = s.scrollLeft - a.wheelStartX; const t = s.scrollTop - a.wheelStartY; const n = t && a.wheelDY && t / a.wheelDY || e && a.wheelDX && e / a.wheelDX; a.wheelStartX = a.wheelStartY = null, n && (Qi = (Qi * Ji + n) / (Ji + 1), ++Ji); } }), 200)) : (a.wheelDX += i, a.wheelDY += o)); } }a ? Qi = -0.53 : n ? Qi = 15 : u ? Qi = -0.7 : d && (Qi = -1 / 3); const ro = function (e, t) { this.ranges = e, this.primIndex = t; }; ro.prototype.primary = function () { return this.ranges[this.primIndex]; }, ro.prototype.equals = function (e) { if (e == this) return !0; if (e.primIndex != this.primIndex || e.ranges.length != this.ranges.length) return !1; for (let t = 0; t < this.ranges.length; t++) { const n = this.ranges[t]; const r = e.ranges[t]; if (!at(n.anchor, r.anchor) || !at(n.head, r.head)) return !1; } return !0; }, ro.prototype.deepCopy = function () { for (var e = [], t = 0; t < this.ranges.length; t++)e[t] = new io(st(this.ranges[t].anchor), st(this.ranges[t].head)); return new ro(e, this.primIndex); }, ro.prototype.somethingSelected = function () { for (let e = 0; e < this.ranges.length; e++) if (!this.ranges[e].empty()) return !0; return !1; }, ro.prototype.contains = function (e, t) { t || (t = e); for (let n = 0; n < this.ranges.length; n++) { const r = this.ranges[n]; if (ot(t, r.from()) >= 0 && ot(e, r.to()) <= 0) return n; } return -1; }; var io = function (e, t) { this.anchor = e, this.head = t; }; function oo(e, t, n) { const r = e && e.options.selectionsMayTouch; const i = t[n]; t.sort(((e, t) => ot(e.from(), t.from()))), n = H(t, i); for (let o = 1; o < t.length; o++) { const a = t[o]; const s = t[o - 1]; const l = ot(s.to(), a.from()); if (r && !a.empty() ? l > 0 : l >= 0) { const c = ct(s.from(), a.from()); const u = lt(s.to(), a.to()); const f = s.empty() ? a.from() == a.head : s.from() == s.head; o <= n && --n, t.splice(--o, 2, new io(f ? u : c, f ? c : u)); } } return new ro(t, n); } function ao(e, t) { return new ro([new io(e, t || e)], 0); } function so(e) { return e.text ? it(e.from.line + e.text.length - 1, X(e.text).length + (e.text.length == 1 ? e.from.ch : 0)) : e.to; } function lo(e, t) { if (ot(e, t.from) < 0) return e; if (ot(e, t.to) <= 0) return so(t); const n = e.line + t.text.length - (t.to.line - t.from.line) - 1; let r = e.ch; return e.line == t.to.line && (r += so(t).ch - t.to.ch), it(n, r); } function co(e, t) { for (var n = [], r = 0; r < e.sel.ranges.length; r++) { const i = e.sel.ranges[r]; n.push(new io(lo(i.anchor, t), lo(i.head, t))); } return oo(e.cm, n, e.sel.primIndex); } function uo(e, t, n) { return e.line == t.line ? it(n.line, e.ch - t.ch + n.ch) : it(n.line + (e.line - t.line), e.ch); } function fo(e, t, n) { for (var r = [], i = it(e.first, 0), o = i, a = 0; a < t.length; a++) { const s = t[a]; const l = uo(s.from, i, o); const c = uo(so(s), i, o); if (i = s.to, o = c, n == 'around') { const u = e.sel.ranges[a]; const f = ot(u.head, u.anchor) < 0; r[a] = new io(f ? c : l, f ? l : c); } else r[a] = new io(l, l); } return new ro(r, e.sel.primIndex); } function ho(e) { e.doc.mode = qe(e.options, e.doc.modeOption), po(e); } function po(e) { e.doc.iter(((e) => { e.stateAfter && (e.stateAfter = null), e.styles && (e.styles = null); })), e.doc.modeFrontier = e.doc.highlightFrontier = e.doc.first, Di(e, 100), e.state.modeGen++, e.curOp && Fr(e); } function mo(e, t) { return t.from.ch == 0 && t.to.ch == 0 && X(t.text) == '' && (!e.cm || e.cm.options.wholeLineUpdateBefore); } function go(e, t, n, r) { function i(e) { return n ? n[e] : null; } function o(e, n, i) { cn(e, n, i, r), Ln(e, 'change', e, t); } function a(e, t) { for (var n = [], o = e; o < t; ++o)n.push(new ln(c[o], i(o), r)); return n; } const s = t.from; const l = t.to; var c = t.text; const u = Ye(e, s.line); const f = Ye(e, l.line); const d = X(c); const h = i(c.length - 1); const p = l.line - s.line; if (t.full)e.insert(0, a(0, c.length)), e.remove(c.length, e.size - c.length); else if (mo(e, t)) { const m = a(0, c.length - 1); o(f, f.text, h), p && e.remove(s.line, p), m.length && e.insert(s.line, m); } else if (u == f) if (c.length == 1)o(u, u.text.slice(0, s.ch) + d + u.text.slice(l.ch), h); else { const g = a(1, c.length - 1); g.push(new ln(d + u.text.slice(l.ch), h, r)), o(u, u.text.slice(0, s.ch) + c[0], i(0)), e.insert(s.line + 1, g); } else if (c.length == 1)o(u, u.text.slice(0, s.ch) + c[0] + f.text.slice(l.ch), i(0)), e.remove(s.line + 1, p); else { o(u, u.text.slice(0, s.ch) + c[0], i(0)), o(f, d + f.text.slice(l.ch), h); const v = a(1, c.length - 1); p > 1 && e.remove(s.line + 1, p - 1), e.insert(s.line + 1, v); }Ln(e, 'change', e, t); } function vo(e, t, n) { function r(e, i, o) { if (e.linked) for (let a = 0; a < e.linked.length; ++a) { const s = e.linked[a]; if (s.doc != i) { const l = o && s.sharedHist; n && !l || (t(s.doc, l), r(s.doc, e, l)); } } }r(e, null, !0); } function bo(e, t) { if (t.cm) throw new Error('This document is already in use.'); e.doc = t, t.cm = e, Pr(e), ho(e), yo(e), e.options.direction = t.direction, e.options.lineWrapping || sn(e), e.options.mode = t.modeOption, Fr(e); } function yo(e) { (e.doc.direction == 'rtl' ? P : O)(e.display.lineDiv, 'CodeMirror-rtl'); } function wo(e) { Mi(e, (() => { yo(e), Fr(e); })); } function xo(e) { this.done = [], this.undone = [], this.undoDepth = e ? e.undoDepth : 1 / 0, this.lastModTime = this.lastSelTime = 0, this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null, this.generation = this.maxGeneration = e ? e.maxGeneration : 1; } function ko(e, t) { const n = { from: st(t.from), to: so(t), text: Ze(e, t.from, t.to) }; return To(e, n, t.from.line, t.to.line + 1), vo(e, ((e) => To(e, n, t.from.line, t.to.line + 1)), !0), n; } function _o(e) { while (e.length) { const t = X(e); if (!t.ranges) break; e.pop(); } } function Co(e, t) { return t ? (_o(e.done), X(e.done)) : e.done.length && !X(e.done).ranges ? X(e.done) : e.done.length > 1 && !e.done[e.done.length - 2].ranges ? (e.done.pop(), X(e.done)) : void 0; } function So(e, t, n, r) { const i = e.history; i.undone.length = 0; let o; let a; const s = +new Date(); if ((i.lastOp == r || i.lastOrigin == t.origin && t.origin && (t.origin.charAt(0) == '+' && i.lastModTime > s - (e.cm ? e.cm.options.historyEventDelay : 500) || t.origin.charAt(0) == '*')) && (o = Co(i, i.lastOp == r)))a = X(o.changes), ot(t.from, t.to) == 0 && ot(t.from, a.to) == 0 ? a.to = so(t) : o.changes.push(ko(e, t)); else { const l = X(i.done); l && l.ranges || Lo(e.sel, i.done), o = { changes: [ko(e, t)], generation: i.generation }, i.done.push(o); while (i.done.length > i.undoDepth)i.done.shift(), i.done[0].ranges || i.done.shift(); }i.done.push(n), i.generation = ++i.maxGeneration, i.lastModTime = i.lastSelTime = s, i.lastOp = i.lastSelOp = r, i.lastOrigin = i.lastSelOrigin = t.origin, a || ve(e, 'historyAdded'); } function Oo(e, t, n, r) { const i = t.charAt(0); return i == '*' || i == '+' && n.ranges.length == r.ranges.length && n.somethingSelected() == r.somethingSelected() && new Date() - e.history.lastSelTime <= (e.cm ? e.cm.options.historyEventDelay : 500); } function jo(e, t, n, r) { const i = e.history; const o = r && r.origin; n == i.lastSelOp || o && i.lastSelOrigin == o && (i.lastModTime == i.lastSelTime && i.lastOrigin == o || Oo(e, o, X(i.done), t)) ? i.done[i.done.length - 1] = t : Lo(t, i.done), i.lastSelTime = +new Date(), i.lastSelOrigin = o, i.lastSelOp = n, r && !1 !== r.clearRedo && _o(i.undone); } function Lo(e, t) { const n = X(t); n && n.ranges && n.equals(e) || t.push(e); } function To(e, t, n, r) { let i = t[`spans_${e.id}`]; let o = 0; e.iter(Math.max(e.first, n), Math.min(e.first + e.size, r), ((n) => { n.markedSpans && ((i || (i = t[`spans_${e.id}`] = {}))[o] = n.markedSpans), ++o; })); } function Mo(e) { if (!e) return null; for (var t, n = 0; n < e.length; ++n)e[n].marker.explicitlyCleared ? t || (t = e.slice(0, n)) : t && t.push(e[n]); return t ? t.length ? t : null : e; } function Ao(e, t) { const n = t[`spans_${e.id}`]; if (!n) return null; for (var r = [], i = 0; i < t.text.length; ++i)r.push(Mo(n[i])); return r; } function Eo(e, t) { const n = Ao(e, t); const r = It(e, t); if (!n) return r; if (!r) return n; for (let i = 0; i < n.length; ++i) { const o = n[i]; const a = r[i]; if (o && a)e:for (let s = 0; s < a.length; ++s) { for (var l = a[s], c = 0; c < o.length; ++c) if (o[c].marker == l.marker) continue e; o.push(l); } else a && (n[i] = a); } return n; } function Po(e, t, n) { for (var r = [], i = 0; i < e.length; ++i) { const o = e[i]; if (o.ranges)r.push(n ? ro.prototype.deepCopy.call(o) : o); else { const a = o.changes; const s = []; r.push({ changes: s }); for (let l = 0; l < a.length; ++l) { const c = a[l]; let u = void 0; if (s.push({ from: c.from, to: c.to, text: c.text }), t) for (const f in c)(u = f.match(/^spans_(\d+)$/)) && H(t, Number(u[1])) > -1 && (X(s)[f] = c[f], delete c[f]); } } } return r; } function Do(e, t, n, r) { if (r) { let i = e.anchor; if (n) { const o = ot(t, i) < 0; o != ot(n, i) < 0 ? (i = t, t = n) : o != ot(t, n) < 0 && (t = n); } return new io(i, t); } return new io(n || t, t); } function No(e, t, n, r, i) { i == null && (i = e.cm && (e.cm.display.shift || e.extend)), Ro(e, new ro([Do(e.sel.primary(), t, n, i)], 0), r); } function Fo(e, t, n) { for (var r = [], i = e.cm && (e.cm.display.shift || e.extend), o = 0; o < e.sel.ranges.length; o++)r[o] = Do(e.sel.ranges[o], t[o], null, i); const a = oo(e.cm, r, e.sel.primIndex); Ro(e, a, n); } function zo(e, t, n, r) { const i = e.sel.ranges.slice(0); i[t] = n, Ro(e, oo(e.cm, i, e.sel.primIndex), r); } function Io(e, t, n, r) { Ro(e, ao(t, n), r); } function Bo(e, t, n) { const r = { ranges: t.ranges, update(t) { this.ranges = []; for (let n = 0; n < t.length; n++) this.ranges[n] = new io(ft(e, t[n].anchor), ft(e, t[n].head)); }, origin: n && n.origin }; return ve(e, 'beforeSelectionChange', e, r), e.cm && ve(e.cm, 'beforeSelectionChange', e.cm, r), r.ranges != t.ranges ? oo(e.cm, r.ranges, r.ranges.length - 1) : t; } function Ho(e, t, n) { const r = e.history.done; const i = X(r); i && i.ranges ? (r[r.length - 1] = t, Wo(e, t, n)) : Ro(e, t, n); } function Ro(e, t, n) { Wo(e, t, n), jo(e, e.sel, e.cm ? e.cm.curOp.id : NaN, n); } function Wo(e, t, n) { (we(e, 'beforeSelectionChange') || e.cm && we(e.cm, 'beforeSelectionChange')) && (t = Bo(e, t, n)); const r = n && n.bias || (ot(t.primary().head, e.sel.primary().head) < 0 ? -1 : 1); qo(e, Vo(e, t, r, !0)), n && !1 === n.scroll || !e.cm || e.cm.getOption('readOnly') == 'nocursor' || ai(e.cm); } function qo(e, t) { t.equals(e.sel) || (e.sel = t, e.cm && (e.cm.curOp.updateInput = 1, e.cm.curOp.selectionChanged = !0, ye(e.cm)), Ln(e, 'cursorActivity', e)); } function $o(e) { qo(e, Vo(e, e.sel, null, !1)); } function Vo(e, t, n, r) { for (var i, o = 0; o < t.ranges.length; o++) { const a = t.ranges[o]; const s = t.ranges.length == e.sel.ranges.length && e.sel.ranges[o]; const l = Go(e, a.anchor, s && s.anchor, n, r); const c = Go(e, a.head, s && s.head, n, r); (i || l != a.anchor || c != a.head) && (i || (i = t.ranges.slice(0, o)), i[o] = new io(l, c)); } return i ? oo(e.cm, i, t.primIndex) : t; } function Uo(e, t, n, r, i) { const o = Ye(e, t.line); if (o.markedSpans) for (let a = 0; a < o.markedSpans.length; ++a) { const s = o.markedSpans[a]; const l = s.marker; const c = 'selectLeft' in l ? !l.selectLeft : l.inclusiveLeft; const u = 'selectRight' in l ? !l.selectRight : l.inclusiveRight; if ((s.from == null || (c ? s.from <= t.ch : s.from < t.ch)) && (s.to == null || (u ? s.to >= t.ch : s.to > t.ch))) { if (i && (ve(l, 'beforeCursorEnter'), l.explicitlyCleared)) { if (o.markedSpans) { --a; continue; } break; } if (!l.atomic) continue; if (n) { let f = l.find(r < 0 ? 1 : -1); let d = void 0; if ((r < 0 ? u : c) && (f = Ko(e, f, -r, f && f.line == t.line ? o : null)), f && f.line == t.line && (d = ot(f, n)) && (r < 0 ? d < 0 : d > 0)) return Uo(e, f, t, r, i); } let h = l.find(r < 0 ? -1 : 1); return (r < 0 ? c : u) && (h = Ko(e, h, r, h.line == t.line ? o : null)), h ? Uo(e, h, t, r, i) : null; } } return t; } function Go(e, t, n, r, i) { const o = r || 1; const a = Uo(e, t, n, o, i) || !i && Uo(e, t, n, o, !0) || Uo(e, t, n, -o, i) || !i && Uo(e, t, n, -o, !0); return a || (e.cantEdit = !0, it(e.first, 0)); } function Ko(e, t, n, r) { return n < 0 && t.ch == 0 ? t.line > e.first ? ft(e, it(t.line - 1)) : null : n > 0 && t.ch == (r || Ye(e, t.line)).text.length ? t.line < e.first + e.size - 1 ? it(t.line + 1, 0) : null : new it(t.line, t.ch + n); } function Xo(e) { e.setSelection(it(e.firstLine(), 0), it(e.lastLine()), q); } function Yo(e, t, n) {
        var r = {
          canceled: !1, from: t.from, to: t.to, text: t.text, origin: t.origin, cancel() { return r.canceled = !0; },
        }; return n && (r.update = function (t, n, i, o) { t && (r.from = ft(e, t)), n && (r.to = ft(e, n)), i && (r.text = i), void 0 !== o && (r.origin = o); }), ve(e, 'beforeChange', e, r), e.cm && ve(e.cm, 'beforeChange', e.cm, r), r.canceled ? (e.cm && (e.cm.curOp.updateInput = 2), null) : {
          from: r.from, to: r.to, text: r.text, origin: r.origin,
        };
      } function Zo(e, t, n) {
        if (e.cm) { if (!e.cm.curOp) return Ai(e.cm, Zo)(e, t, n); if (e.cm.state.suppressEdits) return; } if (!(we(e, 'beforeChange') || e.cm && we(e.cm, 'beforeChange')) || (t = Yo(e, t, !0), t)) {
          const r = Lt && !n && Ht(e, t.from, t.to); if (r) {
            for (let i = r.length - 1; i >= 0; --i) {
              Jo(e, {
                from: r[i].from, to: r[i].to, text: i ? [''] : t.text, origin: t.origin,
              });
            }
          } else Jo(e, t);
        }
      } function Jo(e, t) { if (t.text.length != 1 || t.text[0] != '' || ot(t.from, t.to) != 0) { const n = co(e, t); So(e, t, n, e.cm ? e.cm.curOp.id : NaN), ta(e, t, n, It(e, t)); const r = []; vo(e, ((e, n) => { n || H(r, e.history) != -1 || (aa(e.history, t), r.push(e.history)), ta(e, t, null, It(e, t)); })); } } function Qo(e, t, n) { const r = e.cm && e.cm.state.suppressEdits; if (!r || n) { for (var i, o = e.history, a = e.sel, s = t == 'undo' ? o.done : o.undone, l = t == 'undo' ? o.undone : o.done, c = 0; c < s.length; c++) if (i = s[c], n ? i.ranges && !i.equals(e.sel) : !i.ranges) break; if (c != s.length) { for (o.lastOrigin = o.lastSelOrigin = null; ;) { if (i = s.pop(), !i.ranges) { if (r) return void s.push(i); break; } if (Lo(i, l), n && !i.equals(e.sel)) return void Ro(e, i, { clearRedo: !1 }); a = i; } const u = []; Lo(a, l), l.push({ changes: u, generation: o.generation }), o.generation = i.generation || ++o.maxGeneration; for (var f = we(e, 'beforeChange') || e.cm && we(e.cm, 'beforeChange'), d = function (n) { const r = i.changes[n]; if (r.origin = t, f && !Yo(e, r, !1)) return s.length = 0, {}; u.push(ko(e, r)); const o = n ? co(e, r) : X(s); ta(e, r, o, Eo(e, r)), !n && e.cm && e.cm.scrollIntoView({ from: r.from, to: so(r) }); const a = []; vo(e, ((e, t) => { t || H(a, e.history) != -1 || (aa(e.history, r), a.push(e.history)), ta(e, r, null, Eo(e, r)); })); }, h = i.changes.length - 1; h >= 0; --h) { const p = d(h); if (p) return p.v; } } } } function ea(e, t) { if (t != 0 && (e.first += t, e.sel = new ro(Y(e.sel.ranges, ((e) => new io(it(e.anchor.line + t, e.anchor.ch), it(e.head.line + t, e.head.ch)))), e.sel.primIndex), e.cm)) { Fr(e.cm, e.first, e.first - t, t); for (let n = e.cm.display, r = n.viewFrom; r < n.viewTo; r++)zr(e.cm, r, 'gutter'); } } function ta(e, t, n, r) {
        if (e.cm && !e.cm.curOp) return Ai(e.cm, ta)(e, t, n, r); if (t.to.line < e.first)ea(e, t.text.length - 1 - (t.to.line - t.from.line)); else if (!(t.from.line > e.lastLine())) {
          if (t.from.line < e.first) {
            const i = t.text.length - 1 - (e.first - t.from.line); ea(e, i), t = {
              from: it(e.first, 0), to: it(t.to.line + i, t.to.ch), text: [X(t.text)], origin: t.origin,
            };
          } const o = e.lastLine(); t.to.line > o && (t = {
            from: t.from, to: it(o, Ye(e, o).text.length), text: [t.text[0]], origin: t.origin,
          }), t.removed = Ze(e, t.from, t.to), n || (n = co(e, t)), e.cm ? na(e.cm, t, r) : go(e, t, r), Wo(e, n, q), e.cantEdit && Go(e, it(e.firstLine(), 0)) && (e.cantEdit = !1);
        }
      } function na(e, t, n) {
        const r = e.doc; const i = e.display; const o = t.from; const a = t.to; let s = !1; let l = o.line; e.options.lineWrapping || (l = et(Zt(Ye(r, o.line))), r.iter(l, a.line + 1, ((e) => { if (e == i.maxLine) return s = !0, !0; }))), r.sel.contains(t.from, t.to) > -1 && ye(e), go(r, t, n, Er(e)), e.options.lineWrapping || (r.iter(l, o.line + t.text.length, ((e) => { const t = an(e); t > i.maxLineLength && (i.maxLine = e, i.maxLineLength = t, i.maxLineChanged = !0, s = !1); })), s && (e.curOp.updateMaxLine = !0)), jt(r, o.line), Di(e, 400); const c = t.text.length - (a.line - o.line) - 1; t.full ? Fr(e) : o.line != a.line || t.text.length != 1 || mo(e.doc, t) ? Fr(e, o.line, a.line + 1, c) : zr(e, o.line, 'text'); const u = we(e, 'changes'); const f = we(e, 'change'); if (f || u) {
          const d = {
            from: o, to: a, text: t.text, removed: t.removed, origin: t.origin,
          }; f && Ln(e, 'change', e, d), u && (e.curOp.changeObjs || (e.curOp.changeObjs = [])).push(d);
        }e.display.selForContextMenu = null;
      } function ra(e, t, n, r, i) {
        let o; r || (r = n), ot(r, n) < 0 && (o = [r, n], n = o[0], r = o[1]), typeof t === 'string' && (t = e.splitLines(t)), Zo(e, {
          from: n, to: r, text: t, origin: i,
        });
      } function ia(e, t, n, r) { n < e.line ? e.line += r : t < e.line && (e.line = t, e.ch = 0); } function oa(e, t, n, r) { for (let i = 0; i < e.length; ++i) { let o = e[i]; let a = !0; if (o.ranges) { o.copied || (o = e[i] = o.deepCopy(), o.copied = !0); for (let s = 0; s < o.ranges.length; s++)ia(o.ranges[s].anchor, t, n, r), ia(o.ranges[s].head, t, n, r); } else { for (let l = 0; l < o.changes.length; ++l) { const c = o.changes[l]; if (n < c.from.line)c.from = it(c.from.line + r, c.from.ch), c.to = it(c.to.line + r, c.to.ch); else if (t <= c.to.line) { a = !1; break; } }a || (e.splice(0, i + 1), i = 0); } } } function aa(e, t) { const n = t.from.line; const r = t.to.line; const i = t.text.length - (r - n) - 1; oa(e.done, n, r, i), oa(e.undone, n, r, i); } function sa(e, t, n, r) { let i = t; let o = t; return typeof t === 'number' ? o = Ye(e, ut(e, t)) : i = et(t), i == null ? null : (r(o, i) && e.cm && zr(e.cm, i, n), o); } function la(e) { this.lines = e, this.parent = null; for (var t = 0, n = 0; n < e.length; ++n)e[n].parent = this, t += e[n].height; this.height = t; } function ca(e) { this.children = e; for (var t = 0, n = 0, r = 0; r < e.length; ++r) { const i = e[r]; t += i.chunkSize(), n += i.height, i.parent = this; } this.size = t, this.height = n, this.parent = null; }io.prototype.from = function () { return ct(this.anchor, this.head); }, io.prototype.to = function () { return lt(this.anchor, this.head); }, io.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch; }, la.prototype = {
        chunkSize() { return this.lines.length; }, removeInner(e, t) { for (let n = e, r = e + t; n < r; ++n) { const i = this.lines[n]; this.height -= i.height, un(i), Ln(i, 'delete'); } this.lines.splice(e, t); }, collapse(e) { e.push.apply(e, this.lines); }, insertInner(e, t, n) { this.height += n, this.lines = this.lines.slice(0, e).concat(t).concat(this.lines.slice(e)); for (let r = 0; r < t.length; ++r)t[r].parent = this; }, iterN(e, t, n) { for (let r = e + t; e < r; ++e) if (n(this.lines[e])) return !0; },
      }, ca.prototype = {
        chunkSize() { return this.size; }, removeInner(e, t) { this.size -= t; for (let n = 0; n < this.children.length; ++n) { const r = this.children[n]; const i = r.chunkSize(); if (e < i) { const o = Math.min(t, i - e); const a = r.height; if (r.removeInner(e, o), this.height -= a - r.height, i == o && (this.children.splice(n--, 1), r.parent = null), (t -= o) == 0) break; e = 0; } else e -= i; } if (this.size - t < 25 && (this.children.length > 1 || !(this.children[0] instanceof la))) { const s = []; this.collapse(s), this.children = [new la(s)], this.children[0].parent = this; } }, collapse(e) { for (let t = 0; t < this.children.length; ++t) this.children[t].collapse(e); }, insertInner(e, t, n) { this.size += t.length, this.height += n; for (let r = 0; r < this.children.length; ++r) { const i = this.children[r]; const o = i.chunkSize(); if (e <= o) { if (i.insertInner(e, t, n), i.lines && i.lines.length > 50) { for (var a = i.lines.length % 25 + 25, s = a; s < i.lines.length;) { const l = new la(i.lines.slice(s, s += 25)); i.height -= l.height, this.children.splice(++r, 0, l), l.parent = this; }i.lines = i.lines.slice(0, a), this.maybeSpill(); } break; }e -= o; } }, maybeSpill() { if (!(this.children.length <= 10)) { let e = this; do { const t = e.children.splice(e.children.length - 5, 5); const n = new ca(t); if (e.parent) { e.size -= n.size, e.height -= n.height; const r = H(e.parent.children, e); e.parent.children.splice(r + 1, 0, n); } else { const i = new ca(e.children); i.parent = e, e.children = [i, n], e = i; }n.parent = e.parent; } while (e.children.length > 10);e.parent.maybeSpill(); } }, iterN(e, t, n) { for (let r = 0; r < this.children.length; ++r) { const i = this.children[r]; const o = i.chunkSize(); if (e < o) { const a = Math.min(t, o - e); if (i.iterN(e, a, n)) return !0; if ((t -= a) == 0) break; e = 0; } else e -= o; } },
      }; const ua = function (e, t, n) { if (n) for (const r in n)n.hasOwnProperty(r) && (this[r] = n[r]); this.doc = e, this.node = t; }; function fa(e, t, n) { on(t) < (e.curOp && e.curOp.scrollTop || e.doc.scrollTop) && oi(e, n); } function da(e, t, n, r) { const i = new ua(e, n, r); const o = e.cm; return o && i.noHScroll && (o.display.alignWidgets = !0), sa(e, t, 'widget', ((t) => { const n = t.widgets || (t.widgets = []); if (i.insertAt == null ? n.push(i) : n.splice(Math.min(n.length, Math.max(0, i.insertAt)), 0, i), i.line = t, o && !nn(e, t)) { const r = on(t) < e.scrollTop; Qe(t, t.height + Wn(i)), r && oi(o, i.height), o.curOp.forceUpdate = !0; } return !0; })), o && Ln(o, 'lineWidgetAdded', o, i, typeof t === 'number' ? t : et(t)), i; }ua.prototype.clear = function () { const e = this.doc.cm; const t = this.line.widgets; const n = this.line; const r = et(n); if (r != null && t) { for (let i = 0; i < t.length; ++i)t[i] == this && t.splice(i--, 1); t.length || (n.widgets = null); const o = Wn(this); Qe(n, Math.max(0, n.height - o)), e && (Mi(e, (() => { fa(e, n, -o), zr(e, r, 'widget'); })), Ln(e, 'lineWidgetCleared', e, this, r)); } }, ua.prototype.changed = function () { const e = this; const t = this.height; const n = this.doc.cm; const r = this.line; this.height = null; const i = Wn(this) - t; i && (nn(this.doc, r) || Qe(r, r.height + i), n && Mi(n, (() => { n.curOp.forceUpdate = !0, fa(n, r, i), Ln(n, 'lineWidgetChanged', n, e, et(r)); }))); }, xe(ua); let ha = 0; const pa = function (e, t) { this.lines = [], this.type = t, this.doc = e, this.id = ++ha; }; function ma(e, t, n, r, i) { if (r && r.shared) return va(e, t, n, r, i); if (e.cm && !e.cm.curOp) return Ai(e.cm, ma)(e, t, n, r, i); const o = new pa(e, i); const a = ot(t, n); if (r && z(r, o, !1), a > 0 || a == 0 && !1 !== o.clearWhenEmpty) return o; if (o.replacedWith && (o.collapsed = !0, o.widgetNode = M('span', [o.replacedWith], 'CodeMirror-widget'), r.handleMouseEvents || o.widgetNode.setAttribute('cm-ignore-events', 'true'), r.insertLeft && (o.widgetNode.insertLeft = !0)), o.collapsed) { if (Yt(e, t.line, t, n, o) || t.line != n.line && Yt(e, n.line, t, n, o)) throw new Error('Inserting collapsed marker partially overlapping an existing one'); At(); }o.addToHistory && So(e, { from: t, to: n, origin: 'markText' }, e.sel, NaN); let s; let l = t.line; const c = e.cm; if (e.iter(l, n.line + 1, ((r) => { c && o.collapsed && !c.options.lineWrapping && Zt(r) == c.display.maxLine && (s = !0), o.collapsed && l != t.line && Qe(r, 0), Nt(r, new Et(o, l == t.line ? t.ch : null, l == n.line ? n.ch : null), e.cm && e.cm.curOp), ++l; })), o.collapsed && e.iter(t.line, n.line + 1, ((t) => { nn(e, t) && Qe(t, 0); })), o.clearOnEnter && pe(o, 'beforeCursorEnter', (() => o.clear())), o.readOnly && (Mt(), (e.history.done.length || e.history.undone.length) && e.clearHistory()), o.collapsed && (o.id = ++ha, o.atomic = !0), c) { if (s && (c.curOp.updateMaxLine = !0), o.collapsed)Fr(c, t.line, n.line + 1); else if (o.className || o.startStyle || o.endStyle || o.css || o.attributes || o.title) for (let u = t.line; u <= n.line; u++)zr(c, u, 'text'); o.atomic && $o(c.doc), Ln(c, 'markerAdded', c, o); } return o; }pa.prototype.clear = function () { if (!this.explicitlyCleared) { const e = this.doc.cm; const t = e && !e.curOp; if (t && ki(e), we(this, 'clear')) { const n = this.find(); n && Ln(this, 'clear', n.from, n.to); } for (var r = null, i = null, o = 0; o < this.lines.length; ++o) { const a = this.lines[o]; const s = Pt(a.markedSpans, this); e && !this.collapsed ? zr(e, et(a), 'text') : e && (s.to != null && (i = et(a)), s.from != null && (r = et(a))), a.markedSpans = Dt(a.markedSpans, s), s.from == null && this.collapsed && !nn(this.doc, a) && e && Qe(a, Lr(e.display)); } if (e && this.collapsed && !e.options.lineWrapping) for (let l = 0; l < this.lines.length; ++l) { const c = Zt(this.lines[l]); const u = an(c); u > e.display.maxLineLength && (e.display.maxLine = c, e.display.maxLineLength = u, e.display.maxLineChanged = !0); }r != null && e && this.collapsed && Fr(e, r, i + 1), this.lines.length = 0, this.explicitlyCleared = !0, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, e && $o(e.doc)), e && Ln(e, 'markerCleared', e, this, r, i), t && _i(e), this.parent && this.parent.clear(); } }, pa.prototype.find = function (e, t) { let n; let r; e == null && this.type == 'bookmark' && (e = 1); for (let i = 0; i < this.lines.length; ++i) { const o = this.lines[i]; const a = Pt(o.markedSpans, this); if (a.from != null && (n = it(t ? o : et(o), a.from), e == -1)) return n; if (a.to != null && (r = it(t ? o : et(o), a.to), e == 1)) return r; } return n && { from: n, to: r }; }, pa.prototype.changed = function () { const e = this; const t = this.find(-1, !0); const n = this; const r = this.doc.cm; t && r && Mi(r, (() => { const i = t.line; const o = et(t.line); const a = er(r, o); if (a && (cr(a), r.curOp.selectionChanged = r.curOp.forceUpdate = !0), r.curOp.updateMaxLine = !0, !nn(n.doc, i) && n.height != null) { const s = n.height; n.height = null; const l = Wn(n) - s; l && Qe(i, i.height + l); }Ln(r, 'markerChanged', r, e); })); }, pa.prototype.attachLine = function (e) { if (!this.lines.length && this.doc.cm) { const t = this.doc.cm.curOp; t.maybeHiddenMarkers && H(t.maybeHiddenMarkers, this) != -1 || (t.maybeUnhiddenMarkers || (t.maybeUnhiddenMarkers = [])).push(this); } this.lines.push(e); }, pa.prototype.detachLine = function (e) { if (this.lines.splice(H(this.lines, e), 1), !this.lines.length && this.doc.cm) { const t = this.doc.cm.curOp; (t.maybeHiddenMarkers || (t.maybeHiddenMarkers = [])).push(this); } }, xe(pa); const ga = function (e, t) { this.markers = e, this.primary = t; for (let n = 0; n < e.length; ++n)e[n].parent = this; }; function va(e, t, n, r, i) { r = z(r), r.shared = !1; const o = [ma(e, t, n, r, i)]; let a = o[0]; const s = r.widgetNode; return vo(e, ((e) => { s && (r.widgetNode = s.cloneNode(!0)), o.push(ma(e, ft(e, t), ft(e, n), r, i)); for (let l = 0; l < e.linked.length; ++l) if (e.linked[l].isParent) return; a = X(o); })), new ga(o, a); } function ba(e) { return e.findMarks(it(e.first, 0), e.clipPos(it(e.lastLine())), ((e) => e.parent)); } function ya(e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; const i = r.find(); const o = e.clipPos(i.from); const a = e.clipPos(i.to); if (ot(o, a)) { const s = ma(e, o, a, r.primary, r.primary.type); r.markers.push(s), s.parent = r; } } } function wa(e) { for (let t = function (t) { const n = e[t]; const r = [n.primary.doc]; vo(n.primary.doc, ((e) => r.push(e))); for (let i = 0; i < n.markers.length; i++) { const o = n.markers[i]; H(r, o.doc) == -1 && (o.parent = null, n.markers.splice(i--, 1)); } }, n = 0; n < e.length; n++)t(n); }ga.prototype.clear = function () { if (!this.explicitlyCleared) { this.explicitlyCleared = !0; for (let e = 0; e < this.markers.length; ++e) this.markers[e].clear(); Ln(this, 'clear'); } }, ga.prototype.find = function (e, t) { return this.primary.find(e, t); }, xe(ga); let xa = 0; var ka = function (e, t, n, r, i) { if (!(this instanceof ka)) return new ka(e, t, n, r, i); n == null && (n = 0), ca.call(this, [new la([new ln('', null)])]), this.first = n, this.scrollTop = this.scrollLeft = 0, this.cantEdit = !1, this.cleanGeneration = 1, this.modeFrontier = this.highlightFrontier = n; const o = it(n, 0); this.sel = ao(o), this.history = new xo(null), this.id = ++xa, this.modeOption = t, this.lineSep = r, this.direction = i == 'rtl' ? 'rtl' : 'ltr', this.extend = !1, typeof e === 'string' && (e = this.splitLines(e)), go(this, { from: o, to: o, text: e }), Ro(this, ao(o), q); }; ka.prototype = Q(ca.prototype, {
        constructor: ka,
        iter(e, t, n) { n ? this.iterN(e - this.first, t - e, n) : this.iterN(this.first, this.first + this.size, e); },
        insert(e, t) { for (var n = 0, r = 0; r < t.length; ++r)n += t[r].height; this.insertInner(e - this.first, t, n); },
        remove(e, t) { this.removeInner(e - this.first, t); },
        getValue(e) { const t = Je(this, this.first, this.first + this.size); return !1 === e ? t : t.join(e || this.lineSeparator()); },
        setValue: Pi((function (e) {
          const t = it(this.first, 0); const n = this.first + this.size - 1; Zo(this, {
            from: t, to: it(n, Ye(this, n).text.length), text: this.splitLines(e), origin: 'setValue', full: !0,
          }, !0), this.cm && si(this.cm, 0, 0), Ro(this, ao(t), q);
        })),
        replaceRange(e, t, n, r) { t = ft(this, t), n = n ? ft(this, n) : t, ra(this, e, t, n, r); },
        getRange(e, t, n) { const r = Ze(this, ft(this, e), ft(this, t)); return !1 === n ? r : r.join(n || this.lineSeparator()); },
        getLine(e) { const t = this.getLineHandle(e); return t && t.text; },
        getLineHandle(e) { if (nt(this, e)) return Ye(this, e); },
        getLineNumber(e) { return et(e); },
        getLineHandleVisualStart(e) { return typeof e === 'number' && (e = Ye(this, e)), Zt(e); },
        lineCount() { return this.size; },
        firstLine() { return this.first; },
        lastLine() { return this.first + this.size - 1; },
        clipPos(e) { return ft(this, e); },
        getCursor(e) { let t; const n = this.sel.primary(); return t = e == null || e == 'head' ? n.head : e == 'anchor' ? n.anchor : e == 'end' || e == 'to' || !1 === e ? n.to() : n.from(), t; },
        listSelections() { return this.sel.ranges; },
        somethingSelected() { return this.sel.somethingSelected(); },
        setCursor: Pi((function (e, t, n) { Io(this, ft(this, typeof e === 'number' ? it(e, t || 0) : e), null, n); })),
        setSelection: Pi((function (e, t, n) { Io(this, ft(this, e), ft(this, t || e), n); })),
        extendSelection: Pi((function (e, t, n) { No(this, ft(this, e), t && ft(this, t), n); })),
        extendSelections: Pi((function (e, t) { Fo(this, ht(this, e), t); })),
        extendSelectionsBy: Pi((function (e, t) { const n = Y(this.sel.ranges, e); Fo(this, ht(this, n), t); })),
        setSelections: Pi((function (e, t, n) { if (e.length) { for (var r = [], i = 0; i < e.length; i++)r[i] = new io(ft(this, e[i].anchor), ft(this, e[i].head || e[i].anchor)); t == null && (t = Math.min(e.length - 1, this.sel.primIndex)), Ro(this, oo(this.cm, r, t), n); } })),
        addSelection: Pi((function (e, t, n) { const r = this.sel.ranges.slice(0); r.push(new io(ft(this, e), ft(this, t || e))), Ro(this, oo(this.cm, r, r.length - 1), n); })),
        getSelection(e) { for (var t, n = this.sel.ranges, r = 0; r < n.length; r++) { const i = Ze(this, n[r].from(), n[r].to()); t = t ? t.concat(i) : i; } return !1 === e ? t : t.join(e || this.lineSeparator()); },
        getSelections(e) { for (var t = [], n = this.sel.ranges, r = 0; r < n.length; r++) { let i = Ze(this, n[r].from(), n[r].to()); !1 !== e && (i = i.join(e || this.lineSeparator())), t[r] = i; } return t; },
        replaceSelection(e, t, n) { for (var r = [], i = 0; i < this.sel.ranges.length; i++)r[i] = e; this.replaceSelections(r, t, n || '+input'); },
        replaceSelections: Pi((function (e, t, n) {
          for (var r = [], i = this.sel, o = 0; o < i.ranges.length; o++) {
            const a = i.ranges[o]; r[o] = {
              from: a.from(), to: a.to(), text: this.splitLines(e[o]), origin: n,
            };
          } for (var s = t && t != 'end' && fo(this, r, t), l = r.length - 1; l >= 0; l--)Zo(this, r[l]); s ? Ho(this, s) : this.cm && ai(this.cm);
        })),
        undo: Pi((function () { Qo(this, 'undo'); })),
        redo: Pi((function () { Qo(this, 'redo'); })),
        undoSelection: Pi((function () { Qo(this, 'undo', !0); })),
        redoSelection: Pi((function () { Qo(this, 'redo', !0); })),
        setExtending(e) { this.extend = e; },
        getExtending() { return this.extend; },
        historySize() { for (var e = this.history, t = 0, n = 0, r = 0; r < e.done.length; r++)e.done[r].ranges || ++t; for (let i = 0; i < e.undone.length; i++)e.undone[i].ranges || ++n; return { undo: t, redo: n }; },
        clearHistory() { const e = this; this.history = new xo(this.history), vo(this, ((t) => t.history = e.history), !0); },
        markClean() { this.cleanGeneration = this.changeGeneration(!0); },
        changeGeneration(e) { return e && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), this.history.generation; },
        isClean(e) { return this.history.generation == (e || this.cleanGeneration); },
        getHistory() { return { done: Po(this.history.done), undone: Po(this.history.undone) }; },
        setHistory(e) { const t = this.history = new xo(this.history); t.done = Po(e.done.slice(0), null, !0), t.undone = Po(e.undone.slice(0), null, !0); },
        setGutterMarker: Pi((function (e, t, n) { return sa(this, e, 'gutter', ((e) => { const r = e.gutterMarkers || (e.gutterMarkers = {}); return r[t] = n, !n && re(r) && (e.gutterMarkers = null), !0; })); })),
        clearGutter: Pi((function (e) { const t = this; this.iter(((n) => { n.gutterMarkers && n.gutterMarkers[e] && sa(t, n, 'gutter', (() => (n.gutterMarkers[e] = null, re(n.gutterMarkers) && (n.gutterMarkers = null), !0))); })); })),
        lineInfo(e) {
          let t; if (typeof e === 'number') { if (!nt(this, e)) return null; if (t = e, e = Ye(this, e), !e) return null; } else if (t = et(e), t == null) return null; return {
            line: t, handle: e, text: e.text, gutterMarkers: e.gutterMarkers, textClass: e.textClass, bgClass: e.bgClass, wrapClass: e.wrapClass, widgets: e.widgets,
          };
        },
        addLineClass: Pi((function (e, t, n) { return sa(this, e, t == 'gutter' ? 'gutter' : 'class', ((e) => { const r = t == 'text' ? 'textClass' : t == 'background' ? 'bgClass' : t == 'gutter' ? 'gutterClass' : 'wrapClass'; if (e[r]) { if (C(n).test(e[r])) return !1; e[r] += ` ${n}`; } else e[r] = n; return !0; })); })),
        removeLineClass: Pi((function (e, t, n) {
          return sa(this, e, t == 'gutter' ? 'gutter' : 'class', ((e) => {
            const r = t == 'text' ? 'textClass' : t == 'background' ? 'bgClass' : t == 'gutter' ? 'gutterClass' : 'wrapClass'; const
              i = e[r]; if (!i) return !1; if (n == null)e[r] = null; else { const o = i.match(C(n)); if (!o) return !1; const a = o.index + o[0].length; e[r] = i.slice(0, o.index) + (o.index && a != i.length ? ' ' : '') + i.slice(a) || null; } return !0;
          }));
        })),
        addLineWidget: Pi((function (e, t, n) { return da(this, e, t, n); })),
        removeLineWidget(e) { e.clear(); },
        markText(e, t, n) { return ma(this, ft(this, e), ft(this, t), n, n && n.type || 'range'); },
        setBookmark(e, t) {
          const n = {
            replacedWith: t && (t.nodeType == null ? t.widget : t), insertLeft: t && t.insertLeft, clearWhenEmpty: !1, shared: t && t.shared, handleMouseEvents: t && t.handleMouseEvents,
          }; return e = ft(this, e), ma(this, e, e, n, 'bookmark');
        },
        findMarksAt(e) { e = ft(this, e); const t = []; const n = Ye(this, e.line).markedSpans; if (n) for (let r = 0; r < n.length; ++r) { const i = n[r]; (i.from == null || i.from <= e.ch) && (i.to == null || i.to >= e.ch) && t.push(i.marker.parent || i.marker); } return t; },
        findMarks(e, t, n) { e = ft(this, e), t = ft(this, t); const r = []; let i = e.line; return this.iter(e.line, t.line + 1, ((o) => { const a = o.markedSpans; if (a) for (let s = 0; s < a.length; s++) { const l = a[s]; l.to != null && i == e.line && e.ch >= l.to || l.from == null && i != e.line || l.from != null && i == t.line && l.from >= t.ch || n && !n(l.marker) || r.push(l.marker.parent || l.marker); }++i; })), r; },
        getAllMarks() { const e = []; return this.iter(((t) => { const n = t.markedSpans; if (n) for (let r = 0; r < n.length; ++r)n[r].from != null && e.push(n[r].marker); })), e; },
        posFromIndex(e) { let t; let n = this.first; const r = this.lineSeparator().length; return this.iter(((i) => { const o = i.text.length + r; if (o > e) return t = e, !0; e -= o, ++n; })), ft(this, it(n, t)); },
        indexFromPos(e) { e = ft(this, e); let t = e.ch; if (e.line < this.first || e.ch < 0) return 0; const n = this.lineSeparator().length; return this.iter(this.first, e.line, ((e) => { t += e.text.length + n; })), t; },
        copy(e) { const t = new ka(Je(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction); return t.scrollTop = this.scrollTop, t.scrollLeft = this.scrollLeft, t.sel = this.sel, t.extend = !1, e && (t.history.undoDepth = this.history.undoDepth, t.setHistory(this.getHistory())), t; },
        linkedDoc(e) { e || (e = {}); let t = this.first; let n = this.first + this.size; e.from != null && e.from > t && (t = e.from), e.to != null && e.to < n && (n = e.to); const r = new ka(Je(this, t, n), e.mode || this.modeOption, t, this.lineSep, this.direction); return e.sharedHist && (r.history = this.history), (this.linked || (this.linked = [])).push({ doc: r, sharedHist: e.sharedHist }), r.linked = [{ doc: this, isParent: !0, sharedHist: e.sharedHist }], ya(r, ba(this)), r; },
        unlinkDoc(e) { if (e instanceof Fs && (e = e.doc), this.linked) for (let t = 0; t < this.linked.length; ++t) { const n = this.linked[t]; if (n.doc == e) { this.linked.splice(t, 1), e.unlinkDoc(this), wa(ba(this)); break; } } if (e.history == this.history) { const r = [e.id]; vo(e, ((e) => r.push(e.id)), !0), e.history = new xo(null), e.history.done = Po(this.history.done, r), e.history.undone = Po(this.history.undone, r); } },
        iterLinkedDocs(e) { vo(this, e); },
        getMode() { return this.mode; },
        getEditor() { return this.cm; },
        splitLines(e) { return this.lineSep ? e.split(this.lineSep) : Pe(e); },
        lineSeparator() { return this.lineSep || '\n'; },
        setDirection: Pi((function (e) { e != 'rtl' && (e = 'ltr'), e != this.direction && (this.direction = e, this.iter(((e) => e.order = null)), this.cm && wo(this.cm)); })),
      }), ka.prototype.eachLine = ka.prototype.iter; let _a = 0; function Ca(e) {
        const t = this; if (ja(t), !be(t, e) && !qn(t.display, e)) {
          ke(e), a && (_a = +new Date()); let n = Dr(t, e, !0); const r = e.dataTransfer.files; if (n && !t.isReadOnly()) {
            if (r && r.length && window.FileReader && window.File) {
              for (var i = r.length, o = Array(i), s = 0, l = function () {
                  ++s == i && Ai(t, (() => {
                    n = ft(t.doc, n); const e = {
                      from: n, to: n, text: t.doc.splitLines(o.filter(((e) => e != null)).join(t.doc.lineSeparator())), origin: 'paste',
                    }; Zo(t.doc, e), Ho(t.doc, ao(ft(t.doc, n), ft(t.doc, so(e))));
                  }))();
                }, c = function (e, n) { if (t.options.allowDropFileTypes && H(t.options.allowDropFileTypes, e.type) == -1)l(); else { const r = new FileReader(); r.onerror = function () { return l(); }, r.onload = function () { const e = r.result; /[\x00-\x08\x0e-\x1f]{2}/.test(e) || (o[n] = e), l(); }, r.readAsText(e); } }, u = 0; u < r.length; u++)c(r[u], u);
            } else { if (t.state.draggingText && t.doc.sel.contains(n) > -1) return t.state.draggingText(e), void setTimeout((() => t.display.input.focus()), 20); try { const f = e.dataTransfer.getData('Text'); if (f) { let d; if (t.state.draggingText && !t.state.draggingText.copy && (d = t.listSelections()), Wo(t.doc, ao(n, n)), d) for (let h = 0; h < d.length; ++h)ra(t.doc, '', d[h].anchor, d[h].head, 'drag'); t.replaceSelection(f, 'around', 'paste'), t.display.input.focus(); } } catch (p) {} }
          }
        }
      } function Sa(e, t) { if (a && (!e.state.draggingText || +new Date() - _a < 100))Se(t); else if (!be(e, t) && !qn(e.display, t) && (t.dataTransfer.setData('Text', e.getSelection()), t.dataTransfer.effectAllowed = 'copyMove', t.dataTransfer.setDragImage && !d)) { const n = T('img', null, null, 'position: fixed; left: 0; top: 0;'); n.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==', f && (n.width = n.height = 1, e.display.wrapper.appendChild(n), n._top = n.offsetTop), t.dataTransfer.setDragImage(n, 0, 0), f && n.parentNode.removeChild(n); } } function Oa(e, t) { const n = Dr(e, t); if (n) { const r = document.createDocumentFragment(); $r(e, n, r), e.display.dragCursor || (e.display.dragCursor = T('div', null, 'CodeMirror-cursors CodeMirror-dragcursors'), e.display.lineSpace.insertBefore(e.display.dragCursor, e.display.cursorDiv)), L(e.display.dragCursor, r); } } function ja(e) { e.display.dragCursor && (e.display.lineSpace.removeChild(e.display.dragCursor), e.display.dragCursor = null); } function La(e) { if (document.getElementsByClassName) { for (var t = document.getElementsByClassName('CodeMirror'), n = [], r = 0; r < t.length; r++) { const i = t[r].CodeMirror; i && n.push(i); }n.length && n[0].operation((() => { for (let t = 0; t < n.length; t++)e(n[t]); })); } } let Ta = !1; function Ma() { Ta || (Aa(), Ta = !0); } function Aa() { let e; pe(window, 'resize', (() => { e == null && (e = setTimeout((() => { e = null, La(Ea); }), 100)); })), pe(window, 'blur', (() => La(Zr))); } function Ea(e) { const t = e.display; t.cachedCharWidth = t.cachedTextHeight = t.cachedPaddingH = null, t.scrollbarsClipped = !1, e.setSize(); } for (var Pa = {
          3: 'Pause', 8: 'Backspace', 9: 'Tab', 13: 'Enter', 16: 'Shift', 17: 'Ctrl', 18: 'Alt', 19: 'Pause', 20: 'CapsLock', 27: 'Esc', 32: 'Space', 33: 'PageUp', 34: 'PageDown', 35: 'End', 36: 'Home', 37: 'Left', 38: 'Up', 39: 'Right', 40: 'Down', 44: 'PrintScrn', 45: 'Insert', 46: 'Delete', 59: ';', 61: '=', 91: 'Mod', 92: 'Mod', 93: 'Mod', 106: '*', 107: '=', 109: '-', 110: '.', 111: '/', 145: 'ScrollLock', 173: '-', 186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`', 219: '[', 220: '\\', 221: ']', 222: "'", 224: 'Mod', 63232: 'Up', 63233: 'Down', 63234: 'Left', 63235: 'Right', 63272: 'Delete', 63273: 'Home', 63275: 'End', 63276: 'PageUp', 63277: 'PageDown', 63302: 'Insert',
        }, Da = 0; Da < 10; Da++)Pa[Da + 48] = Pa[Da + 96] = String(Da); for (let Na = 65; Na <= 90; Na++)Pa[Na] = String.fromCharCode(Na); for (let Fa = 1; Fa <= 12; Fa++)Pa[Fa + 111] = Pa[Fa + 63235] = `F${Fa}`; const za = {}; function Ia(e) { let t; let n; let r; let i; const o = e.split(/-(?!$)/); e = o[o.length - 1]; for (let a = 0; a < o.length - 1; a++) { const s = o[a]; if (/^(cmd|meta|m)$/i.test(s))i = !0; else if (/^a(lt)?$/i.test(s))t = !0; else if (/^(c|ctrl|control)$/i.test(s))n = !0; else { if (!/^s(hift)?$/i.test(s)) throw new Error(`Unrecognized modifier name: ${s}`); r = !0; } } return t && (e = `Alt-${e}`), n && (e = `Ctrl-${e}`), i && (e = `Cmd-${e}`), r && (e = `Shift-${e}`), e; } function Ba(e) { const t = {}; for (const n in e) if (e.hasOwnProperty(n)) { const r = e[n]; if (/^(name|fallthrough|(de|at)tach)$/.test(n)) continue; if (r == '...') { delete e[n]; continue; } for (let i = Y(n.split(' '), Ia), o = 0; o < i.length; o++) { let a = void 0; let s = void 0; o == i.length - 1 ? (s = i.join(' '), a = r) : (s = i.slice(0, o + 1).join(' '), a = '...'); const l = t[s]; if (l) { if (l != a) throw new Error(`Inconsistent bindings for ${s}`); } else t[s] = a; } delete e[n]; } for (const c in t)e[c] = t[c]; return e; } function Ha(e, t, n, r) { t = $a(t); const i = t.call ? t.call(e, r) : t[e]; if (!1 === i) return 'nothing'; if (i === '...') return 'multi'; if (i != null && n(i)) return 'handled'; if (t.fallthrough) { if (Object.prototype.toString.call(t.fallthrough) != '[object Array]') return Ha(e, t.fallthrough, n, r); for (let o = 0; o < t.fallthrough.length; o++) { const a = Ha(e, t.fallthrough[o], n, r); if (a) return a; } } } function Ra(e) { const t = typeof e === 'string' ? e : Pa[e.keyCode]; return t == 'Ctrl' || t == 'Alt' || t == 'Shift' || t == 'Mod'; } function Wa(e, t, n) { const r = e; return t.altKey && r != 'Alt' && (e = `Alt-${e}`), (k ? t.metaKey : t.ctrlKey) && r != 'Ctrl' && (e = `Ctrl-${e}`), (k ? t.ctrlKey : t.metaKey) && r != 'Mod' && (e = `Cmd-${e}`), !n && t.shiftKey && r != 'Shift' && (e = `Shift-${e}`), e; } function qa(e, t) { if (f && e.keyCode == 34 && e.char) return !1; let n = Pa[e.keyCode]; return n != null && !e.altGraphKey && (e.keyCode == 3 && e.code && (n = e.code), Wa(n, e, t)); } function $a(e) { return typeof e === 'string' ? za[e] : e; } function Va(e, t) { for (var n = e.doc.sel.ranges, r = [], i = 0; i < n.length; i++) { const o = t(n[i]); while (r.length && ot(o.from, X(r).to) <= 0) { const a = r.pop(); if (ot(a.from, o.from) < 0) { o.from = a.from; break; } }r.push(o); }Mi(e, (() => { for (let t = r.length - 1; t >= 0; t--)ra(e.doc, '', r[t].from, r[t].to, '+delete'); ai(e); })); } function Ua(e, t, n) { const r = ae(e.text, t + n, n); return r < 0 || r > e.text.length ? null : r; } function Ga(e, t, n) { const r = Ua(e, t.ch, n); return r == null ? null : new it(t.line, r, n < 0 ? 'after' : 'before'); } function Ka(e, t, n, r, i) { if (e) { t.doc.direction == 'rtl' && (i = -i); const o = de(n, t.doc.direction); if (o) { let a; const s = i < 0 ? X(o) : o[0]; const l = i < 0 == (s.level == 1); const c = l ? 'after' : 'before'; if (s.level > 0 || t.doc.direction == 'rtl') { const u = tr(t, n); a = i < 0 ? n.text.length - 1 : 0; const f = nr(t, u, a).top; a = se(((e) => nr(t, u, e).top == f), i < 0 == (s.level == 1) ? s.from : s.to - 1, a), c == 'before' && (a = Ua(n, a, 1)); } else a = i < 0 ? s.to : s.from; return new it(r, a, c); } } return new it(r, i < 0 ? n.text.length : 0, i < 0 ? 'before' : 'after'); } function Xa(e, t, n, r) { const i = de(t, e.doc.direction); if (!i) return Ga(t, n, r); n.ch >= t.text.length ? (n.ch = t.text.length, n.sticky = 'before') : n.ch <= 0 && (n.ch = 0, n.sticky = 'after'); const o = ue(i, n.ch, n.sticky); const a = i[o]; if (e.doc.direction == 'ltr' && a.level % 2 == 0 && (r > 0 ? a.to > n.ch : a.from < n.ch)) return Ga(t, n, r); let s; const l = function (e, n) { return Ua(t, e instanceof it ? e.ch : e, n); }; const c = function (n) { return e.options.lineWrapping ? (s = s || tr(e, t), _r(e, t, s, n)) : { begin: 0, end: t.text.length }; }; const u = c(n.sticky == 'before' ? l(n, -1) : n.ch); if (e.doc.direction == 'rtl' || a.level == 1) { const f = a.level == 1 == r < 0; const d = l(n, f ? 1 : -1); if (d != null && (f ? d <= a.to && d <= u.end : d >= a.from && d >= u.begin)) { const h = f ? 'before' : 'after'; return new it(n.line, d, h); } } const p = function (e, t, r) { for (let o = function (e, t) { return t ? new it(n.line, l(e, 1), 'before') : new it(n.line, e, 'after'); }; e >= 0 && e < i.length; e += t) { const a = i[e]; const s = t > 0 == (a.level != 1); let c = s ? r.begin : l(r.end, -1); if (a.from <= c && c < a.to) return o(c, s); if (c = s ? a.from : l(a.to, -1), r.begin <= c && c < r.end) return o(c, s); } }; let m = p(o + r, r, u); if (m) return m; const g = r > 0 ? u.end : l(u.begin, -1); return g == null || r > 0 && g == t.text.length || (m = p(r > 0 ? 0 : i.length - 1, r, c(g)), !m) ? null : m; }za.basic = {
        Left: 'goCharLeft', Right: 'goCharRight', Up: 'goLineUp', Down: 'goLineDown', End: 'goLineEnd', Home: 'goLineStartSmart', PageUp: 'goPageUp', PageDown: 'goPageDown', Delete: 'delCharAfter', Backspace: 'delCharBefore', 'Shift-Backspace': 'delCharBefore', Tab: 'defaultTab', 'Shift-Tab': 'indentAuto', Enter: 'newlineAndIndent', Insert: 'toggleOverwrite', Esc: 'singleSelection',
      }, za.pcDefault = {
        'Ctrl-A': 'selectAll', 'Ctrl-D': 'deleteLine', 'Ctrl-Z': 'undo', 'Shift-Ctrl-Z': 'redo', 'Ctrl-Y': 'redo', 'Ctrl-Home': 'goDocStart', 'Ctrl-End': 'goDocEnd', 'Ctrl-Up': 'goLineUp', 'Ctrl-Down': 'goLineDown', 'Ctrl-Left': 'goGroupLeft', 'Ctrl-Right': 'goGroupRight', 'Alt-Left': 'goLineStart', 'Alt-Right': 'goLineEnd', 'Ctrl-Backspace': 'delGroupBefore', 'Ctrl-Delete': 'delGroupAfter', 'Ctrl-S': 'save', 'Ctrl-F': 'find', 'Ctrl-G': 'findNext', 'Shift-Ctrl-G': 'findPrev', 'Shift-Ctrl-F': 'replace', 'Shift-Ctrl-R': 'replaceAll', 'Ctrl-[': 'indentLess', 'Ctrl-]': 'indentMore', 'Ctrl-U': 'undoSelection', 'Shift-Ctrl-U': 'redoSelection', 'Alt-U': 'redoSelection', fallthrough: 'basic',
      }, za.emacsy = {
        'Ctrl-F': 'goCharRight', 'Ctrl-B': 'goCharLeft', 'Ctrl-P': 'goLineUp', 'Ctrl-N': 'goLineDown', 'Ctrl-A': 'goLineStart', 'Ctrl-E': 'goLineEnd', 'Ctrl-V': 'goPageDown', 'Shift-Ctrl-V': 'goPageUp', 'Ctrl-D': 'delCharAfter', 'Ctrl-H': 'delCharBefore', 'Alt-Backspace': 'delWordBefore', 'Ctrl-K': 'killLine', 'Ctrl-T': 'transposeChars', 'Ctrl-O': 'openLine',
      }, za.macDefault = {
        'Cmd-A': 'selectAll', 'Cmd-D': 'deleteLine', 'Cmd-Z': 'undo', 'Shift-Cmd-Z': 'redo', 'Cmd-Y': 'redo', 'Cmd-Home': 'goDocStart', 'Cmd-Up': 'goDocStart', 'Cmd-End': 'goDocEnd', 'Cmd-Down': 'goDocEnd', 'Alt-Left': 'goGroupLeft', 'Alt-Right': 'goGroupRight', 'Cmd-Left': 'goLineLeft', 'Cmd-Right': 'goLineRight', 'Alt-Backspace': 'delGroupBefore', 'Ctrl-Alt-Backspace': 'delGroupAfter', 'Alt-Delete': 'delGroupAfter', 'Cmd-S': 'save', 'Cmd-F': 'find', 'Cmd-G': 'findNext', 'Shift-Cmd-G': 'findPrev', 'Cmd-Alt-F': 'replace', 'Shift-Cmd-Alt-F': 'replaceAll', 'Cmd-[': 'indentLess', 'Cmd-]': 'indentMore', 'Cmd-Backspace': 'delWrappedLineLeft', 'Cmd-Delete': 'delWrappedLineRight', 'Cmd-U': 'undoSelection', 'Shift-Cmd-U': 'redoSelection', 'Ctrl-Up': 'goDocStart', 'Ctrl-Down': 'goDocEnd', fallthrough: ['basic', 'emacsy'],
      }, za.default = b ? za.macDefault : za.pcDefault; const Ya = {
        selectAll: Xo, singleSelection(e) { return e.setSelection(e.getCursor('anchor'), e.getCursor('head'), q); }, killLine(e) { return Va(e, ((t) => { if (t.empty()) { const n = Ye(e.doc, t.head.line).text.length; return t.head.ch == n && t.head.line < e.lastLine() ? { from: t.head, to: it(t.head.line + 1, 0) } : { from: t.head, to: it(t.head.line, n) }; } return { from: t.from(), to: t.to() }; })); }, deleteLine(e) { return Va(e, ((t) => ({ from: it(t.from().line, 0), to: ft(e.doc, it(t.to().line + 1, 0)) }))); }, delLineLeft(e) { return Va(e, ((e) => ({ from: it(e.from().line, 0), to: e.from() }))); }, delWrappedLineLeft(e) { return Va(e, ((t) => { const n = e.charCoords(t.head, 'div').top + 5; const r = e.coordsChar({ left: 0, top: n }, 'div'); return { from: r, to: t.from() }; })); }, delWrappedLineRight(e) { return Va(e, ((t) => { const n = e.charCoords(t.head, 'div').top + 5; const r = e.coordsChar({ left: e.display.lineDiv.offsetWidth + 100, top: n }, 'div'); return { from: t.from(), to: r }; })); }, undo(e) { return e.undo(); }, redo(e) { return e.redo(); }, undoSelection(e) { return e.undoSelection(); }, redoSelection(e) { return e.redoSelection(); }, goDocStart(e) { return e.extendSelection(it(e.firstLine(), 0)); }, goDocEnd(e) { return e.extendSelection(it(e.lastLine())); }, goLineStart(e) { return e.extendSelectionsBy(((t) => Za(e, t.head.line)), { origin: '+move', bias: 1 }); }, goLineStartSmart(e) { return e.extendSelectionsBy(((t) => Qa(e, t.head)), { origin: '+move', bias: 1 }); }, goLineEnd(e) { return e.extendSelectionsBy(((t) => Ja(e, t.head.line)), { origin: '+move', bias: -1 }); }, goLineRight(e) { return e.extendSelectionsBy(((t) => { const n = e.cursorCoords(t.head, 'div').top + 5; return e.coordsChar({ left: e.display.lineDiv.offsetWidth + 100, top: n }, 'div'); }), V); }, goLineLeft(e) { return e.extendSelectionsBy(((t) => { const n = e.cursorCoords(t.head, 'div').top + 5; return e.coordsChar({ left: 0, top: n }, 'div'); }), V); }, goLineLeftSmart(e) { return e.extendSelectionsBy(((t) => { const n = e.cursorCoords(t.head, 'div').top + 5; const r = e.coordsChar({ left: 0, top: n }, 'div'); return r.ch < e.getLine(r.line).search(/\S/) ? Qa(e, t.head) : r; }), V); }, goLineUp(e) { return e.moveV(-1, 'line'); }, goLineDown(e) { return e.moveV(1, 'line'); }, goPageUp(e) { return e.moveV(-1, 'page'); }, goPageDown(e) { return e.moveV(1, 'page'); }, goCharLeft(e) { return e.moveH(-1, 'char'); }, goCharRight(e) { return e.moveH(1, 'char'); }, goColumnLeft(e) { return e.moveH(-1, 'column'); }, goColumnRight(e) { return e.moveH(1, 'column'); }, goWordLeft(e) { return e.moveH(-1, 'word'); }, goGroupRight(e) { return e.moveH(1, 'group'); }, goGroupLeft(e) { return e.moveH(-1, 'group'); }, goWordRight(e) { return e.moveH(1, 'word'); }, delCharBefore(e) { return e.deleteH(-1, 'codepoint'); }, delCharAfter(e) { return e.deleteH(1, 'char'); }, delWordBefore(e) { return e.deleteH(-1, 'word'); }, delWordAfter(e) { return e.deleteH(1, 'word'); }, delGroupBefore(e) { return e.deleteH(-1, 'group'); }, delGroupAfter(e) { return e.deleteH(1, 'group'); }, indentAuto(e) { return e.indentSelection('smart'); }, indentMore(e) { return e.indentSelection('add'); }, indentLess(e) { return e.indentSelection('subtract'); }, insertTab(e) { return e.replaceSelection('\t'); }, insertSoftTab(e) { for (var t = [], n = e.listSelections(), r = e.options.tabSize, i = 0; i < n.length; i++) { const o = n[i].from(); const a = I(e.getLine(o.line), o.ch, r); t.push(K(r - a % r)); }e.replaceSelections(t); }, defaultTab(e) { e.somethingSelected() ? e.indentSelection('add') : e.execCommand('insertTab'); }, transposeChars(e) { return Mi(e, (() => { for (var t = e.listSelections(), n = [], r = 0; r < t.length; r++) if (t[r].empty()) { let i = t[r].head; const o = Ye(e.doc, i.line).text; if (o) if (i.ch == o.length && (i = new it(i.line, i.ch - 1)), i.ch > 0)i = new it(i.line, i.ch + 1), e.replaceRange(o.charAt(i.ch - 1) + o.charAt(i.ch - 2), it(i.line, i.ch - 2), i, '+transpose'); else if (i.line > e.doc.first) { const a = Ye(e.doc, i.line - 1).text; a && (i = new it(i.line, 1), e.replaceRange(o.charAt(0) + e.doc.lineSeparator() + a.charAt(a.length - 1), it(i.line - 1, a.length - 1), i, '+transpose')); }n.push(new io(i, i)); }e.setSelections(n); })); }, newlineAndIndent(e) { return Mi(e, (() => { for (var t = e.listSelections(), n = t.length - 1; n >= 0; n--)e.replaceRange(e.doc.lineSeparator(), t[n].anchor, t[n].head, '+input'); t = e.listSelections(); for (let r = 0; r < t.length; r++)e.indentLine(t[r].from().line, null, !0); ai(e); })); }, openLine(e) { return e.replaceSelection('\n', 'start'); }, toggleOverwrite(e) { return e.toggleOverwrite(); },
      }; function Za(e, t) { const n = Ye(e.doc, t); const r = Zt(n); return r != n && (t = et(r)), Ka(!0, e, r, t, 1); } function Ja(e, t) { const n = Ye(e.doc, t); const r = Jt(n); return r != n && (t = et(r)), Ka(!0, e, n, t, -1); } function Qa(e, t) { const n = Za(e, t.line); const r = Ye(e.doc, n.line); const i = de(r, e.doc.direction); if (!i || i[0].level == 0) { const o = Math.max(n.ch, r.text.search(/\S/)); const a = t.line == n.line && t.ch <= o && t.ch; return it(n.line, a ? 0 : o, n.sticky); } return n; } function es(e, t, n) { if (typeof t === 'string' && (t = Ya[t], !t)) return !1; e.display.input.ensurePolled(); const r = e.display.shift; let i = !1; try { e.isReadOnly() && (e.state.suppressEdits = !0), n && (e.display.shift = !1), i = t(e) != W; } finally { e.display.shift = r, e.state.suppressEdits = !1; } return i; } function ts(e, t, n) { for (let r = 0; r < e.state.keyMaps.length; r++) { const i = Ha(t, e.state.keyMaps[r], n, e); if (i) return i; } return e.options.extraKeys && Ha(t, e.options.extraKeys, n, e) || Ha(t, e.options.keyMap, n, e); } const ns = new B(); function rs(e, t, n, r) { const i = e.state.keySeq; if (i) { if (Ra(t)) return 'handled'; if (/\'$/.test(t) ? e.state.keySeq = null : ns.set(50, (() => { e.state.keySeq == i && (e.state.keySeq = null, e.display.input.reset()); })), is(e, `${i} ${t}`, n, r)) return !0; } return is(e, t, n, r); } function is(e, t, n, r) { const i = ts(e, t, r); return i == 'multi' && (e.state.keySeq = t), i == 'handled' && Ln(e, 'keyHandled', e, t, n), i != 'handled' && i != 'multi' || (ke(n), Gr(e)), !!i; } function os(e, t) { const n = qa(t, !0); return !!n && (t.shiftKey && !e.state.keySeq ? rs(e, `Shift-${n}`, t, ((t) => es(e, t, !0))) || rs(e, n, t, ((t) => { if (typeof t === 'string' ? /^go[A-Z]/.test(t) : t.motion) return es(e, t); })) : rs(e, n, t, ((t) => es(e, t)))); } function as(e, t, n) { return rs(e, `'${n}'`, t, ((t) => es(e, t, !0))); } let ss = null; function ls(e) { const t = this; if ((!e.target || e.target == t.display.input.getField()) && (t.curOp.focus = E(), !be(t, e))) { a && s < 11 && e.keyCode == 27 && (e.returnValue = !1); const r = e.keyCode; t.display.shift = r == 16 || e.shiftKey; const i = os(t, e); f && (ss = i ? r : null, i || r != 88 || Ne || !(b ? e.metaKey : e.ctrlKey) || t.replaceSelection('', null, 'cut')), n && !b && !i && r == 46 && e.shiftKey && !e.ctrlKey && document.execCommand && document.execCommand('cut'), r != 18 || /\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className) || cs(t); } } function cs(e) { const t = e.display.lineDiv; function n(e) { e.keyCode != 18 && e.altKey || (O(t, 'CodeMirror-crosshair'), ge(document, 'keyup', n), ge(document, 'mouseover', n)); }P(t, 'CodeMirror-crosshair'), pe(document, 'keyup', n), pe(document, 'mouseover', n); } function us(e) { e.keyCode == 16 && (this.doc.sel.shift = !1), be(this, e); } function fs(e) { const t = this; if ((!e.target || e.target == t.display.input.getField()) && !(qn(t.display, e) || be(t, e) || e.ctrlKey && !e.altKey || b && e.metaKey)) { const n = e.keyCode; const r = e.charCode; if (f && n == ss) return ss = null, void ke(e); if (!f || e.which && !(e.which < 10) || !os(t, e)) { const i = String.fromCharCode(r == null ? n : r); i != '\b' && (as(t, e, i) || t.display.input.onKeyPress(e)); } } } let ds; let hs; const ps = 400; const ms = function (e, t, n) { this.time = e, this.pos = t, this.button = n; }; function gs(e, t) { const n = +new Date(); return hs && hs.compare(n, e, t) ? (ds = hs = null, 'triple') : ds && ds.compare(n, e, t) ? (hs = new ms(n, e, t), ds = null, 'double') : (ds = new ms(n, e, t), hs = null, 'single'); } function vs(e) { const t = this; const n = t.display; if (!(be(t, e) || n.activeTouch && n.input.supportsTouch())) if (n.input.ensurePolled(), n.shift = e.shiftKey, qn(n, e))l || (n.scroller.draggable = !1, setTimeout((() => n.scroller.draggable = !0), 100)); else if (!Os(t, e)) { const r = Dr(t, e); const i = je(e); const o = r ? gs(r, i) : 'single'; window.focus(), i == 1 && t.state.selectingText && t.state.selectingText(e), r && bs(t, i, r, o, e) || (i == 1 ? r ? ws(t, r, o, e) : Oe(e) == n.scroller && ke(e) : i == 2 ? (r && No(t.doc, r), setTimeout((() => n.input.focus()), 20)) : i == 3 && (_ ? t.display.input.onContextMenu(e) : Xr(t))); } } function bs(e, t, n, r, i) { let o = 'Click'; return r == 'double' ? o = `Double${o}` : r == 'triple' && (o = `Triple${o}`), o = (t == 1 ? 'Left' : t == 2 ? 'Middle' : 'Right') + o, rs(e, Wa(o, i), i, ((t) => { if (typeof t === 'string' && (t = Ya[t]), !t) return !1; let r = !1; try { e.isReadOnly() && (e.state.suppressEdits = !0), r = t(e, n) != W; } finally { e.state.suppressEdits = !1; } return r; })); } function ys(e, t, n) { const r = e.getOption('configureMouse'); const i = r ? r(e, t, n) : {}; if (i.unit == null) { const o = y ? n.shiftKey && n.metaKey : n.altKey; i.unit = o ? 'rectangle' : t == 'single' ? 'char' : t == 'double' ? 'word' : 'line'; } return (i.extend == null || e.doc.extend) && (i.extend = e.doc.extend || n.shiftKey), i.addNew == null && (i.addNew = b ? n.metaKey : n.ctrlKey), i.moveOnDrag == null && (i.moveOnDrag = !(b ? n.altKey : n.ctrlKey)), i; } function ws(e, t, n, r) { a ? setTimeout(F(Kr, e), 0) : e.curOp.focus = E(); let i; const o = ys(e, n, r); const s = e.doc.sel; e.options.dragDrop && Me && !e.isReadOnly() && n == 'single' && (i = s.contains(t)) > -1 && (ot((i = s.ranges[i]).from(), t) < 0 || t.xRel > 0) && (ot(i.to(), t) > 0 || t.xRel < 0) ? xs(e, r, t, o) : _s(e, r, t, o); } function xs(e, t, n, r) { const i = e.display; let o = !1; var c = Ai(e, ((t) => { l && (i.scroller.draggable = !1), e.state.draggingText = !1, e.state.delayingBlurEvent && (e.hasFocus() ? e.state.delayingBlurEvent = !1 : Xr(e)), ge(i.wrapper.ownerDocument, 'mouseup', c), ge(i.wrapper.ownerDocument, 'mousemove', u), ge(i.scroller, 'dragstart', f), ge(i.scroller, 'drop', c), o || (ke(t), r.addNew || No(e.doc, n, null, null, r.extend), l && !d || a && s == 9 ? setTimeout((() => { i.wrapper.ownerDocument.body.focus({ preventScroll: !0 }), i.input.focus(); }), 20) : i.input.focus()); })); var u = function (e) { o = o || Math.abs(t.clientX - e.clientX) + Math.abs(t.clientY - e.clientY) >= 10; }; var f = function () { return o = !0; }; l && (i.scroller.draggable = !0), e.state.draggingText = c, c.copy = !r.moveOnDrag, pe(i.wrapper.ownerDocument, 'mouseup', c), pe(i.wrapper.ownerDocument, 'mousemove', u), pe(i.scroller, 'dragstart', f), pe(i.scroller, 'drop', c), e.state.delayingBlurEvent = !0, setTimeout((() => i.input.focus()), 20), i.scroller.dragDrop && i.scroller.dragDrop(); } function ks(e, t, n) { if (n == 'char') return new io(t, t); if (n == 'word') return e.findWordAt(t); if (n == 'line') return new io(it(t.line, 0), ft(e.doc, it(t.line + 1, 0))); const r = n(e, t); return new io(r.from, r.to); } function _s(e, t, n, r) { a && Xr(e); const i = e.display; const o = e.doc; ke(t); let s; let l; let c = o.sel; const u = c.ranges; if (r.addNew && !r.extend ? (l = o.sel.contains(n), s = l > -1 ? u[l] : new io(n, n)) : (s = o.sel.primary(), l = o.sel.primIndex), r.unit == 'rectangle')r.addNew || (s = new io(n, n)), n = Dr(e, t, !0, !0), l = -1; else { const f = ks(e, n, r.unit); s = r.extend ? Do(s, f.anchor, f.head, r.extend) : f; }r.addNew ? l == -1 ? (l = u.length, Ro(o, oo(e, u.concat([s]), l), { scroll: !1, origin: '*mouse' })) : u.length > 1 && u[l].empty() && r.unit == 'char' && !r.extend ? (Ro(o, oo(e, u.slice(0, l).concat(u.slice(l + 1)), 0), { scroll: !1, origin: '*mouse' }), c = o.sel) : zo(o, l, s, $) : (l = 0, Ro(o, new ro([s], 0), $), c = o.sel); let d = n; function h(t) { if (ot(d, t) != 0) if (d = t, r.unit == 'rectangle') { for (var i = [], a = e.options.tabSize, u = I(Ye(o, n.line).text, n.ch, a), f = I(Ye(o, t.line).text, t.ch, a), h = Math.min(u, f), p = Math.max(u, f), m = Math.min(n.line, t.line), g = Math.min(e.lastLine(), Math.max(n.line, t.line)); m <= g; m++) { const v = Ye(o, m).text; const b = U(v, h, a); h == p ? i.push(new io(it(m, b), it(m, b))) : v.length > b && i.push(new io(it(m, b), it(m, U(v, p, a)))); }i.length || i.push(new io(n, n)), Ro(o, oo(e, c.ranges.slice(0, l).concat(i), l), { origin: '*mouse', scroll: !1 }), e.scrollIntoView(t); } else { let y; const w = s; const x = ks(e, t, r.unit); let k = w.anchor; ot(x.anchor, k) > 0 ? (y = x.head, k = ct(w.from(), x.anchor)) : (y = x.anchor, k = lt(w.to(), x.head)); const _ = c.ranges.slice(0); _[l] = Cs(e, new io(ft(o, k), y)), Ro(o, oo(e, _, l), $); } } const p = i.wrapper.getBoundingClientRect(); let m = 0; function g(t) { const n = ++m; const a = Dr(e, t, !0, r.unit == 'rectangle'); if (a) if (ot(a, d) != 0) { e.curOp.focus = E(), h(a); const s = ei(i, o); (a.line >= s.to || a.line < s.from) && setTimeout(Ai(e, (() => { m == n && g(t); })), 150); } else { const l = t.clientY < p.top ? -20 : t.clientY > p.bottom ? 20 : 0; l && setTimeout(Ai(e, (() => { m == n && (i.scroller.scrollTop += l, g(t)); })), 50); } } function v(t) { e.state.selectingText = !1, m = 1 / 0, t && (ke(t), i.input.focus()), ge(i.wrapper.ownerDocument, 'mousemove', b), ge(i.wrapper.ownerDocument, 'mouseup', y), o.history.lastSelOrigin = null; } var b = Ai(e, ((e) => { e.buttons !== 0 && je(e) ? g(e) : v(e); })); var y = Ai(e, v); e.state.selectingText = y, pe(i.wrapper.ownerDocument, 'mousemove', b), pe(i.wrapper.ownerDocument, 'mouseup', y); } function Cs(e, t) { const n = t.anchor; const r = t.head; const i = Ye(e.doc, n.line); if (ot(n, r) == 0 && n.sticky == r.sticky) return t; const o = de(i); if (!o) return t; const a = ue(o, n.ch, n.sticky); const s = o[a]; if (s.from != n.ch && s.to != n.ch) return t; let l; const c = a + (s.from == n.ch == (s.level != 1) ? 0 : 1); if (c == 0 || c == o.length) return t; if (r.line != n.line)l = (r.line - n.line) * (e.doc.direction == 'ltr' ? 1 : -1) > 0; else { const u = ue(o, r.ch, r.sticky); const f = u - a || (r.ch - n.ch) * (s.level == 1 ? -1 : 1); l = u == c - 1 || u == c ? f < 0 : f > 0; } const d = o[c + (l ? -1 : 0)]; const h = l == (d.level == 1); const p = h ? d.from : d.to; const m = h ? 'after' : 'before'; return n.ch == p && n.sticky == m ? t : new io(new it(n.line, p, m), r); } function Ss(e, t, n, r) { let i; let o; if (t.touches)i = t.touches[0].clientX, o = t.touches[0].clientY; else try { i = t.clientX, o = t.clientY; } catch (d) { return !1; } if (i >= Math.floor(e.display.gutters.getBoundingClientRect().right)) return !1; r && ke(t); const a = e.display; const s = a.lineDiv.getBoundingClientRect(); if (o > s.bottom || !we(e, n)) return Ce(t); o -= s.top - a.viewOffset; for (let l = 0; l < e.display.gutterSpecs.length; ++l) { const c = a.gutters.childNodes[l]; if (c && c.getBoundingClientRect().right >= i) { const u = tt(e.doc, o); const f = e.display.gutterSpecs[l]; return ve(e, n, e, u, f.className, t), Ce(t); } } } function Os(e, t) { return Ss(e, t, 'gutterClick', !0); } function js(e, t) { qn(e.display, t) || Ls(e, t) || be(e, t, 'contextmenu') || _ || e.display.input.onContextMenu(t); } function Ls(e, t) { return !!we(e, 'gutterContextMenu') && Ss(e, t, 'gutterContextMenu', !1); } function Ts(e) { e.display.wrapper.className = e.display.wrapper.className.replace(/\s*cm-s-\S+/g, '') + e.options.theme.replace(/(^|\s)\s*/g, ' cm-s-'), fr(e); }ms.prototype.compare = function (e, t, n) { return this.time + ps > e && ot(t, this.pos) == 0 && n == this.button; }; const Ms = { toString() { return 'CodeMirror.Init'; } }; const As = {}; const Es = {}; function Ps(e) { const t = e.optionHandlers; function n(n, r, i, o) { e.defaults[n] = r, i && (t[n] = o ? function (e, t, n) { n != Ms && i(e, t, n); } : i); }e.defineOption = n, e.Init = Ms, n('value', '', ((e, t) => e.setValue(t)), !0), n('mode', null, ((e, t) => { e.doc.modeOption = t, ho(e); }), !0), n('indentUnit', 2, ho, !0), n('indentWithTabs', !1), n('smartIndent', !0), n('tabSize', 4, ((e) => { po(e), fr(e), Fr(e); }), !0), n('lineSeparator', null, ((e, t) => { if (e.doc.lineSep = t, t) { const n = []; let r = e.doc.first; e.doc.iter(((e) => { for (let i = 0; ;) { const o = e.text.indexOf(t, i); if (o == -1) break; i = o + t.length, n.push(it(r, o)); }r++; })); for (let i = n.length - 1; i >= 0; i--)ra(e.doc, t, n[i], it(n[i].line, n[i].ch + t.length)); } })), n('specialChars', /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, ((e, t, n) => { e.state.specialChars = new RegExp(t.source + (t.test('\t') ? '' : '|\t'), 'g'), n != Ms && e.refresh(); })), n('specialCharPlaceholder', mn, ((e) => e.refresh()), !0), n('electricChars', !0), n('inputStyle', v ? 'contenteditable' : 'textarea', (() => { throw new Error('inputStyle can not (yet) be changed in a running editor'); }), !0), n('spellcheck', !1, ((e, t) => e.getInputField().spellcheck = t), !0), n('autocorrect', !1, ((e, t) => e.getInputField().autocorrect = t), !0), n('autocapitalize', !1, ((e, t) => e.getInputField().autocapitalize = t), !0), n('rtlMoveVisually', !w), n('wholeLineUpdateBefore', !0), n('theme', 'default', ((e) => { Ts(e), Yi(e); }), !0), n('keyMap', 'default', ((e, t, n) => { const r = $a(t); const i = n != Ms && $a(n); i && i.detach && i.detach(e, r), r.attach && r.attach(e, i || null); })), n('extraKeys', null), n('configureMouse', null), n('lineWrapping', !1, Ns, !0), n('gutters', [], ((e, t) => { e.display.gutterSpecs = Ki(t, e.options.lineNumbers), Yi(e); }), !0), n('fixedGutter', !0, ((e, t) => { e.display.gutters.style.left = t ? `${Ar(e.display)}px` : '0', e.refresh(); }), !0), n('coverGutterNextToScrollbar', !1, ((e) => vi(e)), !0), n('scrollbarStyle', 'native', ((e) => { wi(e), vi(e), e.display.scrollbars.setScrollTop(e.doc.scrollTop), e.display.scrollbars.setScrollLeft(e.doc.scrollLeft); }), !0), n('lineNumbers', !1, ((e, t) => { e.display.gutterSpecs = Ki(e.options.gutters, t), Yi(e); }), !0), n('firstLineNumber', 1, Yi, !0), n('lineNumberFormatter', ((e) => e), Yi, !0), n('showCursorWhenSelecting', !1, Wr, !0), n('resetSelectionOnContextMenu', !0), n('lineWiseCopyCut', !0), n('pasteLinesPerSelection', !0), n('selectionsMayTouch', !1), n('readOnly', !1, ((e, t) => { t == 'nocursor' && (Zr(e), e.display.input.blur()), e.display.input.readOnlyChanged(t); })), n('screenReaderLabel', null, ((e, t) => { t = t === '' ? null : t, e.display.input.screenReaderLabelChanged(t); })), n('disableInput', !1, ((e, t) => { t || e.display.input.reset(); }), !0), n('dragDrop', !0, Ds), n('allowDropFileTypes', null), n('cursorBlinkRate', 530), n('cursorScrollMargin', 0), n('cursorHeight', 1, Wr, !0), n('singleCursorHeightPerLine', !0, Wr, !0), n('workTime', 100), n('workDelay', 100), n('flattenSpans', !0, po, !0), n('addModeClass', !1, po, !0), n('pollInterval', 100), n('undoDepth', 200, ((e, t) => e.doc.history.undoDepth = t)), n('historyEventDelay', 1250), n('viewportMargin', 10, ((e) => e.refresh()), !0), n('maxHighlightLength', 1e4, po, !0), n('moveInputWithCursor', !0, ((e, t) => { t || e.display.input.resetPosition(); })), n('tabindex', null, ((e, t) => e.display.input.getField().tabIndex = t || '')), n('autofocus', null), n('direction', 'ltr', ((e, t) => e.doc.setDirection(t)), !0), n('phrases', null); } function Ds(e, t, n) { const r = n && n != Ms; if (!t != !r) { const i = e.display.dragFunctions; const o = t ? pe : ge; o(e.display.scroller, 'dragstart', i.start), o(e.display.scroller, 'dragenter', i.enter), o(e.display.scroller, 'dragover', i.over), o(e.display.scroller, 'dragleave', i.leave), o(e.display.scroller, 'drop', i.drop); } } function Ns(e) { e.options.lineWrapping ? (P(e.display.wrapper, 'CodeMirror-wrap'), e.display.sizer.style.minWidth = '', e.display.sizerWidth = null) : (O(e.display.wrapper, 'CodeMirror-wrap'), sn(e)), Pr(e), Fr(e), fr(e), setTimeout((() => vi(e)), 100); } function Fs(e, t) {
        const n = this; if (!(this instanceof Fs)) return new Fs(e, t); this.options = t = t ? z(t) : {}, z(As, t, !1); let r = t.value; typeof r === 'string' ? r = new ka(r, t.mode, null, t.lineSeparator, t.direction) : t.mode && (r.modeOption = t.mode), this.doc = r; const i = new Fs.inputStyles[t.inputStyle](this); const o = this.display = new Zi(e, r, i, t); for (const c in o.wrapper.CodeMirror = this, Ts(this), t.lineWrapping && (this.display.wrapper.className += ' CodeMirror-wrap'), wi(this), this.state = {
          keyMaps: [], overlays: [], modeGen: 0, overwrite: !1, delayingBlurEvent: !1, focused: !1, suppressEdits: !1, pasteIncoming: -1, cutIncoming: -1, selectingText: !1, draggingText: !1, highlight: new B(), keySeq: null, specialChars: null,
        }, t.autofocus && !v && o.input.focus(), a && s < 11 && setTimeout((() => n.display.input.reset(!0)), 20), zs(this), Ma(), ki(this), this.curOp.forceUpdate = !0, bo(this, r), t.autofocus && !v || this.hasFocus() ? setTimeout((() => { n.hasFocus() && !n.state.focused && Yr(n); }), 20) : Zr(this), Es)Es.hasOwnProperty(c) && Es[c](this, t[c], Ms); Gi(this), t.finishInit && t.finishInit(this); for (let u = 0; u < Is.length; ++u)Is[u](this); _i(this), l && t.lineWrapping && getComputedStyle(o.lineDiv).textRendering == 'optimizelegibility' && (o.lineDiv.style.textRendering = 'auto');
      } function zs(e) {
        const t = e.display; pe(t.scroller, 'mousedown', Ai(e, vs)), pe(t.scroller, 'dblclick', a && s < 11 ? Ai(e, ((t) => { if (!be(e, t)) { const n = Dr(e, t); if (n && !Os(e, t) && !qn(e.display, t)) { ke(t); const r = e.findWordAt(n); No(e.doc, r.anchor, r.head); } } })) : (t) => be(e, t) || ke(t)), pe(t.scroller, 'contextmenu', ((t) => js(e, t))), pe(t.input.getField(), 'contextmenu', ((n) => { t.scroller.contains(n.target) || js(e, n); })); let n; let r = { end: 0 }; function i() { t.activeTouch && (n = setTimeout((() => t.activeTouch = null), 1e3), r = t.activeTouch, r.end = +new Date()); } function o(e) { if (e.touches.length != 1) return !1; const t = e.touches[0]; return t.radiusX <= 1 && t.radiusY <= 1; } function l(e, t) { if (t.left == null) return !0; const n = t.left - e.left; const r = t.top - e.top; return n * n + r * r > 400; }pe(t.scroller, 'touchstart', ((i) => { if (!be(e, i) && !o(i) && !Os(e, i)) { t.input.ensurePolled(), clearTimeout(n); const a = +new Date(); t.activeTouch = { start: a, moved: !1, prev: a - r.end <= 300 ? r : null }, i.touches.length == 1 && (t.activeTouch.left = i.touches[0].pageX, t.activeTouch.top = i.touches[0].pageY); } })), pe(t.scroller, 'touchmove', (() => { t.activeTouch && (t.activeTouch.moved = !0); })), pe(t.scroller, 'touchend', ((n) => { const r = t.activeTouch; if (r && !qn(t, n) && r.left != null && !r.moved && new Date() - r.start < 300) { let o; const a = e.coordsChar(t.activeTouch, 'page'); o = !r.prev || l(r, r.prev) ? new io(a, a) : !r.prev.prev || l(r, r.prev.prev) ? e.findWordAt(a) : new io(it(a.line, 0), ft(e.doc, it(a.line + 1, 0))), e.setSelection(o.anchor, o.head), e.focus(), ke(n); }i(); })), pe(t.scroller, 'touchcancel', i), pe(t.scroller, 'scroll', (() => { t.scroller.clientHeight && (fi(e, t.scroller.scrollTop), hi(e, t.scroller.scrollLeft, !0), ve(e, 'scroll', e)); })), pe(t.scroller, 'mousewheel', ((t) => no(e, t))), pe(t.scroller, 'DOMMouseScroll', ((t) => no(e, t))), pe(t.wrapper, 'scroll', (() => t.wrapper.scrollTop = t.wrapper.scrollLeft = 0)), t.dragFunctions = {
          enter(t) { be(e, t) || Se(t); }, over(t) { be(e, t) || (Oa(e, t), Se(t)); }, start(t) { return Sa(e, t); }, drop: Ai(e, Ca), leave(t) { be(e, t) || ja(e); },
        }; const c = t.input.getField(); pe(c, 'keyup', ((t) => us.call(e, t))), pe(c, 'keydown', Ai(e, ls)), pe(c, 'keypress', Ai(e, fs)), pe(c, 'focus', ((t) => Yr(e, t))), pe(c, 'blur', ((t) => Zr(e, t)));
      }Fs.defaults = As, Fs.optionHandlers = Es; var Is = []; function Bs(e, t, n, r) { let i; const o = e.doc; n == null && (n = 'add'), n == 'smart' && (o.mode.indent ? i = bt(e, t).state : n = 'prev'); const a = e.options.tabSize; const s = Ye(o, t); const l = I(s.text, null, a); s.stateAfter && (s.stateAfter = null); let c; const u = s.text.match(/^\s*/)[0]; if (r || /\S/.test(s.text)) { if (n == 'smart' && (c = o.mode.indent(i, s.text.slice(u.length), s.text), c == W || c > 150)) { if (!r) return; n = 'prev'; } } else c = 0, n = 'not'; n == 'prev' ? c = t > o.first ? I(Ye(o, t - 1).text, null, a) : 0 : n == 'add' ? c = l + e.options.indentUnit : n == 'subtract' ? c = l - e.options.indentUnit : typeof n === 'number' && (c = l + n), c = Math.max(0, c); let f = ''; let d = 0; if (e.options.indentWithTabs) for (let h = Math.floor(c / a); h; --h)d += a, f += '\t'; if (d < c && (f += K(c - d)), f != u) return ra(o, f, it(t, 0), it(t, u.length), '+input'), s.stateAfter = null, !0; for (let p = 0; p < o.sel.ranges.length; p++) { const m = o.sel.ranges[p]; if (m.head.line == t && m.head.ch < u.length) { const g = it(t, u.length); zo(o, p, new io(g, g)); break; } } }Fs.defineInitHook = function (e) { return Is.push(e); }; let Hs = null; function Rs(e) { Hs = e; } function Ws(e, t, n, r, i) {
        const o = e.doc; e.display.shift = !1, r || (r = o.sel); const a = +new Date() - 200; const s = i == 'paste' || e.state.pasteIncoming > a; const l = Pe(t); let c = null; if (s && r.ranges.length > 1) if (Hs && Hs.text.join('\n') == t) { if (r.ranges.length % Hs.text.length == 0) { c = []; for (let u = 0; u < Hs.text.length; u++)c.push(o.splitLines(Hs.text[u])); } } else l.length == r.ranges.length && e.options.pasteLinesPerSelection && (c = Y(l, ((e) => [e]))); for (var f = e.curOp.updateInput, d = r.ranges.length - 1; d >= 0; d--) {
          const h = r.ranges[d]; let p = h.from(); let m = h.to(); h.empty() && (n && n > 0 ? p = it(p.line, p.ch - n) : e.state.overwrite && !s ? m = it(m.line, Math.min(Ye(o, m.line).text.length, m.ch + X(l).length)) : s && Hs && Hs.lineWise && Hs.text.join('\n') == l.join('\n') && (p = m = it(p.line, 0))); const g = {
            from: p, to: m, text: c ? c[d % c.length] : l, origin: i || (s ? 'paste' : e.state.cutIncoming > a ? 'cut' : '+input'),
          }; Zo(e.doc, g), Ln(e, 'inputRead', e, g);
        }t && !s && $s(e, t), ai(e), e.curOp.updateInput < 2 && (e.curOp.updateInput = f), e.curOp.typing = !0, e.state.pasteIncoming = e.state.cutIncoming = -1;
      } function qs(e, t) { const n = e.clipboardData && e.clipboardData.getData('Text'); if (n) return e.preventDefault(), t.isReadOnly() || t.options.disableInput || Mi(t, (() => Ws(t, n, 0, null, 'paste'))), !0; } function $s(e, t) { if (e.options.electricChars && e.options.smartIndent) for (let n = e.doc.sel, r = n.ranges.length - 1; r >= 0; r--) { const i = n.ranges[r]; if (!(i.head.ch > 100 || r && n.ranges[r - 1].head.line == i.head.line)) { const o = e.getModeAt(i.head); let a = !1; if (o.electricChars) { for (let s = 0; s < o.electricChars.length; s++) if (t.indexOf(o.electricChars.charAt(s)) > -1) { a = Bs(e, i.head.line, 'smart'); break; } } else o.electricInput && o.electricInput.test(Ye(e.doc, i.head.line).text.slice(0, i.head.ch)) && (a = Bs(e, i.head.line, 'smart')); a && Ln(e, 'electricInput', e, i.head.line); } } } function Vs(e) { for (var t = [], n = [], r = 0; r < e.doc.sel.ranges.length; r++) { const i = e.doc.sel.ranges[r].head.line; const o = { anchor: it(i, 0), head: it(i + 1, 0) }; n.push(o), t.push(e.getRange(o.anchor, o.head)); } return { text: t, ranges: n }; } function Us(e, t, n, r) { e.setAttribute('autocorrect', n ? '' : 'off'), e.setAttribute('autocapitalize', r ? '' : 'off'), e.setAttribute('spellcheck', !!t); } function Gs() { const e = T('textarea', null, null, 'position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none'); const t = T('div', [e], null, 'overflow: hidden; position: relative; width: 3px; height: 0px;'); return l ? e.style.width = '1000px' : e.setAttribute('wrap', 'off'), m && (e.style.border = '1px solid black'), Us(e), t; } function Ks(e) {
        const t = e.optionHandlers; const n = e.helpers = {}; e.prototype = {
          constructor: e,
          focus() { window.focus(), this.display.input.focus(); },
          setOption(e, n) { const r = this.options; const i = r[e]; r[e] == n && e != 'mode' || (r[e] = n, t.hasOwnProperty(e) && Ai(this, t[e])(this, n, i), ve(this, 'optionChange', this, e)); },
          getOption(e) { return this.options[e]; },
          getDoc() { return this.doc; },
          addKeyMap(e, t) { this.state.keyMaps[t ? 'push' : 'unshift']($a(e)); },
          removeKeyMap(e) { for (let t = this.state.keyMaps, n = 0; n < t.length; ++n) if (t[n] == e || t[n].name == e) return t.splice(n, 1), !0; },
          addOverlay: Ei((function (t, n) {
            const r = t.token ? t : e.getMode(this.options, t); if (r.startState) throw new Error('Overlays may not be stateful.'); Z(this.state.overlays, {
              mode: r, modeSpec: t, opaque: n && n.opaque, priority: n && n.priority || 0,
            }, ((e) => e.priority)), this.state.modeGen++, Fr(this);
          })),
          removeOverlay: Ei((function (e) { for (let t = this.state.overlays, n = 0; n < t.length; ++n) { const r = t[n].modeSpec; if (r == e || typeof e === 'string' && r.name == e) return t.splice(n, 1), this.state.modeGen++, void Fr(this); } })),
          indentLine: Ei((function (e, t, n) { typeof t !== 'string' && typeof t !== 'number' && (t = t == null ? this.options.smartIndent ? 'smart' : 'prev' : t ? 'add' : 'subtract'), nt(this.doc, e) && Bs(this, e, t, n); })),
          indentSelection: Ei((function (e) { for (let t = this.doc.sel.ranges, n = -1, r = 0; r < t.length; r++) { const i = t[r]; if (i.empty())i.head.line > n && (Bs(this, i.head.line, e, !0), n = i.head.line, r == this.doc.sel.primIndex && ai(this)); else { const o = i.from(); const a = i.to(); const s = Math.max(n, o.line); n = Math.min(this.lastLine(), a.line - (a.ch ? 0 : 1)) + 1; for (let l = s; l < n; ++l)Bs(this, l, e); const c = this.doc.sel.ranges; o.ch == 0 && t.length == c.length && c[r].from().ch > 0 && zo(this.doc, r, new io(o, c[r].to()), q); } } })),
          getTokenAt(e, t) { return _t(this, e, t); },
          getLineTokens(e, t) { return _t(this, it(e), t, !0); },
          getTokenTypeAt(e) { e = ft(this.doc, e); let t; const n = vt(this, Ye(this.doc, e.line)); let r = 0; let i = (n.length - 1) / 2; const o = e.ch; if (o == 0)t = n[2]; else for (;;) { const a = r + i >> 1; if ((a ? n[2 * a - 1] : 0) >= o)i = a; else { if (!(n[2 * a + 1] < o)) { t = n[2 * a + 2]; break; }r = a + 1; } } const s = t ? t.indexOf('overlay ') : -1; return s < 0 ? t : s == 0 ? null : t.slice(0, s - 1); },
          getModeAt(t) { const n = this.doc.mode; return n.innerMode ? e.innerMode(n, this.getTokenAt(t).state).mode : n; },
          getHelper(e, t) { return this.getHelpers(e, t)[0]; },
          getHelpers(e, t) { const r = []; if (!n.hasOwnProperty(t)) return r; const i = n[t]; const o = this.getModeAt(e); if (typeof o[t] === 'string')i[o[t]] && r.push(i[o[t]]); else if (o[t]) for (let a = 0; a < o[t].length; a++) { const s = i[o[t][a]]; s && r.push(s); } else o.helperType && i[o.helperType] ? r.push(i[o.helperType]) : i[o.name] && r.push(i[o.name]); for (let l = 0; l < i._global.length; l++) { const c = i._global[l]; c.pred(o, this) && H(r, c.val) == -1 && r.push(c.val); } return r; },
          getStateAfter(e, t) { const n = this.doc; return e = ut(n, e == null ? n.first + n.size - 1 : e), bt(this, e + 1, t).state; },
          cursorCoords(e, t) { let n; const r = this.doc.sel.primary(); return n = e == null ? r.head : typeof e === 'object' ? ft(this.doc, e) : e ? r.from() : r.to(), br(this, n, t || 'page'); },
          charCoords(e, t) { return vr(this, ft(this.doc, e), t || 'page'); },
          coordsChar(e, t) { return e = gr(this, e, t || 'page'), xr(this, e.left, e.top); },
          lineAtHeight(e, t) { return e = gr(this, { top: e, left: 0 }, t || 'page').top, tt(this.doc, e + this.display.viewOffset); },
          heightAtLine(e, t, n) { let r; let i = !1; if (typeof e === 'number') { const o = this.doc.first + this.doc.size - 1; e < this.doc.first ? e = this.doc.first : e > o && (e = o, i = !0), r = Ye(this.doc, e); } else r = e; return mr(this, r, { top: 0, left: 0 }, t || 'page', n || i).top + (i ? this.doc.height - on(r) : 0); },
          defaultTextHeight() { return Lr(this.display); },
          defaultCharWidth() { return Tr(this.display); },
          getViewport() { return { from: this.display.viewFrom, to: this.display.viewTo }; },
          addWidget(e, t, n, r, i) {
            const o = this.display; e = br(this, ft(this.doc, e)); let a = e.bottom; let s = e.left; if (t.style.position = 'absolute', t.setAttribute('cm-ignore-events', 'true'), this.display.input.setUneditable(t), o.sizer.appendChild(t), r == 'over')a = e.top; else if (r == 'above' || r == 'near') { const l = Math.max(o.wrapper.clientHeight, this.doc.height); const c = Math.max(o.sizer.clientWidth, o.lineSpace.clientWidth); (r == 'above' || e.bottom + t.offsetHeight > l) && e.top > t.offsetHeight ? a = e.top - t.offsetHeight : e.bottom + t.offsetHeight <= l && (a = e.bottom), s + t.offsetWidth > c && (s = c - t.offsetWidth); }t.style.top = `${a}px`, t.style.left = t.style.right = '', i == 'right' ? (s = o.sizer.clientWidth - t.offsetWidth, t.style.right = '0px') : (i == 'left' ? s = 0 : i == 'middle' && (s = (o.sizer.clientWidth - t.offsetWidth) / 2), t.style.left = `${s}px`), n && ri(this, {
              left: s, top: a, right: s + t.offsetWidth, bottom: a + t.offsetHeight,
            });
          },
          triggerOnKeyDown: Ei(ls),
          triggerOnKeyPress: Ei(fs),
          triggerOnKeyUp: us,
          triggerOnMouseDown: Ei(vs),
          execCommand(e) { if (Ya.hasOwnProperty(e)) return Ya[e].call(null, this); },
          triggerElectric: Ei((function (e) { $s(this, e); })),
          findPosH(e, t, n, r) { let i = 1; t < 0 && (i = -1, t = -t); for (var o = ft(this.doc, e), a = 0; a < t; ++a) if (o = Xs(this.doc, o, i, n, r), o.hitSide) break; return o; },
          moveH: Ei((function (e, t) { const n = this; this.extendSelectionsBy(((r) => (n.display.shift || n.doc.extend || r.empty() ? Xs(n.doc, r.head, e, t, n.options.rtlMoveVisually) : e < 0 ? r.from() : r.to())), V); })),
          deleteH: Ei((function (e, t) { const n = this.doc.sel; const r = this.doc; n.somethingSelected() ? r.replaceSelection('', null, '+delete') : Va(this, ((n) => { const i = Xs(r, n.head, e, t, !1); return e < 0 ? { from: i, to: n.head } : { from: n.head, to: i }; })); })),
          findPosV(e, t, n, r) { let i = 1; let o = r; t < 0 && (i = -1, t = -t); for (var a = ft(this.doc, e), s = 0; s < t; ++s) { const l = br(this, a, 'div'); if (o == null ? o = l.left : l.left = o, a = Ys(this, l, i, n), a.hitSide) break; } return a; },
          moveV: Ei((function (e, t) { const n = this; const r = this.doc; const i = []; const o = !this.display.shift && !r.extend && r.sel.somethingSelected(); if (r.extendSelectionsBy(((a) => { if (o) return e < 0 ? a.from() : a.to(); const s = br(n, a.head, 'div'); a.goalColumn != null && (s.left = a.goalColumn), i.push(s.left); const l = Ys(n, s, e, t); return t == 'page' && a == r.sel.primary() && oi(n, vr(n, l, 'div').top - s.top), l; }), V), i.length) for (let a = 0; a < r.sel.ranges.length; a++)r.sel.ranges[a].goalColumn = i[a]; })),
          findWordAt(e) { const t = this.doc; const n = Ye(t, e.line).text; let r = e.ch; let i = e.ch; if (n) { const o = this.getHelper(e, 'wordChars'); e.sticky != 'before' && i != n.length || !r ? ++i : --r; const a = n.charAt(r); const s = ne(a, o) ? function (e) { return ne(e, o); } : /\s/.test(a) ? function (e) { return /\s/.test(e); } : function (e) { return !/\s/.test(e) && !ne(e); }; while (r > 0 && s(n.charAt(r - 1)))--r; while (i < n.length && s(n.charAt(i)))++i; } return new io(it(e.line, r), it(e.line, i)); },
          toggleOverwrite(e) { e != null && e == this.state.overwrite || ((this.state.overwrite = !this.state.overwrite) ? P(this.display.cursorDiv, 'CodeMirror-overwrite') : O(this.display.cursorDiv, 'CodeMirror-overwrite'), ve(this, 'overwriteToggle', this, this.state.overwrite)); },
          hasFocus() { return this.display.input.getField() == E(); },
          isReadOnly() { return !(!this.options.readOnly && !this.doc.cantEdit); },
          scrollTo: Ei((function (e, t) { si(this, e, t); })),
          getScrollInfo() {
            const e = this.display.scroller; return {
              left: e.scrollLeft, top: e.scrollTop, height: e.scrollHeight - Gn(this) - this.display.barHeight, width: e.scrollWidth - Gn(this) - this.display.barWidth, clientHeight: Xn(this), clientWidth: Kn(this),
            };
          },
          scrollIntoView: Ei((function (e, t) { e == null ? (e = { from: this.doc.sel.primary().head, to: null }, t == null && (t = this.options.cursorScrollMargin)) : typeof e === 'number' ? e = { from: it(e, 0), to: null } : e.from == null && (e = { from: e, to: null }), e.to || (e.to = e.from), e.margin = t || 0, e.from.line != null ? li(this, e) : ui(this, e.from, e.to, e.margin); })),
          setSize: Ei((function (e, t) { const n = this; const r = function (e) { return typeof e === 'number' || /^\d+$/.test(String(e)) ? `${e}px` : e; }; e != null && (this.display.wrapper.style.width = r(e)), t != null && (this.display.wrapper.style.height = r(t)), this.options.lineWrapping && ur(this); let i = this.display.viewFrom; this.doc.iter(i, this.display.viewTo, ((e) => { if (e.widgets) for (let t = 0; t < e.widgets.length; t++) if (e.widgets[t].noHScroll) { zr(n, i, 'widget'); break; }++i; })), this.curOp.forceUpdate = !0, ve(this, 'refresh', this); })),
          operation(e) { return Mi(this, e); },
          startOperation() { return ki(this); },
          endOperation() { return _i(this); },
          refresh: Ei((function () { const e = this.display.cachedTextHeight; Fr(this), this.curOp.forceUpdate = !0, fr(this), si(this, this.doc.scrollLeft, this.doc.scrollTop), $i(this.display), (e == null || Math.abs(e - Lr(this.display)) > 0.5 || this.options.lineWrapping) && Pr(this), ve(this, 'refresh', this); })),
          swapDoc: Ei((function (e) { const t = this.doc; return t.cm = null, this.state.selectingText && this.state.selectingText(), bo(this, e), fr(this), this.display.input.reset(), si(this, e.scrollLeft, e.scrollTop), this.curOp.forceScroll = !0, Ln(this, 'swapDoc', this, t), t; })),
          phrase(e) { const t = this.options.phrases; return t && Object.prototype.hasOwnProperty.call(t, e) ? t[e] : e; },
          getInputField() { return this.display.input.getField(); },
          getWrapperElement() { return this.display.wrapper; },
          getScrollerElement() { return this.display.scroller; },
          getGutterElement() { return this.display.gutters; },
        }, xe(e), e.registerHelper = function (t, r, i) { n.hasOwnProperty(t) || (n[t] = e[t] = { _global: [] }), n[t][r] = i; }, e.registerGlobalHelper = function (t, r, i, o) { e.registerHelper(t, r, o), n[t]._global.push({ pred: i, val: o }); };
      } function Xs(e, t, n, r, i) { const o = t; const a = n; let s = Ye(e, t.line); const l = i && e.direction == 'rtl' ? -n : n; function c() { const n = t.line + l; return !(n < e.first || n >= e.first + e.size) && (t = new it(n, t.ch, t.sticky), s = Ye(e, n)); } function u(o) { let a; if (r == 'codepoint') { const u = s.text.charCodeAt(t.ch + (n > 0 ? 0 : -1)); if (isNaN(u))a = null; else { const f = n > 0 ? u >= 55296 && u < 56320 : u >= 56320 && u < 57343; a = new it(t.line, Math.max(0, Math.min(s.text.length, t.ch + n * (f ? 2 : 1))), -n); } } else a = i ? Xa(e.cm, s, t, n) : Ga(s, t, n); if (a == null) { if (o || !c()) return !1; t = Ka(i, e.cm, s, t.line, l); } else t = a; return !0; } if (r == 'char' || r == 'codepoint')u(); else if (r == 'column')u(!0); else if (r == 'word' || r == 'group') for (let f = null, d = r == 'group', h = e.cm && e.cm.getHelper(t, 'wordChars'), p = !0; ;p = !1) { if (n < 0 && !u(!p)) break; const m = s.text.charAt(t.ch) || '\n'; let g = ne(m, h) ? 'w' : d && m == '\n' ? 'n' : !d || /\s/.test(m) ? null : 'p'; if (!d || p || g || (g = 's'), f && f != g) { n < 0 && (n = 1, u(), t.sticky = 'after'); break; } if (g && (f = g), n > 0 && !u(!p)) break; } const v = Go(e, t, o, a, !0); return at(o, v) && (v.hitSide = !0), v; } function Ys(e, t, n, r) { let i; let o; const a = e.doc; const s = t.left; if (r == 'page') { const l = Math.min(e.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight); const c = Math.max(l - 0.5 * Lr(e.display), 3); i = (n > 0 ? t.bottom : t.top) + n * c; } else r == 'line' && (i = n > 0 ? t.bottom + 3 : t.top - 3); for (;;) { if (o = xr(e, s, i), !o.outside) break; if (n < 0 ? i <= 0 : i >= a.height) { o.hitSide = !0; break; }i += 5 * n; } return o; } const Zs = function (e) { this.cm = e, this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null, this.polling = new B(), this.composing = null, this.gracePeriod = !1, this.readDOMTimeout = null; }; function Js(e, t) { const n = er(e, t.line); if (!n || n.hidden) return null; const r = Ye(e.doc, t.line); const i = Zn(n, r, t.line); const o = de(r, e.doc.direction); let a = 'left'; if (o) { const s = ue(o, t.ch); a = s % 2 ? 'right' : 'left'; } const l = or(i.map, t.ch, a); return l.offset = l.collapse == 'right' ? l.end : l.start, l; } function Qs(e) { for (let t = e; t; t = t.parentNode) if (/CodeMirror-gutter-wrapper/.test(t.className)) return !0; return !1; } function el(e, t) { return t && (e.bad = !0), e; } function tl(e, t, n, r, i) { let o = ''; let a = !1; const s = e.doc.lineSeparator(); let l = !1; function c(e) { return function (t) { return t.id == e; }; } function u() { a && (o += s, l && (o += s), a = l = !1); } function f(e) { e && (u(), o += e); } function d(t) { if (t.nodeType == 1) { const n = t.getAttribute('cm-text'); if (n) return void f(n); let o; const h = t.getAttribute('cm-marker'); if (h) { const p = e.findMarks(it(r, 0), it(i + 1, 0), c(+h)); return void (p.length && (o = p[0].find(0)) && f(Ze(e.doc, o.from, o.to).join(s))); } if (t.getAttribute('contenteditable') == 'false') return; const m = /^(pre|div|p|li|table|br)$/i.test(t.nodeName); if (!/^br$/i.test(t.nodeName) && t.textContent.length == 0) return; m && u(); for (let g = 0; g < t.childNodes.length; g++)d(t.childNodes[g]); /^(pre|p)$/i.test(t.nodeName) && (l = !0), m && (a = !0); } else t.nodeType == 3 && f(t.nodeValue.replace(/\u200b/g, '').replace(/\u00a0/g, ' ')); } for (;;) { if (d(t), t == n) break; t = t.nextSibling, l = !1; } return o; } function nl(e, t, n) { let r; if (t == e.display.lineDiv) { if (r = e.display.lineDiv.childNodes[n], !r) return el(e.clipPos(it(e.display.viewTo - 1)), !0); t = null, n = 0; } else for (r = t; ;r = r.parentNode) { if (!r || r == e.display.lineDiv) return null; if (r.parentNode && r.parentNode == e.display.lineDiv) break; } for (let i = 0; i < e.display.view.length; i++) { const o = e.display.view[i]; if (o.node == r) return rl(o, t, n); } } function rl(e, t, n) { const r = e.text.firstChild; let i = !1; if (!t || !A(r, t)) return el(it(et(e.line), 0), !0); if (t == r && (i = !0, t = r.childNodes[n], n = 0, !t)) { const o = e.rest ? X(e.rest) : e.line; return el(it(et(o), o.text.length), i); } let a = t.nodeType == 3 ? t : null; let s = t; a || t.childNodes.length != 1 || t.firstChild.nodeType != 3 || (a = t.firstChild, n && (n = a.nodeValue.length)); while (s.parentNode != r)s = s.parentNode; const l = e.measure; const c = l.maps; function u(t, n, r) { for (let i = -1; i < (c ? c.length : 0); i++) for (let o = i < 0 ? l.map : c[i], a = 0; a < o.length; a += 3) { const s = o[a + 2]; if (s == t || s == n) { const u = et(i < 0 ? e.line : e.rest[i]); let f = o[a] + r; return (r < 0 || s != t) && (f = o[a + (r ? 1 : 0)]), it(u, f); } } } let f = u(a, s, n); if (f) return el(f, i); for (let d = s.nextSibling, h = a ? a.nodeValue.length - n : 0; d; d = d.nextSibling) { if (f = u(d, d.firstChild, 0), f) return el(it(f.line, f.ch - h), i); h += d.textContent.length; } for (let p = s.previousSibling, m = n; p; p = p.previousSibling) { if (f = u(p, p.firstChild, -1), f) return el(it(f.line, f.ch + m), i); m += p.textContent.length; } }Zs.prototype.init = function (e) { const t = this; const n = this; const r = n.cm; const i = n.div = e.lineDiv; function o(e) { for (let t = e.target; t; t = t.parentNode) { if (t == i) return !0; if (/\bCodeMirror-(?:line)?widget\b/.test(t.className)) break; } return !1; } function a(e) { if (o(e) && !be(r, e)) { if (r.somethingSelected())Rs({ lineWise: !1, text: r.getSelections() }), e.type == 'cut' && r.replaceSelection('', null, 'cut'); else { if (!r.options.lineWiseCopyCut) return; const t = Vs(r); Rs({ lineWise: !0, text: t.text }), e.type == 'cut' && r.operation((() => { r.setSelections(t.ranges, 0, q), r.replaceSelection('', null, 'cut'); })); } if (e.clipboardData) { e.clipboardData.clearData(); const a = Hs.text.join('\n'); if (e.clipboardData.setData('Text', a), e.clipboardData.getData('Text') == a) return void e.preventDefault(); } const s = Gs(); const l = s.firstChild; r.display.lineSpace.insertBefore(s, r.display.lineSpace.firstChild), l.value = Hs.text.join('\n'); const c = E(); N(l), setTimeout((() => { r.display.lineSpace.removeChild(s), c.focus(), c == i && n.showPrimarySelection(); }), 50); } }i.contentEditable = !0, Us(i, r.options.spellcheck, r.options.autocorrect, r.options.autocapitalize), pe(i, 'paste', ((e) => { !o(e) || be(r, e) || qs(e, r) || s <= 11 && setTimeout(Ai(r, (() => t.updateFromDOM())), 20); })), pe(i, 'compositionstart', ((e) => { t.composing = { data: e.data, done: !1 }; })), pe(i, 'compositionupdate', ((e) => { t.composing || (t.composing = { data: e.data, done: !1 }); })), pe(i, 'compositionend', ((e) => { t.composing && (e.data != t.composing.data && t.readFromDOMSoon(), t.composing.done = !0); })), pe(i, 'touchstart', (() => n.forceCompositionEnd())), pe(i, 'input', (() => { t.composing || t.readFromDOMSoon(); })), pe(i, 'copy', a), pe(i, 'cut', a); }, Zs.prototype.screenReaderLabelChanged = function (e) { e ? this.div.setAttribute('aria-label', e) : this.div.removeAttribute('aria-label'); }, Zs.prototype.prepareSelection = function () { const e = qr(this.cm, !1); return e.focus = E() == this.div, e; }, Zs.prototype.showSelection = function (e, t) { e && this.cm.display.view.length && ((e.focus || t) && this.showPrimarySelection(), this.showMultipleSelections(e)); }, Zs.prototype.getSelection = function () { return this.cm.display.wrapper.ownerDocument.getSelection(); }, Zs.prototype.showPrimarySelection = function () { const e = this.getSelection(); const t = this.cm; const r = t.doc.sel.primary(); const i = r.from(); const o = r.to(); if (t.display.viewTo == t.display.viewFrom || i.line >= t.display.viewTo || o.line < t.display.viewFrom)e.removeAllRanges(); else { const a = nl(t, e.anchorNode, e.anchorOffset); const s = nl(t, e.focusNode, e.focusOffset); if (!a || a.bad || !s || s.bad || ot(ct(a, s), i) != 0 || ot(lt(a, s), o) != 0) { const l = t.display.view; const c = i.line >= t.display.viewFrom && Js(t, i) || { node: l[0].measure.map[2], offset: 0 }; let u = o.line < t.display.viewTo && Js(t, o); if (!u) { const f = l[l.length - 1].measure; const d = f.maps ? f.maps[f.maps.length - 1] : f.map; u = { node: d[d.length - 1], offset: d[d.length - 2] - d[d.length - 3] }; } if (c && u) { let h; const p = e.rangeCount && e.getRangeAt(0); try { h = S(c.node, c.offset, u.offset, u.node); } catch (m) {}h && (!n && t.state.focused ? (e.collapse(c.node, c.offset), h.collapsed || (e.removeAllRanges(), e.addRange(h))) : (e.removeAllRanges(), e.addRange(h)), p && e.anchorNode == null ? e.addRange(p) : n && this.startGracePeriod()), this.rememberSelection(); } else e.removeAllRanges(); } } }, Zs.prototype.startGracePeriod = function () { const e = this; clearTimeout(this.gracePeriod), this.gracePeriod = setTimeout((() => { e.gracePeriod = !1, e.selectionChanged() && e.cm.operation((() => e.cm.curOp.selectionChanged = !0)); }), 20); }, Zs.prototype.showMultipleSelections = function (e) { L(this.cm.display.cursorDiv, e.cursors), L(this.cm.display.selectionDiv, e.selection); }, Zs.prototype.rememberSelection = function () { const e = this.getSelection(); this.lastAnchorNode = e.anchorNode, this.lastAnchorOffset = e.anchorOffset, this.lastFocusNode = e.focusNode, this.lastFocusOffset = e.focusOffset; }, Zs.prototype.selectionInEditor = function () { const e = this.getSelection(); if (!e.rangeCount) return !1; const t = e.getRangeAt(0).commonAncestorContainer; return A(this.div, t); }, Zs.prototype.focus = function () { this.cm.options.readOnly != 'nocursor' && (this.selectionInEditor() && E() == this.div || this.showSelection(this.prepareSelection(), !0), this.div.focus()); }, Zs.prototype.blur = function () { this.div.blur(); }, Zs.prototype.getField = function () { return this.div; }, Zs.prototype.supportsTouch = function () { return !0; }, Zs.prototype.receivedFocus = function () { const e = this; function t() { e.cm.state.focused && (e.pollSelection(), e.polling.set(e.cm.options.pollInterval, t)); } this.selectionInEditor() ? this.pollSelection() : Mi(this.cm, (() => e.cm.curOp.selectionChanged = !0)), this.polling.set(this.cm.options.pollInterval, t); }, Zs.prototype.selectionChanged = function () { const e = this.getSelection(); return e.anchorNode != this.lastAnchorNode || e.anchorOffset != this.lastAnchorOffset || e.focusNode != this.lastFocusNode || e.focusOffset != this.lastFocusOffset; }, Zs.prototype.pollSelection = function () { if (this.readDOMTimeout == null && !this.gracePeriod && this.selectionChanged()) { const e = this.getSelection(); const t = this.cm; if (g && u && this.cm.display.gutterSpecs.length && Qs(e.anchorNode)) return this.cm.triggerOnKeyDown({ type: 'keydown', keyCode: 8, preventDefault: Math.abs }), this.blur(), void this.focus(); if (!this.composing) { this.rememberSelection(); const n = nl(t, e.anchorNode, e.anchorOffset); const r = nl(t, e.focusNode, e.focusOffset); n && r && Mi(t, (() => { Ro(t.doc, ao(n, r), q), (n.bad || r.bad) && (t.curOp.selectionChanged = !0); })); } } }, Zs.prototype.pollContent = function () { this.readDOMTimeout != null && (clearTimeout(this.readDOMTimeout), this.readDOMTimeout = null); let e; let t; let n; const r = this.cm; const i = r.display; const o = r.doc.sel.primary(); let a = o.from(); let s = o.to(); if (a.ch == 0 && a.line > r.firstLine() && (a = it(a.line - 1, Ye(r.doc, a.line - 1).length)), s.ch == Ye(r.doc, s.line).text.length && s.line < r.lastLine() && (s = it(s.line + 1, 0)), a.line < i.viewFrom || s.line > i.viewTo - 1) return !1; a.line == i.viewFrom || (e = Nr(r, a.line)) == 0 ? (t = et(i.view[0].line), n = i.view[0].node) : (t = et(i.view[e].line), n = i.view[e - 1].node.nextSibling); let l; let c; const u = Nr(r, s.line); if (u == i.view.length - 1 ? (l = i.viewTo - 1, c = i.lineDiv.lastChild) : (l = et(i.view[u + 1].line) - 1, c = i.view[u + 1].node.previousSibling), !n) return !1; const f = r.doc.splitLines(tl(r, n, c, t, l)); const d = Ze(r.doc, it(t, 0), it(l, Ye(r.doc, l).text.length)); while (f.length > 1 && d.length > 1) if (X(f) == X(d))f.pop(), d.pop(), l--; else { if (f[0] != d[0]) break; f.shift(), d.shift(), t++; } let h = 0; let p = 0; const m = f[0]; const g = d[0]; const v = Math.min(m.length, g.length); while (h < v && m.charCodeAt(h) == g.charCodeAt(h))++h; const b = X(f); const y = X(d); const w = Math.min(b.length - (f.length == 1 ? h : 0), y.length - (d.length == 1 ? h : 0)); while (p < w && b.charCodeAt(b.length - p - 1) == y.charCodeAt(y.length - p - 1))++p; if (f.length == 1 && d.length == 1 && t == a.line) while (h && h > a.ch && b.charCodeAt(b.length - p - 1) == y.charCodeAt(y.length - p - 1))h--, p++; f[f.length - 1] = b.slice(0, b.length - p).replace(/^\u200b+/, ''), f[0] = f[0].slice(h).replace(/\u200b+$/, ''); const x = it(t, h); const k = it(l, d.length ? X(d).length - p : 0); return f.length > 1 || f[0] || ot(x, k) ? (ra(r.doc, f, x, k, '+input'), !0) : void 0; }, Zs.prototype.ensurePolled = function () { this.forceCompositionEnd(); }, Zs.prototype.reset = function () { this.forceCompositionEnd(); }, Zs.prototype.forceCompositionEnd = function () { this.composing && (clearTimeout(this.readDOMTimeout), this.composing = null, this.updateFromDOM(), this.div.blur(), this.div.focus()); }, Zs.prototype.readFromDOMSoon = function () { const e = this; this.readDOMTimeout == null && (this.readDOMTimeout = setTimeout((() => { if (e.readDOMTimeout = null, e.composing) { if (!e.composing.done) return; e.composing = null; }e.updateFromDOM(); }), 80)); }, Zs.prototype.updateFromDOM = function () { const e = this; !this.cm.isReadOnly() && this.pollContent() || Mi(this.cm, (() => Fr(e.cm))); }, Zs.prototype.setUneditable = function (e) { e.contentEditable = 'false'; }, Zs.prototype.onKeyPress = function (e) { e.charCode == 0 || this.composing || (e.preventDefault(), this.cm.isReadOnly() || Ai(this.cm, Ws)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0)); }, Zs.prototype.readOnlyChanged = function (e) { this.div.contentEditable = String(e != 'nocursor'); }, Zs.prototype.onContextMenu = function () {}, Zs.prototype.resetPosition = function () {}, Zs.prototype.needsContentAttribute = !0; const il = function (e) { this.cm = e, this.prevInput = '', this.pollingFast = !1, this.polling = new B(), this.hasSelection = !1, this.composing = null; }; function ol(e, t) { if (t = t ? z(t) : {}, t.value = e.value, !t.tabindex && e.tabIndex && (t.tabindex = e.tabIndex), !t.placeholder && e.placeholder && (t.placeholder = e.placeholder), t.autofocus == null) { const n = E(); t.autofocus = n == e || e.getAttribute('autofocus') != null && n == document.body; } function r() { e.value = s.getValue(); } let i; if (e.form && (pe(e.form, 'submit', r), !t.leaveSubmitMethodAlone)) { const o = e.form; i = o.submit; try { var a = o.submit = function () { r(), o.submit = i, o.submit(), o.submit = a; }; } catch (l) {} }t.finishInit = function (n) { n.save = r, n.getTextArea = function () { return e; }, n.toTextArea = function () { n.toTextArea = isNaN, r(), e.parentNode.removeChild(n.getWrapperElement()), e.style.display = '', e.form && (ge(e.form, 'submit', r), t.leaveSubmitMethodAlone || typeof e.form.submit !== 'function' || (e.form.submit = i)); }; }, e.style.display = 'none'; var s = Fs(((t) => e.parentNode.insertBefore(t, e.nextSibling)), t); return s; } function al(e) { e.off = ge, e.on = pe, e.wheelEventPixels = to, e.Doc = ka, e.splitLines = Pe, e.countColumn = I, e.findColumn = U, e.isWordChar = te, e.Pass = W, e.signal = ve, e.Line = ln, e.changeEnd = so, e.scrollbarModel = yi, e.Pos = it, e.cmpPos = ot, e.modes = Ie, e.mimeModes = Be, e.resolveMode = We, e.getMode = qe, e.modeExtensions = $e, e.extendMode = Ve, e.copyState = Ue, e.startState = Ke, e.innerMode = Ge, e.commands = Ya, e.keyMap = za, e.keyName = qa, e.isModifierKey = Ra, e.lookupKey = Ha, e.normalizeKeyMap = Ba, e.StringStream = Xe, e.SharedTextMarker = ga, e.TextMarker = pa, e.LineWidget = ua, e.e_preventDefault = ke, e.e_stopPropagation = _e, e.e_stop = Se, e.addClass = P, e.contains = A, e.rmClass = O, e.keyNames = Pa; }il.prototype.init = function (e) { const t = this; const n = this; const r = this.cm; this.createField(e); const i = this.textarea; function o(e) { if (!be(r, e)) { if (r.somethingSelected())Rs({ lineWise: !1, text: r.getSelections() }); else { if (!r.options.lineWiseCopyCut) return; const t = Vs(r); Rs({ lineWise: !0, text: t.text }), e.type == 'cut' ? r.setSelections(t.ranges, null, q) : (n.prevInput = '', i.value = t.text.join('\n'), N(i)); }e.type == 'cut' && (r.state.cutIncoming = +new Date()); } }e.wrapper.insertBefore(this.wrapper, e.wrapper.firstChild), m && (i.style.width = '0px'), pe(i, 'input', (() => { a && s >= 9 && t.hasSelection && (t.hasSelection = null), n.poll(); })), pe(i, 'paste', ((e) => { be(r, e) || qs(e, r) || (r.state.pasteIncoming = +new Date(), n.fastPoll()); })), pe(i, 'cut', o), pe(i, 'copy', o), pe(e.scroller, 'paste', ((t) => { if (!qn(e, t) && !be(r, t)) { if (!i.dispatchEvent) return r.state.pasteIncoming = +new Date(), void n.focus(); const o = new Event('paste'); o.clipboardData = t.clipboardData, i.dispatchEvent(o); } })), pe(e.lineSpace, 'selectstart', ((t) => { qn(e, t) || ke(t); })), pe(i, 'compositionstart', (() => { const e = r.getCursor('from'); n.composing && n.composing.range.clear(), n.composing = { start: e, range: r.markText(e, r.getCursor('to'), { className: 'CodeMirror-composing' }) }; })), pe(i, 'compositionend', (() => { n.composing && (n.poll(), n.composing.range.clear(), n.composing = null); })); }, il.prototype.createField = function (e) { this.wrapper = Gs(), this.textarea = this.wrapper.firstChild; }, il.prototype.screenReaderLabelChanged = function (e) { e ? this.textarea.setAttribute('aria-label', e) : this.textarea.removeAttribute('aria-label'); }, il.prototype.prepareSelection = function () { const e = this.cm; const t = e.display; const n = e.doc; const r = qr(e); if (e.options.moveInputWithCursor) { const i = br(e, n.sel.primary().head, 'div'); const o = t.wrapper.getBoundingClientRect(); const a = t.lineDiv.getBoundingClientRect(); r.teTop = Math.max(0, Math.min(t.wrapper.clientHeight - 10, i.top + a.top - o.top)), r.teLeft = Math.max(0, Math.min(t.wrapper.clientWidth - 10, i.left + a.left - o.left)); } return r; }, il.prototype.showSelection = function (e) { const t = this.cm; const n = t.display; L(n.cursorDiv, e.cursors), L(n.selectionDiv, e.selection), e.teTop != null && (this.wrapper.style.top = `${e.teTop}px`, this.wrapper.style.left = `${e.teLeft}px`); }, il.prototype.reset = function (e) { if (!this.contextMenuPending && !this.composing) { const t = this.cm; if (t.somethingSelected()) { this.prevInput = ''; const n = t.getSelection(); this.textarea.value = n, t.state.focused && N(this.textarea), a && s >= 9 && (this.hasSelection = n); } else e || (this.prevInput = this.textarea.value = '', a && s >= 9 && (this.hasSelection = null)); } }, il.prototype.getField = function () { return this.textarea; }, il.prototype.supportsTouch = function () { return !1; }, il.prototype.focus = function () { if (this.cm.options.readOnly != 'nocursor' && (!v || E() != this.textarea)) try { this.textarea.focus(); } catch (e) {} }, il.prototype.blur = function () { this.textarea.blur(); }, il.prototype.resetPosition = function () { this.wrapper.style.top = this.wrapper.style.left = 0; }, il.prototype.receivedFocus = function () { this.slowPoll(); }, il.prototype.slowPoll = function () { const e = this; this.pollingFast || this.polling.set(this.cm.options.pollInterval, (() => { e.poll(), e.cm.state.focused && e.slowPoll(); })); }, il.prototype.fastPoll = function () { let e = !1; const t = this; function n() { const r = t.poll(); r || e ? (t.pollingFast = !1, t.slowPoll()) : (e = !0, t.polling.set(60, n)); }t.pollingFast = !0, t.polling.set(20, n); }, il.prototype.poll = function () { const e = this; const t = this.cm; const n = this.textarea; let r = this.prevInput; if (this.contextMenuPending || !t.state.focused || De(n) && !r && !this.composing || t.isReadOnly() || t.options.disableInput || t.state.keySeq) return !1; const i = n.value; if (i == r && !t.somethingSelected()) return !1; if (a && s >= 9 && this.hasSelection === i || b && /[\uf700-\uf7ff]/.test(i)) return t.display.input.reset(), !1; if (t.doc.sel == t.display.selForContextMenu) { const o = i.charCodeAt(0); if (o != 8203 || r || (r = '​'), o == 8666) return this.reset(), this.cm.execCommand('undo'); } let l = 0; const c = Math.min(r.length, i.length); while (l < c && r.charCodeAt(l) == i.charCodeAt(l))++l; return Mi(t, (() => { Ws(t, i.slice(l), r.length - l, null, e.composing ? '*compose' : null), i.length > 1e3 || i.indexOf('\n') > -1 ? n.value = e.prevInput = '' : e.prevInput = i, e.composing && (e.composing.range.clear(), e.composing.range = t.markText(e.composing.start, t.getCursor('to'), { className: 'CodeMirror-composing' })); })), !0; }, il.prototype.ensurePolled = function () { this.pollingFast && this.poll() && (this.pollingFast = !1); }, il.prototype.onKeyPress = function () { a && s >= 9 && (this.hasSelection = null), this.fastPoll(); }, il.prototype.onContextMenu = function (e) { const t = this; const n = t.cm; const r = n.display; const i = t.textarea; t.contextMenuPending && t.contextMenuPending(); const o = Dr(n, e); const c = r.scroller.scrollTop; if (o && !f) { const u = n.options.resetSelectionOnContextMenu; u && n.doc.sel.contains(o) == -1 && Ai(n, Ro)(n.doc, ao(o), q); let d; var h = i.style.cssText; var p = t.wrapper.style.cssText; const m = t.wrapper.offsetParent.getBoundingClientRect(); if (t.wrapper.style.cssText = 'position: static', i.style.cssText = `position: absolute; width: 30px; height: 30px;\n      top: ${e.clientY - m.top - 5}px; left: ${e.clientX - m.left - 5}px;\n      z-index: 1000; background: ${a ? 'rgba(255, 255, 255, .05)' : 'transparent'};\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);`, l && (d = window.scrollY), r.input.focus(), l && window.scrollTo(null, d), r.input.reset(), n.somethingSelected() || (i.value = t.prevInput = ' '), t.contextMenuPending = b, r.selForContextMenu = n.doc.sel, clearTimeout(r.detectingSelectAll), a && s >= 9 && v(), _) { Se(e); var g = function () { ge(window, 'mouseup', g), setTimeout(b, 20); }; pe(window, 'mouseup', g); } else setTimeout(b, 50); } function v() { if (i.selectionStart != null) { const e = n.somethingSelected(); const o = `​${e ? i.value : ''}`; i.value = '⇚', i.value = o, t.prevInput = e ? '' : '​', i.selectionStart = 1, i.selectionEnd = o.length, r.selForContextMenu = n.doc.sel; } } function b() { if (t.contextMenuPending == b && (t.contextMenuPending = !1, t.wrapper.style.cssText = p, i.style.cssText = h, a && s < 9 && r.scrollbars.setScrollTop(r.scroller.scrollTop = c), i.selectionStart != null)) { (!a || a && s < 9) && v(); let e = 0; var o = function () { r.selForContextMenu == n.doc.sel && i.selectionStart == 0 && i.selectionEnd > 0 && t.prevInput == '​' ? Ai(n, Xo)(n) : e++ < 10 ? r.detectingSelectAll = setTimeout(o, 500) : (r.selForContextMenu = null, r.input.reset()); }; r.detectingSelectAll = setTimeout(o, 200); } } }, il.prototype.readOnlyChanged = function (e) { e || this.reset(), this.textarea.disabled = e == 'nocursor', this.textarea.readOnly = !!e; }, il.prototype.setUneditable = function () {}, il.prototype.needsContentAttribute = !1, Ps(Fs), Ks(Fs); const sl = 'iter insert remove copy getEditor constructor'.split(' '); for (const ll in ka.prototype)ka.prototype.hasOwnProperty(ll) && H(sl, ll) < 0 && (Fs.prototype[ll] = (function (e) { return function () { return e.apply(this.doc, arguments); }; }(ka.prototype[ll]))); return xe(ka), Fs.inputStyles = { textarea: il, contenteditable: Zs }, Fs.defineMode = function (e) { Fs.defaults.mode || e == 'null' || (Fs.defaults.mode = e), He.apply(this, arguments); }, Fs.defineMIME = Re, Fs.defineMode('null', (() => ({ token(e) { return e.skipToEnd(); } }))), Fs.defineMIME('text/plain', 'null'), Fs.defineExtension = function (e, t) { Fs.prototype[e] = t; }, Fs.defineDocExtension = function (e, t) { ka.prototype[e] = t; }, Fs.fromTextArea = ol, al(Fs), Fs.version = '5.61.1', Fs;
    })));
  },
  '56ef': function (e, t, n) { const r = n('d066'); const i = n('241c'); const o = n('7418'); const a = n('825a'); e.exports = r('Reflect', 'ownKeys') || function (e) { const t = i.f(a(e)); const n = o.f; return n ? t.concat(n(e)) : t; }; },
  '5a25': function (e, t, n) {},
  '5c6c': function (e, t) {
    e.exports = function (e, t) {
      return {
        enumerable: !(1 & e), configurable: !(2 & e), writable: !(4 & e), value: t,
      };
    };
  },
  '605d': function (e, t, n) { const r = n('c6b6'); const i = n('da84'); e.exports = r(i.process) == 'process'; },
  6069(e, t) { e.exports = typeof window === 'object'; },
  '60da': function (e, t, n) {
    const r = n('83ab'); const i = n('d039'); const o = n('df75'); const a = n('7418'); const s = n('d1e7'); const l = n('7b0b'); const c = n('44ad'); const u = Object.assign; const f = Object.defineProperty; e.exports = !u || i((() => { if (r && ({ b: 1, ...u(f({}, 'a', { enumerable: !0, get() { f(this, 'b', { value: 3, enumerable: !1 }); } }), { b: 2 }) }).b !== 1) return !0; const e = {}; const t = {}; const n = Symbol(); const i = 'abcdefghijklmnopqrst'; return e[n] = 7, i.split('').forEach(((e) => { t[e] = e; })), ({ ...e })[n] != 7 || o({ ...t }).join('') != i; })) ? function (e, t) { const n = l(e); const i = arguments.length; let u = 1; const { f } = a; const d = s.f; while (i > u) { var h; const p = c(arguments[u++]); const m = f ? o(p).concat(f(p)) : o(p); const g = m.length; let v = 0; while (g > v)h = m[v++], r && !d.call(p, h) || (n[h] = p[h]); } return n; } : u;
  },
  6547(e, t, n) { const r = n('a691'); const i = n('1d80'); const o = function (e) { return function (t, n) { let o; let a; const s = String(i(t)); const l = r(n); const c = s.length; return l < 0 || l >= c ? e ? '' : void 0 : (o = s.charCodeAt(l), o < 55296 || o > 56319 || l + 1 === c || (a = s.charCodeAt(l + 1)) < 56320 || a > 57343 ? e ? s.charAt(l) : o : e ? s.slice(l, l + 2) : a - 56320 + (o - 55296 << 10) + 65536); }; }; e.exports = { codeAt: o(!1), charAt: o(!0) }; },
  '69f3': function (e, t, n) {
    let r; let i; let o; const a = n('7f9a'); const s = n('da84'); const l = n('861d'); const c = n('9112'); const u = n('5135'); const f = n('c6cd'); const d = n('f772'); const h = n('d012'); const p = 'Object already initialized'; const m = s.WeakMap; const g = function (e) { return o(e) ? i(e) : r(e, {}); }; const v = function (e) { return function (t) { let n; if (!l(t) || (n = i(t)).type !== e) throw TypeError(`Incompatible receiver, ${e} required`); return n; }; }; if (a || f.state) { const b = f.state || (f.state = new m()); const y = b.get; const w = b.has; const x = b.set; r = function (e, t) { if (w.call(b, e)) throw new TypeError(p); return t.facade = e, x.call(b, e, t), t; }, i = function (e) { return y.call(b, e) || {}; }, o = function (e) { return w.call(b, e); }; } else { const k = d('state'); h[k] = !0, r = function (e, t) { if (u(e, k)) throw new TypeError(p); return t.facade = e, c(e, k, t), t; }, i = function (e) { return u(e, k) ? e[k] : {}; }, o = function (e) { return u(e, k); }; }e.exports = {
      set: r, get: i, has: o, enforce: g, getterFor: v,
    };
  },
  '6a70': function (e, t, n) {},
  '6c02': function (e, t, n) {
    n.d(t, 'a', (() => Qe)), n.d(t, 'b', (() => $)); const r = n('7a23'); n('3f4e');
    /*!
  * vue-router v4.0.8
  * (c) 2021 Eduardo San Martin Morote
  * @license MIT
  */
    const i = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol'; const o = (e) => (i ? Symbol(e) : `_vr_${e}`); const a = o('rvlm'); const s = o('rvd'); const l = o('r'); const c = o('rl'); const u = o('rvl'); const f = typeof window !== 'undefined'; function d(e) { return e.__esModule || i && e[Symbol.toStringTag] === 'Module'; } const h = Object.assign; function p(e, t) { const n = {}; for (const r in t) { const i = t[r]; n[r] = Array.isArray(i) ? i.map(e) : e(i); } return n; } const m = () => {}; const g = /\/$/; const v = (e) => e.replace(g, ''); function b(e, t, n = '/') {
      let r; let i = {}; let o = ''; let a = ''; const s = t.indexOf('?'); const l = t.indexOf('#', s > -1 ? s : 0); return s > -1 && (r = t.slice(0, s), o = t.slice(s + 1, l > -1 ? l : t.length), i = e(o)), l > -1 && (r = r || t.slice(0, l), a = t.slice(l, t.length)), r = O(r != null ? r : t, n), {
        fullPath: r + (o && '?') + o + a, path: r, query: i, hash: a,
      };
    } function y(e, t) { const n = t.query ? e(t.query) : ''; return t.path + (n && '?') + n + (t.hash || ''); } function w(e, t) { return !t || e.toLowerCase().indexOf(t.toLowerCase()) ? e : e.slice(t.length) || '/'; } function x(e, t, n) { const r = t.matched.length - 1; const i = n.matched.length - 1; return r > -1 && r === i && k(t.matched[r], n.matched[i]) && _(t.params, n.params) && e(t.query) === e(n.query) && t.hash === n.hash; } function k(e, t) { return (e.aliasOf || e) === (t.aliasOf || t); } function _(e, t) { if (Object.keys(e).length !== Object.keys(t).length) return !1; for (const n in e) if (!C(e[n], t[n])) return !1; return !0; } function C(e, t) { return Array.isArray(e) ? S(e, t) : Array.isArray(t) ? S(t, e) : e === t; } function S(e, t) { return Array.isArray(t) ? e.length === t.length && e.every((e, n) => e === t[n]) : e.length === 1 && e[0] === t; } function O(e, t) { if (e.startsWith('/')) return e; if (!e) return t; const n = t.split('/'); const r = e.split('/'); let i; let o; let a = n.length - 1; for (i = 0; i < r.length; i++) if (o = r[i], a !== 1 && o !== '.') { if (o !== '..') break; a--; } return `${n.slice(0, a).join('/')}/${r.slice(i - (i === r.length ? 1 : 0)).join('/')}`; } let j; let L; (function (e) { e.pop = 'pop', e.push = 'push'; }(j || (j = {}))), (function (e) { e.back = 'back', e.forward = 'forward', e.unknown = ''; }(L || (L = {}))); function T(e) { if (!e) if (f) { const t = document.querySelector('base'); e = t && t.getAttribute('href') || '/', e = e.replace(/^\w+:\/\/[^\/]+/, ''); } else e = '/'; return e[0] !== '/' && e[0] !== '#' && (e = `/${e}`), v(e); } const M = /^[^#]+#/; function A(e, t) { return e.replace(M, '#') + t; } function E(e, t) { const n = document.documentElement.getBoundingClientRect(); const r = e.getBoundingClientRect(); return { behavior: t.behavior, left: r.left - n.left - (t.left || 0), top: r.top - n.top - (t.top || 0) }; } const P = () => ({ left: window.pageXOffset, top: window.pageYOffset }); function D(e) { let t; if ('el' in e) { const n = e.el; const r = typeof n === 'string' && n.startsWith('#'); 0; const i = typeof n === 'string' ? r ? document.getElementById(n.slice(1)) : document.querySelector(n) : n; if (!i) return; t = E(i, e); } else t = e; 'scrollBehavior' in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(t.left != null ? t.left : window.pageXOffset, t.top != null ? t.top : window.pageYOffset); } function N(e, t) { const n = history.state ? history.state.position - t : -1; return n + e; } const F = new Map(); function z(e, t) { F.set(e, t); } function I(e) { const t = F.get(e); return F.delete(e), t; } const B = () => `${location.protocol}//${location.host}`; function H(e, t) { const { pathname: n, search: r, hash: i } = t; const o = e.indexOf('#'); if (o > -1) { const t = i.includes(e.slice(o)) ? e.slice(o).length : 1; let n = i.slice(t); return n[0] !== '/' && (n = `/${n}`), w(n, ''); } const a = w(n, e); return a + r + i; } function R(e, t, n, r) { const i = []; let o = []; let a = null; const s = ({ state: o }) => { const s = H(e, location); const l = n.value; const c = t.value; let u = 0; if (o) { if (n.value = s, t.value = o, a && a === l) return void (a = null); u = c ? o.position - c.position : 0; } else r(s); i.forEach((e) => { e(n.value, l, { delta: u, type: j.pop, direction: u ? u > 0 ? L.forward : L.back : L.unknown }); }); }; function l() { a = n.value; } function c(e) { i.push(e); const t = () => { const t = i.indexOf(e); t > -1 && i.splice(t, 1); }; return o.push(t), t; } function u() { const { history: e } = window; e.state && e.replaceState({ ...e.state, scroll: P() }, ''); } function f() { for (const e of o)e(); o = [], window.removeEventListener('popstate', s), window.removeEventListener('beforeunload', u); } return window.addEventListener('popstate', s), window.addEventListener('beforeunload', u), { pauseListeners: l, listen: c, destroy: f }; } function W(e, t, n, r = !1, i = !1) {
      return {
        back: e, current: t, forward: n, replaced: r, position: window.history.length, scroll: i ? P() : null,
      };
    } function q(e) {
      const { history: t, location: n } = window; const r = { value: H(e, n) }; const i = { value: t.state }; function o(r, o, a) { const s = e.indexOf('#'); const l = s > -1 ? (n.host && document.querySelector('base') ? e : e.slice(s)) + r : B() + e + r; try { t[a ? 'replaceState' : 'pushState'](o, '', l), i.value = o; } catch (c) { console.error(c), n[a ? 'replace' : 'assign'](l); } } function a(e, n) {
        const a = {
          ...t.state, ...W(i.value.back, e, i.value.forward, !0), ...n, position: i.value.position,
        }; o(e, a, !0), r.value = e;
      } function s(e, n) {
        const a = {
          ...i.value, ...t.state, forward: e, scroll: P(),
        }; o(a.current, a, !0); const s = { ...W(r.value, e, null), position: a.position + 1, ...n }; o(e, s, !1), r.value = e;
      } return i.value || o(r.value, {
        back: null, current: r.value, forward: null, position: t.length - 1, replaced: !0, scroll: null,
      }, !0), {
        location: r, state: i, push: s, replace: a,
      };
    } function $(e) {
      e = T(e); const t = q(e); const n = R(e, t.state, t.location, t.replace); function r(e, t = !0) { t || n.pauseListeners(), history.go(e); } const i = {
        location: '', base: e, go: r, createHref: A.bind(null, e), ...t, ...n,
      }; return Object.defineProperty(i, 'location', { enumerable: !0, get: () => t.location.value }), Object.defineProperty(i, 'state', { enumerable: !0, get: () => t.state.value }), i;
    } function V(e) { return typeof e === 'string' || e && typeof e === 'object'; } function U(e) { return typeof e === 'string' || typeof e === 'symbol'; } const G = {
      path: '/', name: void 0, params: {}, query: {}, hash: '', fullPath: '/', matched: [], meta: {}, redirectedFrom: void 0,
    }; const K = o('nf'); let X; (function (e) { e[e.aborted = 4] = 'aborted', e[e.cancelled = 8] = 'cancelled', e[e.duplicated = 16] = 'duplicated'; }(X || (X = {}))); function Y(e, t) { return h(new Error(), { type: e, [K]: !0 }, t); } function Z(e, t) { return e instanceof Error && K in e && (t == null || !!(e.type & t)); } const J = '[^/]+?'; const Q = {
      sensitive: !1, strict: !1, start: !0, end: !0,
    }; const ee = /[.+*?^${}()[\]/\\]/g; function te(e, t) {
      const n = { ...Q, ...t }; const r = []; let i = n.start ? '^' : ''; const o = []; for (const u of e) {
        const e = u.length ? [] : [90]; n.strict && !u.length && (i += '/'); for (let t = 0; t < u.length; t++) {
          const r = u[t]; let a = 40 + (n.sensitive ? 0.25 : 0); if (r.type === 0)t || (i += '/'), i += r.value.replace(ee, '\\$&'), a += 40; else if (r.type === 1) {
            const {
              value: e, repeatable: n, optional: s, regexp: l,
            } = r; o.push({ name: e, repeatable: n, optional: s }); const f = l || J; if (f !== J) { a += 10; try { new RegExp(`(${f})`); } catch (c) { throw new Error(`Invalid custom RegExp for param "${e}" (${f}): ${c.message}`); } }let d = n ? `((?:${f})(?:/(?:${f}))*)` : `(${f})`; t || (d = s && u.length < 2 ? `(?:/${d})` : `/${d}`), s && (d += '?'), i += d, a += 20, s && (a += -8), n && (a += -20), f === '.*' && (a += -50);
          }e.push(a);
        }r.push(e);
      } if (n.strict && n.end) { const e = r.length - 1; r[e][r[e].length - 1] += 0.7000000000000001; }n.strict || (i += '/?'), n.end ? i += '$' : n.strict && (i += '(?:/|$)'); const a = new RegExp(i, n.sensitive ? '' : 'i'); function s(e) { const t = e.match(a); const n = {}; if (!t) return null; for (let r = 1; r < t.length; r++) { const e = t[r] || ''; const i = o[r - 1]; n[i.name] = e && i.repeatable ? e.split('/') : e; } return n; } function l(t) { let n = ''; let r = !1; for (const i of e) { r && n.endsWith('/') || (n += '/'), r = !1; for (const e of i) if (e.type === 0)n += e.value; else if (e.type === 1) { const { value: o, repeatable: a, optional: s } = e; const l = o in t ? t[o] : ''; if (Array.isArray(l) && !a) throw new Error(`Provided param "${o}" is an array but it is not repeatable (* or + modifiers)`); const c = Array.isArray(l) ? l.join('/') : l; if (!c) { if (!s) throw new Error(`Missing required param "${o}"`); i.length < 2 && (n.endsWith('/') ? n = n.slice(0, -1) : r = !0); }n += c; } } return n; } return {
        re: a, score: r, keys: o, parse: s, stringify: l,
      };
    } function ne(e, t) { let n = 0; while (n < e.length && n < t.length) { const r = t[n] - e[n]; if (r) return r; n++; } return e.length < t.length ? e.length === 1 && e[0] === 80 ? -1 : 1 : e.length > t.length ? t.length === 1 && t[0] === 80 ? 1 : -1 : 0; } function re(e, t) { let n = 0; const r = e.score; const i = t.score; while (n < r.length && n < i.length) { const e = ne(r[n], i[n]); if (e) return e; n++; } return i.length - r.length; } const ie = { type: 0, value: '' }; const oe = /[a-zA-Z0-9_]/; function ae(e) {
      if (!e) return [[]]; if (e === '/') return [[ie]]; if (!e.startsWith('/')) throw new Error(`Invalid path "${e}"`); function t(e) { throw new Error(`ERR (${n})/"${c}": ${e}`); }let n = 0; let r = n; const i = []; let o; function a() { o && i.push(o), o = []; }let s; let l = 0; let c = ''; let u = ''; function f() {
        c && (n === 0 ? o.push({ type: 0, value: c }) : n === 1 || n === 2 || n === 3 ? (o.length > 1 && (s === '*' || s === '+') && t(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`), o.push({
          type: 1, value: c, regexp: u, repeatable: s === '*' || s === '+', optional: s === '*' || s === '?',
        })) : t('Invalid state to consume buffer'), c = '');
      } function d() { c += s; } while (l < e.length) if (s = e[l++], s !== '\\' || n === 2) switch (n) { case 0: s === '/' ? (c && f(), a()) : s === ':' ? (f(), n = 1) : d(); break; case 4: d(), n = r; break; case 1: s === '(' ? n = 2 : oe.test(s) ? d() : (f(), n = 0, s !== '*' && s !== '?' && s !== '+' && l--); break; case 2: s === ')' ? u[u.length - 1] == '\\' ? u = u.slice(0, -1) + s : n = 3 : u += s; break; case 3: f(), n = 0, s !== '*' && s !== '?' && s !== '+' && l--, u = ''; break; default: t('Unknown state'); break; } else r = n, n = 4; return n === 2 && t(`Unfinished custom RegExp for param "${c}"`), f(), a(), i;
    } function se(e, t, n) {
      const r = te(ae(e.path), n); const i = h(r, {
        record: e, parent: t, children: [], alias: [],
      }); return t && !i.record.aliasOf === !t.record.aliasOf && t.children.push(i), i;
    } function le(e, t) {
      const n = []; const r = new Map(); function i(e) { return r.get(e); } function o(e, n, r) {
        const i = !r; const s = ue(e); s.aliasOf = r && r.record; const c = pe(t, e); const u = [s]; if ('alias' in e) {
          const t = typeof e.alias === 'string' ? [e.alias] : e.alias; for (const e of t) {
            u.push({
              ...s, components: r ? r.record.components : s.components, path: e, aliasOf: r ? r.record : s,
            });
          }
        }let f; let d; for (const t of u) { const { path: u } = t; if (n && u[0] !== '/') { const e = n.record.path; const r = e[e.length - 1] === '/' ? '' : '/'; t.path = n.record.path + (u && r + u); } if (f = se(t, n, c), r ? r.alias.push(f) : (d = d || f, d !== f && d.alias.push(f), i && e.name && !de(f) && a(e.name)), 'children' in s) { const e = s.children; for (let t = 0; t < e.length; t++)o(e[t], f, r && r.children[t]); }r = r || f, l(f); } return d ? () => { a(d); } : m;
      } function a(e) { if (U(e)) { const t = r.get(e); t && (r.delete(e), n.splice(n.indexOf(t), 1), t.children.forEach(a), t.alias.forEach(a)); } else { const t = n.indexOf(e); t > -1 && (n.splice(t, 1), e.record.name && r.delete(e.record.name), e.children.forEach(a), e.alias.forEach(a)); } } function s() { return n; } function l(e) { let t = 0; while (t < n.length && re(e, n[t]) >= 0)t++; n.splice(t, 0, e), e.record.name && !de(e) && r.set(e.record.name, e); } function c(e, t) {
        let i; let o; let a; let s = {}; if ('name' in e && e.name) { if (i = r.get(e.name), !i) throw Y(1, { location: e }); a = i.record.name, s = h(ce(t.params, i.keys.filter((e) => !e.optional).map((e) => e.name)), e.params), o = i.stringify(s); } else if ('path' in e)o = e.path, i = n.find((e) => e.re.test(o)), i && (s = i.parse(o), a = i.record.name); else { if (i = t.name ? r.get(t.name) : n.find((e) => e.re.test(t.path)), !i) throw Y(1, { location: e, currentLocation: t }); a = i.record.name, s = { ...t.params, ...e.params }, o = i.stringify(s); } const l = []; let c = i; while (c)l.unshift(c.record), c = c.parent; return {
          name: a, path: o, params: s, matched: l, meta: he(l),
        };
      } return t = pe({ strict: !1, end: !0, sensitive: !1 }, t), e.forEach((e) => o(e)), {
        addRoute: o, resolve: c, removeRoute: a, getRoutes: s, getRecordMatcher: i,
      };
    } function ce(e, t) { const n = {}; for (const r of t)r in e && (n[r] = e[r]); return n; } function ue(e) {
      return {
        path: e.path, redirect: e.redirect, name: e.name, meta: e.meta || {}, aliasOf: void 0, beforeEnter: e.beforeEnter, props: fe(e), children: e.children || [], instances: {}, leaveGuards: new Set(), updateGuards: new Set(), enterCallbacks: {}, components: 'components' in e ? e.components || {} : { default: e.component },
      };
    } function fe(e) { const t = {}; const n = e.props || !1; if ('component' in e)t.default = n; else for (const r in e.components)t[r] = typeof n === 'boolean' ? n : n[r]; return t; } function de(e) { while (e) { if (e.record.aliasOf) return !0; e = e.parent; } return !1; } function he(e) { return e.reduce((e, t) => h(e, t.meta), {}); } function pe(e, t) { const n = {}; for (const r in e)n[r] = r in t ? t[r] : e[r]; return n; } const me = /#/g; const ge = /&/g; const ve = /\//g; const be = /=/g; const ye = /\?/g; const we = /\+/g; const xe = /%5B/g; const ke = /%5D/g; const _e = /%5E/g; const Ce = /%60/g; const Se = /%7B/g; const Oe = /%7C/g; const je = /%7D/g; const Le = /%20/g; function Te(e) { return encodeURI(`${e}`).replace(Oe, '|').replace(xe, '[').replace(ke, ']'); } function Me(e) { return Te(e).replace(Se, '{').replace(je, '}').replace(_e, '^'); } function Ae(e) {
      return Te(e).replace(we, '%2B').replace(Le, '+').replace(me, '%23')
        .replace(ge, '%26')
        .replace(Ce, '`')
        .replace(Se, '{')
        .replace(je, '}')
        .replace(_e, '^');
    } function Ee(e) { return Ae(e).replace(be, '%3D'); } function Pe(e) { return Te(e).replace(me, '%23').replace(ye, '%3F'); } function De(e) { return Pe(e).replace(ve, '%2F'); } function Ne(e) { try { return decodeURIComponent(`${e}`); } catch (t) {} return `${e}`; } function Fe(e) { const t = {}; if (e === '' || e === '?') return t; const n = e[0] === '?'; const r = (n ? e.slice(1) : e).split('&'); for (let i = 0; i < r.length; ++i) { const e = r[i].replace(we, ' '); const n = e.indexOf('='); const o = Ne(n < 0 ? e : e.slice(0, n)); if (Object.prototype.hasOwnProperty(o)) continue; const a = n < 0 ? null : Ne(e.slice(n + 1)); if (o in t) { let e = t[o]; Array.isArray(e) || (e = t[o] = [e]), e.push(a); } else t[o] = a; } return t; } function ze(e) { let t = ''; for (let n in e) { const r = e[n]; if (n = Ee(n), r == null) { void 0 !== r && (t += (t.length ? '&' : '') + n); continue; } const i = Array.isArray(r) ? r.map((e) => e && Ae(e)) : [r && Ae(r)]; i.forEach((e) => { void 0 !== e && (t += (t.length ? '&' : '') + n, e != null && (t += `=${e}`)); }); } return t; } function Ie(e) { const t = {}; for (const n in e) { const r = e[n]; void 0 !== r && (t[n] = Array.isArray(r) ? r.map((e) => (e == null ? null : `${e}`)) : r == null ? r : `${r}`); } return t; } function Be() { let e = []; function t(t) { return e.push(t), () => { const n = e.indexOf(t); n > -1 && e.splice(n, 1); }; } function n() { e = []; } return { add: t, list: () => e, reset: n }; } function He(e, t, n, r, i) { const o = r && (r.enterCallbacks[i] = r.enterCallbacks[i] || []); return () => new Promise((a, s) => { const l = (e) => { !1 === e ? s(Y(4, { from: n, to: t })) : e instanceof Error ? s(e) : V(e) ? s(Y(2, { from: t, to: e })) : (o && r.enterCallbacks[i] === o && typeof e === 'function' && o.push(e), a()); }; const c = e.call(r && r.instances[i], t, n, l); let u = Promise.resolve(c); e.length < 3 && (u = u.then(l)), u.catch((e) => s(e)); }); } function Re(e, t, n, r) { const i = []; for (const o of e) for (const e in o.components) { const a = o.components[e]; if (t === 'beforeRouteEnter' || o.instances[e]) if (We(a)) { const s = a.__vccOpts || a; const l = s[t]; l && i.push(He(l, n, r, o, e)); } else { let s = a(); s = s.catch(console.error), i.push(() => s.then((i) => { if (!i) return Promise.reject(new Error(`Couldn't resolve component "${e}" at "${o.path}"`)); const a = d(i) ? i.default : i; o.components[e] = a; const s = a.__vccOpts || a; const l = s[t]; return l && He(l, n, r, o, e)(); })); } } return i; } function We(e) { return typeof e === 'object' || 'displayName' in e || 'props' in e || '__vccOpts' in e; } function qe(e) {
      const t = Object(r.h)(l); const n = Object(r.h)(c); const i = Object(r.a)(() => t.resolve(Object(r.u)(e.to))); const o = Object(r.a)(() => { const { matched: e } = i.value; const { length: t } = e; const r = e[t - 1]; const o = n.matched; if (!r || !o.length) return -1; const a = o.findIndex(k.bind(null, r)); if (a > -1) return a; const s = Ke(e[t - 2]); return t > 1 && Ke(r) === s && o[o.length - 1].path !== s ? o.findIndex(k.bind(null, e[t - 2])) : a; }); const a = Object(r.a)(() => o.value > -1 && Ge(n.params, i.value.params)); const s = Object(r.a)(() => o.value > -1 && o.value === n.matched.length - 1 && _(n.params, i.value.params)); function u(n = {}) { return Ue(n) ? t[Object(r.u)(e.replace) ? 'replace' : 'push'](Object(r.u)(e.to)) : Promise.resolve(); } return {
        route: i, href: Object(r.a)(() => i.value.href), isActive: a, isExactActive: s, navigate: u,
      };
    } const $e = Object(r.e)({
      name: 'RouterLink',
      props: {
        to: { type: [String, Object], required: !0 }, replace: Boolean, activeClass: String, exactActiveClass: String, custom: Boolean, ariaCurrentValue: { type: String, default: 'page' },
      },
      setup(e, { slots: t }) {
        const n = Object(r.q)(qe(e)); const { options: i } = Object(r.h)(l); const o = Object(r.a)(() => ({ [Xe(e.activeClass, i.linkActiveClass, 'router-link-active')]: n.isActive, [Xe(e.exactActiveClass, i.linkExactActiveClass, 'router-link-exact-active')]: n.isExactActive })); return () => {
          const i = t.default && t.default(n); return e.custom ? i : Object(r.g)('a', {
            'aria-current': n.isExactActive ? e.ariaCurrentValue : null, href: n.href, onClick: n.navigate, class: o.value,
          }, i);
        };
      },
    }); const Ve = $e; function Ue(e) { if (!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && !e.defaultPrevented && (void 0 === e.button || e.button === 0)) { if (e.currentTarget && e.currentTarget.getAttribute) { const t = e.currentTarget.getAttribute('target'); if (/\b_blank\b/i.test(t)) return; } return e.preventDefault && e.preventDefault(), !0; } } function Ge(e, t) { for (const n in t) { const r = t[n]; const i = e[n]; if (typeof r === 'string') { if (r !== i) return !1; } else if (!Array.isArray(i) || i.length !== r.length || r.some((e, t) => e !== i[t])) return !1; } return !0; } function Ke(e) { return e ? e.aliasOf ? e.aliasOf.path : e.path : ''; } const Xe = (e, t, n) => (e != null ? e : t != null ? t : n); const Ye = Object(r.e)({
      name: 'RouterView',
      inheritAttrs: !1,
      props: { name: { type: String, default: 'default' }, route: Object },
      setup(e, { attrs: t, slots: n }) {
        const i = Object(r.h)(u); const o = Object(r.a)(() => e.route || i.value); const l = Object(r.h)(s, 0); const c = Object(r.a)(() => o.value.matched[l]); Object(r.o)(s, l + 1), Object(r.o)(a, c), Object(r.o)(u, o); const f = Object(r.r)(); return Object(r.v)(() => [f.value, c.value, e.name], ([e, t, n], [r, i, o]) => { t && (t.instances[n] = e, i && i !== t && e && e === r && (t.leaveGuards.size || (t.leaveGuards = i.leaveGuards), t.updateGuards.size || (t.updateGuards = i.updateGuards))), !e || !t || i && k(t, i) && r || (t.enterCallbacks[n] || []).forEach((t) => t(e)); }, { flush: 'post' }), () => {
          const i = o.value; const a = c.value; const s = a && a.components[e.name]; const l = e.name; if (!s) return Ze(n.default, { Component: s, route: i }); const u = a.props[e.name]; const d = u ? !0 === u ? i.params : typeof u === 'function' ? u(i) : u : null; const p = (e) => { e.component.isUnmounted && (a.instances[l] = null); }; const m = Object(r.g)(s, {
            ...d, ...t, onVnodeUnmounted: p, ref: f,
          }); return Ze(n.default, { Component: m, route: i }) || m;
        };
      },
    }); function Ze(e, t) { if (!e) return null; const n = e(t); return n.length === 1 ? n[0] : n; } const Je = Ye; function Qe(e) {
      const t = le(e.routes, e); const n = e.parseQuery || Fe; const i = e.stringifyQuery || ze; const o = e.history; const a = Be(); const s = Be(); const d = Be(); const g = Object(r.t)(G); let v = G; f && e.scrollBehavior && 'scrollRestoration' in history && (history.scrollRestoration = 'manual'); const w = p.bind(null, (e) => `${e}`); const k = p.bind(null, De); const _ = p.bind(null, Ne); function C(e, n) { let r; let i; return U(e) ? (r = t.getRecordMatcher(e), i = n) : i = e, t.addRoute(i, r); } function S(e) { const n = t.getRecordMatcher(e); n && t.removeRoute(n); } function O() { return t.getRoutes().map((e) => e.record); } function j(e) { return !!t.getRecordMatcher(e); } function L(e, r) {
        if (r = { ...r || g.value }, typeof e === 'string') {
          const i = b(n, e, r.path); const a = t.resolve({ path: i.path }, r); const s = o.createHref(i.fullPath); return h(i, a, {
            params: _(a.params), hash: Ne(i.hash), redirectedFrom: void 0, href: s,
          });
        }let a; 'path' in e ? a = { ...e, path: b(n, e.path, r.path).path } : (a = { ...e, params: k(e.params) }, r.params = k(r.params)); const s = t.resolve(a, r); const l = e.hash || ''; s.params = w(_(s.params)); const c = y(i, { ...e, hash: Me(l), path: s.path }); const u = o.createHref(c); return {
          fullPath: c, hash: l, query: i === ze ? Ie(e.query) : e.query, ...s, redirectedFrom: void 0, href: u,
        };
      } function T(e) { return typeof e === 'string' ? b(n, e, g.value.path) : ({ ...e }); } function M(e, t) { if (v !== e) return Y(8, { from: t, to: e }); } function A(e) { return B(e); } function E(e) { return A(h(T(e), { replace: !0 })); } function F(e) {
        const t = e.matched[e.matched.length - 1]; if (t && t.redirect) {
          const { redirect: n } = t; let r = typeof n === 'function' ? n(e) : n; return typeof r === 'string' && (r = r.indexOf('?') > -1 || r.indexOf('#') > -1 ? r = T(r) : { path: r }), ({
            query: e.query, hash: e.hash, params: e.params, ...r,
          });
        }
      } function B(e, t) { const n = v = L(e); const r = g.value; const o = e.state; const a = e.force; const s = !0 === e.replace; const l = F(n); if (l) return B(h(T(l), { state: o, force: a, replace: s }), t || n); const c = n; let u; return c.redirectedFrom = t, !a && x(i, r, n) && (u = Y(16, { to: c, from: r }), ne(r, r, !0, !1)), (u ? Promise.resolve(u) : R(c, r)).catch((e) => (Z(e) ? e : Q(e))).then((e) => { if (e) { if (Z(e, 2)) return B(h(T(e.to), { state: o, force: a, replace: s }), t || c); } else e = q(c, r, !0, s, o); return W(c, r, e), e; }); } function H(e, t) { const n = M(e, t); return n ? Promise.reject(n) : Promise.resolve(); } function R(e, t) {
        let n; const [r, i, o] = tt(e, t); n = Re(r.reverse(), 'beforeRouteLeave', e, t); for (const a of r)a.leaveGuards.forEach((r) => { n.push(He(r, e, t)); }); const l = H.bind(null, e, t); return n.push(l), et(n).then(() => { n = []; for (const r of a.list())n.push(He(r, e, t)); return n.push(l), et(n); }).then(() => { n = Re(i, 'beforeRouteUpdate', e, t); for (const r of i)r.updateGuards.forEach((r) => { n.push(He(r, e, t)); }); return n.push(l), et(n); }).then(() => { n = []; for (const r of e.matched) if (r.beforeEnter && t.matched.indexOf(r) < 0) if (Array.isArray(r.beforeEnter)) for (const i of r.beforeEnter)n.push(He(i, e, t)); else n.push(He(r.beforeEnter, e, t)); return n.push(l), et(n); })
          .then(() => (e.matched.forEach((e) => e.enterCallbacks = {}), n = Re(o, 'beforeRouteEnter', e, t), n.push(l), et(n)))
          .then(() => { n = []; for (const r of s.list())n.push(He(r, e, t)); return n.push(l), et(n); })
          .catch((e) => (Z(e, 8) ? e : Promise.reject(e)));
      } function W(e, t, n) { for (const r of d.list())r(e, t, n); } function q(e, t, n, r, i) { const a = M(e, t); if (a) return a; const s = t === G; const l = f ? history.state : {}; n && (r || s ? o.replace(e.fullPath, { scroll: s && l && l.scroll, ...i }) : o.push(e.fullPath, i)), g.value = e, ne(e, t, n, s), te(); }let $; function V() { $ = o.listen((e, t, n) => { const r = L(e); const i = F(r); if (i) return void B(h(i, { replace: !0 }), r).catch(m); v = r; const a = g.value; f && z(N(a.fullPath, n.delta), P()), R(r, a).catch((e) => (Z(e, 12) ? e : Z(e, 2) ? (B(e.to, r).catch(m), Promise.reject()) : (n.delta && o.go(-n.delta, !1), Q(e)))).then((e) => { e = e || q(r, a, !1), e && n.delta && o.go(-n.delta, !1), W(r, a, e); }).catch(m); }); }let K; const X = Be(); const J = Be(); function Q(e) { return te(e), J.list().forEach((t) => t(e)), Promise.reject(e); } function ee() { return K && g.value !== G ? Promise.resolve() : new Promise((e, t) => { X.add([e, t]); }); } function te(e) { K || (K = !0, V(), X.list().forEach(([t, n]) => (e ? n(e) : t())), X.reset()); } function ne(t, n, i, o) { const { scrollBehavior: a } = e; if (!f || !a) return Promise.resolve(); const s = !i && I(N(t.fullPath, 0)) || (o || !i) && history.state && history.state.scroll || null; return Object(r.i)().then(() => a(t, n, s)).then((e) => e && D(e)).catch(Q); } const re = (e) => o.go(e); let ie; const oe = new Set(); const
        ae = {
          currentRoute: g, addRoute: C, removeRoute: S, hasRoute: j, getRoutes: O, resolve: L, options: e, push: A, replace: E, go: re, back: () => re(-1), forward: () => re(1), beforeEach: a.add, beforeResolve: s.add, afterEach: d.add, onError: J.add, isReady: ee, install(e) { const t = this; e.component('RouterLink', Ve), e.component('RouterView', Je), e.config.globalProperties.$router = t, Object.defineProperty(e.config.globalProperties, '$route', { enumerable: !0, get: () => Object(r.u)(g) }), f && !ie && g.value === G && (ie = !0, A(o.location).catch((e) => { 0; })); const n = {}; for (const o in G)n[o] = Object(r.a)(() => g.value[o]); e.provide(l, t), e.provide(c, Object(r.q)(n)), e.provide(u, g); const i = e.unmount; oe.add(e), e.unmount = function () { oe.delete(e), oe.size < 1 && ($(), g.value = G, ie = !1, K = !1), i(); }; },
        }; return ae;
    } function et(e) { return e.reduce((e, t) => e.then(() => t()), Promise.resolve()); } function tt(e, t) { const n = []; const r = []; const i = []; const o = Math.max(t.matched.length, e.matched.length); for (let a = 0; a < o; a++) { const o = t.matched[a]; o && (e.matched.find((e) => k(e, o)) ? r.push(o) : n.push(o)); const s = e.matched[a]; s && (t.matched.find((e) => k(e, s)) || i.push(s)); } return [n, r, i]; }
  },
  '6d78': function (e, t, n) {
    (function (e) { e(n('56b3')); }(((e) => {
      function t(e) {
        const t = e.getWrapperElement(); e.state.fullScreenRestore = {
          scrollTop: window.pageYOffset, scrollLeft: window.pageXOffset, width: t.style.width, height: t.style.height,
        }, t.style.width = '', t.style.height = 'auto', t.className += ' CodeMirror-fullscreen', document.documentElement.style.overflow = 'hidden', e.refresh();
      } function n(e) { const t = e.getWrapperElement(); t.className = t.className.replace(/\s*CodeMirror-fullscreen\b/, ''), document.documentElement.style.overflow = ''; const n = e.state.fullScreenRestore; t.style.width = n.width, t.style.height = n.height, window.scrollTo(n.scrollLeft, n.scrollTop), e.refresh(); }e.defineOption('fullScreen', !1, ((r, i, o) => { o == e.Init && (o = !1), !o != !i && (i ? t(r) : n(r)); }));
    })));
  },
  '6eeb': function (e, t, n) { const r = n('da84'); const i = n('9112'); const o = n('5135'); const a = n('ce4e'); const s = n('8925'); const l = n('69f3'); const c = l.get; const u = l.enforce; const f = String(String).split('String'); (e.exports = function (e, t, n, s) { let l; const c = !!s && !!s.unsafe; let d = !!s && !!s.enumerable; const h = !!s && !!s.noTargetGet; typeof n === 'function' && (typeof t !== 'string' || o(n, 'name') || i(n, 'name', t), l = u(n), l.source || (l.source = f.join(typeof t === 'string' ? t : ''))), e !== r ? (c ? !h && e[t] && (d = !0) : delete e[t], d ? e[t] = n : i(e, t, n)) : d ? e[t] = n : a(t, n); })(Function.prototype, 'toString', (function () { return typeof this === 'function' && c(this).source || s(this); })); },
  7418(e, t) { t.f = Object.getOwnPropertySymbols; },
  7839(e, t) { e.exports = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf']; },
  '7a23': function (e, t, n) {
    n.d(t, 'q', (() => pe)), n.d(t, 'r', (() => Ce)), n.d(t, 't', (() => Se)), n.d(t, 'u', (() => Le)), n.d(t, 'a', (() => ei)), n.d(t, 'c', (() => yr)), n.d(t, 'd', (() => Sr)), n.d(t, 'e', (() => Ut)), n.d(t, 'f', (() => Rr)), n.d(t, 'g', (() => ti)), n.d(t, 'h', (() => Tt)), n.d(t, 'i', (() => Je)), n.d(t, 'j', (() => Yt)), n.d(t, 'k', (() => Zt)), n.d(t, 'l', (() => un)), n.d(t, 'm', (() => mr)), n.d(t, 'n', (() => vt)), n.d(t, 'o', (() => Lt)), n.d(t, 'p', (() => gt)), n.d(t, 's', (() => or)), n.d(t, 'v', (() => At)), n.d(t, 'w', (() => bt)), n.d(t, 'b', (() => no)); const r = n('9ff4'); const i = new WeakMap(); const
      o = []; let a; const s = Symbol(''); const l = Symbol(''); function c(e) { return e && !0 === e._isEffect; } function u(e, t = r.b) { c(e) && (e = e.raw); const n = h(e, t); return t.lazy || n(), n; } function f(e) { e.active && (p(e), e.options.onStop && e.options.onStop(), e.active = !1); }let d = 0; function h(e, t) { const n = function () { if (!n.active) return e(); if (!o.includes(n)) { p(n); try { return b(), o.push(n), a = n, e(); } finally { o.pop(), y(), a = o[o.length - 1]; } } }; return n.id = d++, n.allowRecurse = !!t.allowRecurse, n._isEffect = !0, n.active = !0, n.raw = e, n.deps = [], n.options = t, n; } function p(e) { const { deps: t } = e; if (t.length) { for (let n = 0; n < t.length; n++)t[n].delete(e); t.length = 0; } }let m = !0; const g = []; function v() { g.push(m), m = !1; } function b() { g.push(m), m = !0; } function y() { const e = g.pop(); m = void 0 === e || e; } function w(e, t, n) { if (!m || void 0 === a) return; let r = i.get(e); r || i.set(e, r = new Map()); let o = r.get(n); o || r.set(n, o = new Set()), o.has(a) || (o.add(a), a.deps.push(o)); } function x(e, t, n, o, c, u) {
      const f = i.get(e); if (!f) return; const d = new Set(); const
        h = (e) => { e && e.forEach((e) => { (e !== a || e.allowRecurse) && d.add(e); }); }; if (t === 'clear')f.forEach(h); else if (n === 'length' && Object(r.m)(e))f.forEach((e, t) => { (t === 'length' || t >= o) && h(e); }); else switch (void 0 !== n && h(f.get(n)), t) { case 'add': Object(r.m)(e) ? Object(r.q)(n) && h(f.get('length')) : (h(f.get(s)), Object(r.r)(e) && h(f.get(l))); break; case 'delete': Object(r.m)(e) || (h(f.get(s)), Object(r.r)(e) && h(f.get(l))); break; case 'set': Object(r.r)(e) && h(f.get(s)); break; } const p = (e) => { e.options.scheduler ? e.options.scheduler(e) : e(); }; d.forEach(p);
    } const k = Object(r.F)('__proto__,__v_isRef,__isVue'); const _ = new Set(Object.getOwnPropertyNames(Symbol).map((e) => Symbol[e]).filter(r.C)); const C = T(); const S = T(!1, !0); const O = T(!0); const j = T(!0, !0); const L = {}; function T(e = !1, t = !1) { return function (n, i, o) { if (i === '__v_isReactive') return !e; if (i === '__v_isReadonly') return e; if (i === '__v_raw' && o === (e ? t ? fe : ue : t ? ce : le).get(n)) return n; const a = Object(r.m)(n); if (!e && a && Object(r.j)(L, i)) return Reflect.get(L, i, o); const s = Reflect.get(n, i, o); if (Object(r.C)(i) ? _.has(i) : k(i)) return s; if (e || w(n, 'get', i), t) return s; if (_e(s)) { const e = !a || !Object(r.q)(i); return e ? s.value : s; } return Object(r.t)(s) ? e ? ge(s) : pe(s) : s; }; }['includes', 'indexOf', 'lastIndexOf'].forEach((e) => { const t = Array.prototype[e]; L[e] = function (...e) { const n = xe(this); for (let t = 0, i = this.length; t < i; t++)w(n, 'get', `${t}`); const r = t.apply(n, e); return r === -1 || !1 === r ? t.apply(n, e.map(xe)) : r; }; }), ['push', 'pop', 'shift', 'unshift', 'splice'].forEach((e) => { const t = Array.prototype[e]; L[e] = function (...e) { v(); const n = t.apply(this, e); return y(), n; }; }); const M = E(); const A = E(!0); function E(e = !1) { return function (t, n, i, o) { let a = t[n]; if (!e && (i = xe(i), a = xe(a), !Object(r.m)(t) && _e(a) && !_e(i))) return a.value = i, !0; const s = Object(r.m)(t) && Object(r.q)(n) ? Number(n) < t.length : Object(r.j)(t, n); const l = Reflect.set(t, n, i, o); return t === xe(o) && (s ? Object(r.i)(i, a) && x(t, 'set', n, i, a) : x(t, 'add', n, i)), l; }; } function P(e, t) { const n = Object(r.j)(e, t); const i = e[t]; const o = Reflect.deleteProperty(e, t); return o && n && x(e, 'delete', t, void 0, i), o; } function D(e, t) { const n = Reflect.has(e, t); return Object(r.C)(t) && _.has(t) || w(e, 'has', t), n; } function N(e) { return w(e, 'iterate', Object(r.m)(e) ? 'length' : s), Reflect.ownKeys(e); } const F = {
      get: C, set: M, deleteProperty: P, has: D, ownKeys: N,
    }; const z = { get: O, set(e, t) { return !0; }, deleteProperty(e, t) { return !0; } }; const I = Object(r.h)({}, F, { get: S, set: A }); const B = (Object(r.h)({}, z, { get: j }), (e) => (Object(r.t)(e) ? pe(e) : e)); const H = (e) => (Object(r.t)(e) ? ge(e) : e); const R = (e) => e; const W = (e) => Reflect.getPrototypeOf(e); function q(e, t, n = !1, r = !1) { e = e.__v_raw; const i = xe(e); const o = xe(t); t !== o && !n && w(i, 'get', t), !n && w(i, 'get', o); const { has: a } = W(i); const s = r ? R : n ? H : B; return a.call(i, t) ? s(e.get(t)) : a.call(i, o) ? s(e.get(o)) : void (e !== i && e.get(t)); } function $(e, t = !1) {
      const n = this.__v_raw; const r = xe(n); const
        i = xe(e); return e !== i && !t && w(r, 'has', e), !t && w(r, 'has', i), e === i ? n.has(e) : n.has(e) || n.has(i);
    } function V(e, t = !1) { return e = e.__v_raw, !t && w(xe(e), 'iterate', s), Reflect.get(e, 'size', e); } function U(e) { e = xe(e); const t = xe(this); const n = W(t); const r = n.has.call(t, e); return r || (t.add(e), x(t, 'add', e, e)), this; } function G(e, t) { t = xe(t); const n = xe(this); const { has: i, get: o } = W(n); let a = i.call(n, e); a || (e = xe(e), a = i.call(n, e)); const s = o.call(n, e); return n.set(e, t), a ? Object(r.i)(t, s) && x(n, 'set', e, t, s) : x(n, 'add', e, t), this; } function K(e) { const t = xe(this); const { has: n, get: r } = W(t); let i = n.call(t, e); i || (e = xe(e), i = n.call(t, e)); const o = r ? r.call(t, e) : void 0; const a = t.delete(e); return i && x(t, 'delete', e, void 0, o), a; } function X() { const e = xe(this); const t = e.size !== 0; const n = void 0; const r = e.clear(); return t && x(e, 'clear', void 0, void 0, n), r; } function Y(e, t) { return function (n, r) { const i = this; const o = i.__v_raw; const a = xe(o); const l = t ? R : e ? H : B; return !e && w(a, 'iterate', s), o.forEach((e, t) => n.call(r, l(e), l(t), i)); }; } function Z(e, t, n) {
      return function (...i) {
        const o = this.__v_raw; const a = xe(o); const c = Object(r.r)(a); const u = e === 'entries' || e === Symbol.iterator && c; const f = e === 'keys' && c; const d = o[e](...i); const
          h = n ? R : t ? H : B; return !t && w(a, 'iterate', f ? l : s), { next() { const { value: e, done: t } = d.next(); return t ? { value: e, done: t } : { value: u ? [h(e[0]), h(e[1])] : h(e), done: t }; }, [Symbol.iterator]() { return this; } };
      };
    } function J(e) { return function (...t) { return e !== 'delete' && this; }; } const Q = {
      get(e) { return q(this, e); }, get size() { return V(this); }, has: $, add: U, set: G, delete: K, clear: X, forEach: Y(!1, !1),
    }; const ee = {
      get(e) { return q(this, e, !1, !0); }, get size() { return V(this); }, has: $, add: U, set: G, delete: K, clear: X, forEach: Y(!1, !0),
    }; const te = {
      get(e) { return q(this, e, !0); }, get size() { return V(this, !0); }, has(e) { return $.call(this, e, !0); }, add: J('add'), set: J('set'), delete: J('delete'), clear: J('clear'), forEach: Y(!0, !1),
    }; const ne = {
      get(e) { return q(this, e, !0, !0); }, get size() { return V(this, !0); }, has(e) { return $.call(this, e, !0); }, add: J('add'), set: J('set'), delete: J('delete'), clear: J('clear'), forEach: Y(!0, !0),
    }; const re = ['keys', 'values', 'entries', Symbol.iterator]; function ie(e, t) { const n = t ? e ? ne : ee : e ? te : Q; return (t, i, o) => (i === '__v_isReactive' ? !e : i === '__v_isReadonly' ? e : i === '__v_raw' ? t : Reflect.get(Object(r.j)(n, i) && i in t ? n : t, i, o)); }re.forEach((e) => { Q[e] = Z(e, !1, !1), te[e] = Z(e, !0, !1), ee[e] = Z(e, !1, !0), ne[e] = Z(e, !0, !0); }); const oe = { get: ie(!1, !1) }; const ae = { get: ie(!1, !0) }; const se = { get: ie(!0, !1) }; ie(!0, !0); const le = new WeakMap(); const ce = new WeakMap(); const ue = new WeakMap(); const
      fe = new WeakMap(); function de(e) { switch (e) { case 'Object': case 'Array': return 1; case 'Map': case 'Set': case 'WeakMap': case 'WeakSet': return 2; default: return 0; } } function he(e) { return e.__v_skip || !Object.isExtensible(e) ? 0 : de(Object(r.L)(e)); } function pe(e) { return e && e.__v_isReadonly ? e : ve(e, !1, F, oe, le); } function me(e) { return ve(e, !1, I, ae, ce); } function ge(e) { return ve(e, !0, z, se, ue); } function ve(e, t, n, i, o) { if (!Object(r.t)(e)) return e; if (e.__v_raw && (!t || !e.__v_isReactive)) return e; const a = o.get(e); if (a) return a; const s = he(e); if (s === 0) return e; const l = new Proxy(e, s === 2 ? i : n); return o.set(e, l), l; } function be(e) { return ye(e) ? be(e.__v_raw) : !(!e || !e.__v_isReactive); } function ye(e) { return !(!e || !e.__v_isReadonly); } function we(e) { return be(e) || ye(e); } function xe(e) { return e && xe(e.__v_raw) || e; } const ke = (e) => (Object(r.t)(e) ? pe(e) : e); function _e(e) { return Boolean(e && !0 === e.__v_isRef); } function Ce(e) { return je(e); } function Se(e) { return je(e, !0); } class Oe {
      constructor(e, t = !1) { this._rawValue = e, this._shallow = t, this.__v_isRef = !0, this._value = t ? e : ke(e); }

      get value() { return w(xe(this), 'get', 'value'), this._value; }

      set value(e) { Object(r.i)(xe(e), this._rawValue) && (this._rawValue = e, this._value = this._shallow ? e : ke(e), x(xe(this), 'set', 'value', e)); }
    } function je(e, t = !1) { return _e(e) ? e : new Oe(e, t); } function Le(e) { return _e(e) ? e.value : e; } const Te = { get: (e, t, n) => Le(Reflect.get(e, t, n)), set: (e, t, n, r) => { const i = e[t]; return _e(i) && !_e(n) ? (i.value = n, !0) : Reflect.set(e, t, n, r); } }; function Me(e) { return be(e) ? e : new Proxy(e, Te); } class Ae {
      constructor(e, t) { this._object = e, this._key = t, this.__v_isRef = !0; }

      get value() { return this._object[this._key]; }

      set value(e) { this._object[this._key] = e; }
    } function Ee(e, t) { return _e(e[t]) ? e[t] : new Ae(e, t); } class Pe {
      constructor(e, t, n) { this._setter = t, this._dirty = !0, this.__v_isRef = !0, this.effect = u(e, { lazy: !0, scheduler: () => { this._dirty || (this._dirty = !0, x(xe(this), 'set', 'value')); } }), this.__v_isReadonly = n; }

      get value() { const e = xe(this); return e._dirty && (e._value = this.effect(), e._dirty = !1), w(e, 'get', 'value'), e._value; }

      set value(e) { this._setter(e); }
    } function De(e) { let t; let n; return Object(r.n)(e) ? (t = e, n = r.d) : (t = e.get, n = e.set), new Pe(t, n, Object(r.n)(e) || !e.set); } function Ne(e, t, n, r) { let i; try { i = r ? e(...r) : e(); } catch (o) { ze(o, t, n); } return i; } function Fe(e, t, n, i) { if (Object(r.n)(e)) { const o = Ne(e, t, n, i); return o && Object(r.w)(o) && o.catch((e) => { ze(e, t, n); }), o; } const o = []; for (let r = 0; r < e.length; r++)o.push(Fe(e[r], t, n, i)); return o; } function ze(e, t, n, r = !0) { const i = t ? t.vnode : null; if (t) { let r = t.parent; const i = t.proxy; const o = n; while (r) { const t = r.ec; if (t) for (let n = 0; n < t.length; n++) if (!1 === t[n](e, i, o)) return; r = r.parent; } const a = t.appContext.config.errorHandler; if (a) return void Ne(a, null, 10, [e, i, o]); }Ie(e, n, i, r); } function Ie(e, t, n, r = !0) { console.error(e); }let Be = !1; let He = !1; const Re = []; let We = 0; const qe = []; let $e = null; let Ve = 0; const Ue = []; let Ge = null; let Ke = 0; const Xe = Promise.resolve(); let Ye = null; let Ze = null; function Je(e) { const t = Ye || Xe; return e ? t.then(this ? e.bind(this) : e) : t; } function Qe(e) { let t = We + 1; let n = Re.length; const r = lt(e); while (t < n) { const e = t + n >>> 1; const i = lt(Re[e]); i < r ? t = e + 1 : n = e; } return t; } function et(e) { if ((!Re.length || !Re.includes(e, Be && e.allowRecurse ? We + 1 : We)) && e !== Ze) { const t = Qe(e); t > -1 ? Re.splice(t, 0, e) : Re.push(e), tt(); } } function tt() { Be || He || (He = !0, Ye = Xe.then(ct)); } function nt(e) { const t = Re.indexOf(e); t > We && Re.splice(t, 1); } function rt(e, t, n, i) { Object(r.m)(e) ? n.push(...e) : t && t.includes(e, e.allowRecurse ? i + 1 : i) || n.push(e), tt(); } function it(e) { rt(e, $e, qe, Ve); } function ot(e) { rt(e, Ge, Ue, Ke); } function at(e, t = null) { if (qe.length) { for (Ze = t, $e = [...new Set(qe)], qe.length = 0, Ve = 0; Ve < $e.length; Ve++)$e[Ve](); $e = null, Ve = 0, Ze = null, at(e, t); } } function st(e) { if (Ue.length) { const e = [...new Set(Ue)]; if (Ue.length = 0, Ge) return void Ge.push(...e); for (Ge = e, Ge.sort((e, t) => lt(e) - lt(t)), Ke = 0; Ke < Ge.length; Ke++)Ge[Ke](); Ge = null, Ke = 0; } } const lt = (e) => (e.id == null ? 1 / 0 : e.id); function ct(e) { He = !1, Be = !0, at(e), Re.sort((e, t) => lt(e) - lt(t)); try { for (We = 0; We < Re.length; We++) { const e = Re[We]; e && !1 !== e.active && Ne(e, null, 14); } } finally { We = 0, Re.length = 0, st(e), Be = !1, Ye = null, (Re.length || qe.length || Ue.length) && ct(e); } } new Set(); new Map(); Object.create(null), Object.create(null); function ut(e, t, ...n) { const i = e.vnode.props || r.b; let o = n; const a = t.startsWith('update:'); const s = a && t.slice(7); if (s && s in i) { const e = `${s === 'modelValue' ? 'model' : s}Modifiers`; const { number: t, trim: a } = i[e] || r.b; a ? o = n.map((e) => e.trim()) : t && (o = n.map(r.K)); }let l; let c = i[l = Object(r.J)(t)] || i[l = Object(r.J)(Object(r.e)(t))]; !c && a && (c = i[l = Object(r.J)(Object(r.k)(t))]), c && Fe(c, e, 6, o); const u = i[`${l}Once`]; if (u) { if (e.emitted) { if (e.emitted[l]) return; } else (e.emitted = {})[l] = !0; Fe(u, e, 6, o); } } function ft(e, t, n = !1) { const i = t.emitsCache; const o = i.get(e); if (void 0 !== o) return o; const a = e.emits; const s = {}; let l = !1; if (!Object(r.n)(e)) { const i = (e) => { const n = ft(e, t, !0); n && (l = !0, Object(r.h)(s, n)); }; !n && t.mixins.length && t.mixins.forEach(i), e.extends && i(e.extends), e.mixins && e.mixins.forEach(i); } return a || l ? (Object(r.m)(a) ? a.forEach((e) => s[e] = null) : Object(r.h)(s, a), i.set(e, s), s) : (i.set(e, null), null); } function dt(e, t) { return !(!e || !Object(r.u)(t)) && (t = t.slice(2).replace(/Once$/, ''), Object(r.j)(e, t[0].toLowerCase() + t.slice(1)) || Object(r.j)(e, Object(r.k)(t)) || Object(r.j)(e, t)); }let ht = null; let pt = null; function mt(e) { const t = ht; return ht = e, pt = e && e.type.__scopeId || null, t; } function gt(e) { pt = e; } function vt() { pt = null; } const bt = (e) => yt; function yt(e, t = ht, n) { if (!t) return e; if (e._n) return e; const r = (...n) => { r._d && br(-1); const i = mt(t); const o = e(...n); return mt(i), r._d && br(1), o; }; return r._n = !0, r._c = !0, r._d = !0, r; } function wt(e) {
      const {
        type: t, vnode: n, proxy: i, withProxy: o, props: a, propsOptions: [s], slots: l, attrs: c, emit: u, render: f, renderCache: d, data: h, setupState: p, ctx: m, inheritAttrs: g,
      } = e; let v; const b = mt(e); try { let e; if (4 & n.shapeFlag) { const t = o || i; v = Tr(f.call(t, t, d, a, p, h, m)), e = c; } else { const n = t; 0, v = Tr(n.length > 1 ? n(a, { attrs: c, slots: l, emit: u }) : n(a, null)), e = t.props ? c : xt(c); }let b = v; if (e && !1 !== g) { const t = Object.keys(e); const { shapeFlag: n } = b; t.length && (1 & n || 6 & n) && (s && t.some(r.s) && (e = kt(e, s)), b = jr(b, e)); }0, n.dirs && (b.dirs = b.dirs ? b.dirs.concat(n.dirs) : n.dirs), n.transition && (b.transition = n.transition), v = b; } catch (y) { hr.length = 0, ze(y, e, 1), v = Sr(fr); } return mt(b), v;
    } const xt = (e) => { let t; for (const n in e)(n === 'class' || n === 'style' || Object(r.u)(n)) && ((t || (t = {}))[n] = e[n]); return t; }; const kt = (e, t) => { const n = {}; for (const i in e)Object(r.s)(i) && i.slice(9) in t || (n[i] = e[i]); return n; }; function _t(e, t, n) { const { props: r, children: i, component: o } = e; const { props: a, children: s, patchFlag: l } = t; const c = o.emitsOptions; if (t.dirs || t.transition) return !0; if (!(n && l >= 0)) return !(!i && !s || s && s.$stable) || r !== a && (r ? !a || Ct(r, a, c) : !!a); if (1024 & l) return !0; if (16 & l) return r ? Ct(r, a, c) : !!a; if (8 & l) { const e = t.dynamicProps; for (let t = 0; t < e.length; t++) { const n = e[t]; if (a[n] !== r[n] && !dt(c, n)) return !0; } } return !1; } function Ct(e, t, n) { const r = Object.keys(t); if (r.length !== Object.keys(e).length) return !0; for (let i = 0; i < r.length; i++) { const o = r[i]; if (t[o] !== e[o] && !dt(n, o)) return !0; } return !1; } function St({ vnode: e, parent: t }, n) { while (t && t.subTree === e)(e = t.vnode).el = n, t = t.parent; } const Ot = (e) => e.__isSuspense; function jt(e, t) { t && t.pendingBranch ? Object(r.m)(e) ? t.effects.push(...e) : t.effects.push(e) : ot(e); } function Lt(e, t) { if (Hr) { let n = Hr.provides; const r = Hr.parent && Hr.parent.provides; r === n && (n = Hr.provides = Object.create(r)), n[e] = t; } else 0; } function Tt(e, t, n = !1) { const i = Hr || ht; if (i) { const o = i.parent == null ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides; if (o && e in o) return o[e]; if (arguments.length > 1) return n && Object(r.n)(t) ? t() : t; } else 0; } const Mt = {}; function At(e, t, n) { return Et(e, t, n); } function Et(e, t, {
      immediate: n, deep: i, flush: o, onTrack: a, onTrigger: s,
    } = r.b, l = Hr) {
      let c; let d; let h = !1; let p = !1; if (_e(e) ? (c = () => e.value, h = !!e._shallow) : be(e) ? (c = () => e, i = !0) : Object(r.m)(e) ? (p = !0, h = e.some(be), c = () => e.map((e) => (_e(e) ? e.value : be(e) ? Nt(e) : Object(r.n)(e) ? Ne(e, l, 2) : void 0))) : c = Object(r.n)(e) ? t ? () => Ne(e, l, 2) : () => { if (!l || !l.isUnmounted) return d && d(), Fe(e, l, 3, [m]); } : r.d, t && i) { const e = c; c = () => Nt(e()); }let m = (e) => { d = y.options.onStop = () => { Ne(e, l, 4); }; }; let g = p ? [] : Mt; const v = () => { if (y.active) if (t) { const e = y(); (i || h || (p ? e.some((e, t) => Object(r.i)(e, g[t])) : Object(r.i)(e, g))) && (d && d(), Fe(t, l, 3, [e, g === Mt ? void 0 : g, m]), g = e); } else y(); }; let b; v.allowRecurse = !!t, b = o === 'sync' ? v : o === 'post' ? () => Yn(v, l && l.suspense) : () => { !l || l.isMounted ? it(v) : v(); }; const y = u(c, {
        lazy: !0, onTrack: a, onTrigger: s, scheduler: b,
      }); return Zr(y, l), t ? n ? v() : g = y() : o === 'post' ? Yn(y, l && l.suspense) : y(), () => { f(y), l && Object(r.I)(l.effects, y); };
    } function Pt(e, t, n) { const i = this.proxy; const o = Object(r.B)(e) ? e.includes('.') ? Dt(i, e) : () => i[e] : e.bind(i, i); let a; return Object(r.n)(t) ? a = t : (a = t.handler, n = t), Et(o, a.bind(i), n, this); } function Dt(e, t) { const n = t.split('.'); return () => { let t = e; for (let e = 0; e < n.length && t; e++)t = t[n[e]]; return t; }; } function Nt(e, t = new Set()) { if (!Object(r.t)(e) || t.has(e) || e.__v_skip) return e; if (t.add(e), _e(e))Nt(e.value, t); else if (Object(r.m)(e)) for (let n = 0; n < e.length; n++)Nt(e[n], t); else if (Object(r.z)(e) || Object(r.r)(e))e.forEach((e) => { Nt(e, t); }); else if (Object(r.v)(e)) for (const n in e)Nt(e[n], t); return e; } function Ft() {
      const e = {
        isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map(),
      }; return an(() => { e.isMounted = !0; }), cn(() => { e.isUnmounting = !0; }), e;
    } const zt = [Function, Array]; const It = {
      name: 'BaseTransition',
      props: {
        mode: String, appear: Boolean, persisted: Boolean, onBeforeEnter: zt, onEnter: zt, onAfterEnter: zt, onEnterCancelled: zt, onBeforeLeave: zt, onLeave: zt, onAfterLeave: zt, onLeaveCancelled: zt, onBeforeAppear: zt, onAppear: zt, onAfterAppear: zt, onAppearCancelled: zt,
      },
      setup(e, { slots: t }) { const n = Rr(); const r = Ft(); let i; return () => { const o = t.default && Vt(t.default(), !0); if (!o || !o.length) return; const a = xe(e); const { mode: s } = a; const l = o[0]; if (r.isLeaving) return Wt(l); const c = qt(l); if (!c) return Wt(l); const u = Rt(c, a, r, n); $t(c, u); const f = n.subTree; const d = f && qt(f); let h = !1; const { getTransitionKey: p } = c.type; if (p) { const e = p(); void 0 === i ? i = e : e !== i && (i = e, h = !0); } if (d && d.type !== fr && (!xr(c, d) || h)) { const e = Rt(d, a, r, n); if ($t(d, e), s === 'out-in') return r.isLeaving = !0, e.afterLeave = () => { r.isLeaving = !1, n.update(); }, Wt(l); s === 'in-out' && c.type !== fr && (e.delayLeave = (e, t, n) => { const i = Ht(r, d); i[String(d.key)] = d, e._leaveCb = () => { t(), e._leaveCb = void 0, delete u.delayedLeave; }, u.delayedLeave = n; }); } return l; }; },
    }; const Bt = It; function Ht(e, t) { const { leavingVNodes: n } = e; let r = n.get(t.type); return r || (r = Object.create(null), n.set(t.type, r)), r; } function Rt(e, t, n, r) {
      const {
        appear: i, mode: o, persisted: a = !1, onBeforeEnter: s, onEnter: l, onAfterEnter: c, onEnterCancelled: u, onBeforeLeave: f, onLeave: d, onAfterLeave: h, onLeaveCancelled: p, onBeforeAppear: m, onAppear: g, onAfterAppear: v, onAppearCancelled: b,
      } = t; const y = String(e.key); const w = Ht(n, e); const x = (e, t) => { e && Fe(e, r, 9, t); }; const k = {
        mode: o, persisted: a, beforeEnter(t) { let r = s; if (!n.isMounted) { if (!i) return; r = m || s; }t._leaveCb && t._leaveCb(!0); const o = w[y]; o && xr(e, o) && o.el._leaveCb && o.el._leaveCb(), x(r, [t]); }, enter(e) { let t = l; let r = c; let o = u; if (!n.isMounted) { if (!i) return; t = g || l, r = v || c, o = b || u; }let a = !1; const s = e._enterCb = (t) => { a || (a = !0, x(t ? o : r, [e]), k.delayedLeave && k.delayedLeave(), e._enterCb = void 0); }; t ? (t(e, s), t.length <= 1 && s()) : s(); }, leave(t, r) { const i = String(e.key); if (t._enterCb && t._enterCb(!0), n.isUnmounting) return r(); x(f, [t]); let o = !1; const a = t._leaveCb = (n) => { o || (o = !0, r(), x(n ? p : h, [t]), t._leaveCb = void 0, w[i] === e && delete w[i]); }; w[i] = e, d ? (d(t, a), d.length <= 1 && a()) : a(); }, clone(e) { return Rt(e, t, n, r); },
      }; return k;
    } function Wt(e) { if (Kt(e)) return e = jr(e), e.children = null, e; } function qt(e) { return Kt(e) ? e.children ? e.children[0] : void 0 : e; } function $t(e, t) { 6 & e.shapeFlag && e.component ? $t(e.component.subTree, t) : 128 & e.shapeFlag ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t; } function Vt(e, t = !1) { let n = []; let r = 0; for (let i = 0; i < e.length; i++) { const o = e[i]; o.type === cr ? (128 & o.patchFlag && r++, n = n.concat(Vt(o.children, t))) : (t || o.type !== fr) && n.push(o); } if (r > 1) for (let i = 0; i < n.length; i++)n[i].patchFlag = -2; return n; } function Ut(e) { return Object(r.n)(e) ? { setup: e, name: e.name } : e; } const Gt = (e) => !!e.type.__asyncLoader; const Kt = (e) => e.type.__isKeepAlive; RegExp, RegExp; function Xt(e, t) { return Object(r.m)(e) ? e.some((e) => Xt(e, t)) : Object(r.B)(e) ? e.split(',').indexOf(t) > -1 : !!e.test && e.test(t); } function Yt(e, t) { Jt(e, 'a', t); } function Zt(e, t) { Jt(e, 'da', t); } function Jt(e, t, n = Hr) { const r = e.__wdc || (e.__wdc = () => { let t = n; while (t) { if (t.isDeactivated) return; t = t.parent; }e(); }); if (nn(t, r, n), n) { let e = n.parent; while (e && e.parent)Kt(e.parent.vnode) && Qt(r, t, n, e), e = e.parent; } } function Qt(e, t, n, i) { const o = nn(t, e, i, !0); un(() => { Object(r.I)(i[t], o); }, n); } function en(e) { let t = e.shapeFlag; 256 & t && (t -= 256), 512 & t && (t -= 512), e.shapeFlag = t; } function tn(e) { return 128 & e.shapeFlag ? e.ssContent : e; } function nn(e, t, n = Hr, r = !1) { if (n) { const i = n[e] || (n[e] = []); const o = t.__weh || (t.__weh = (...r) => { if (n.isUnmounted) return; v(), Wr(n); const i = Fe(t, n, e, r); return Wr(null), y(), i; }); return r ? i.unshift(o) : i.push(o), o; } } const rn = (e) => (t, n = Hr) => (!Vr || e === 'sp') && nn(e, t, n); const on = rn('bm'); const an = rn('m'); const sn = rn('bu'); const ln = rn('u'); const cn = rn('bum'); const un = rn('um'); const fn = rn('sp'); const dn = rn('rtg'); const hn = rn('rtc'); function pn(e, t = Hr) { nn('ec', e, t); }let mn = !0; function gn(e) {
      const t = wn(e); const n = e.proxy; const i = e.ctx; mn = !1, t.beforeCreate && bn(t.beforeCreate, e, 'bc'); const {
        data: o, computed: a, methods: s, watch: l, provide: c, inject: u, created: f, beforeMount: d, mounted: h, beforeUpdate: p, updated: m, activated: g, deactivated: v, beforeDestroy: b, beforeUnmount: y, destroyed: w, unmounted: x, render: k, renderTracked: _, renderTriggered: C, errorCaptured: S, serverPrefetch: O, expose: j, inheritAttrs: L, components: T, directives: M, filters: A,
      } = t; const E = null; if (u && vn(u, i, E), s) for (const D in s) { const e = s[D]; Object(r.n)(e) && (i[D] = e.bind(n)); } if (o) { 0; const t = o.call(n, n); 0, Object(r.t)(t) && (e.data = pe(t)); } if (mn = !0, a) {
        for (const D in a) {
          const e = a[D]; const t = Object(r.n)(e) ? e.bind(n, n) : Object(r.n)(e.get) ? e.get.bind(n, n) : r.d; 0; const o = !Object(r.n)(e) && Object(r.n)(e.set) ? e.set.bind(n) : r.d; const
            s = ei({ get: t, set: o }); Object.defineProperty(i, D, {
            enumerable: !0, configurable: !0, get: () => s.value, set: (e) => s.value = e,
          });
        }
      } if (l) for (const r in l)yn(l[r], i, n, r); if (c) { const e = Object(r.n)(c) ? c.call(n) : c; Reflect.ownKeys(e).forEach((t) => { Lt(t, e[t]); }); } function P(e, t) { Object(r.m)(t) ? t.forEach((t) => e(t.bind(n))) : t && e(t.bind(n)); } if (f && bn(f, e, 'c'), P(on, d), P(an, h), P(sn, p), P(ln, m), P(Yt, g), P(Zt, v), P(pn, S), P(hn, _), P(dn, C), P(cn, y), P(un, x), P(fn, O), Object(r.m)(j)) if (j.length) { const t = e.exposed || (e.exposed = Me({})); j.forEach((e) => { t[e] = Ee(n, e); }); } else e.exposed || (e.exposed = r.b); k && e.render === r.d && (e.render = k), L != null && (e.inheritAttrs = L), T && (e.components = T), M && (e.directives = M);
    } function vn(e, t, n = r.d) { Object(r.m)(e) && (e = Sn(e)); for (const i in e) { const n = e[i]; Object(r.t)(n) ? t[i] = 'default' in n ? Tt(n.from || i, n.default, !0) : Tt(n.from || i) : t[i] = Tt(n); } } function bn(e, t, n) { Fe(Object(r.m)(e) ? e.map((e) => e.bind(t.proxy)) : e.bind(t.proxy), t, n); } function yn(e, t, n, i) { const o = i.includes('.') ? Dt(n, i) : () => n[i]; if (Object(r.B)(e)) { const n = t[e]; Object(r.n)(n) && At(o, n); } else if (Object(r.n)(e))At(o, e.bind(n)); else if (Object(r.t)(e)) if (Object(r.m)(e))e.forEach((e) => yn(e, t, n, i)); else { const i = Object(r.n)(e.handler) ? e.handler.bind(n) : t[e.handler]; Object(r.n)(i) && At(o, i, e); } else 0; } function wn(e) { const t = e.type; const { mixins: n, extends: r } = t; const { mixins: i, optionsCache: o, config: { optionMergeStrategies: a } } = e.appContext; const s = o.get(t); let l; return s ? l = s : i.length || n || r ? (l = {}, i.length && i.forEach((e) => xn(l, e, a, !0)), xn(l, t, a)) : l = t, o.set(t, l), l; } function xn(e, t, n, r = !1) { const { mixins: i, extends: o } = t; o && xn(e, o, n, !0), i && i.forEach((t) => xn(e, t, n, !0)); for (const a in t) if (r && a === 'expose');else { const r = kn[a] || n && n[a]; e[a] = r ? r(e[a], t[a]) : t[a]; } return e; } const kn = {
      data: _n, props: jn, emits: jn, methods: jn, computed: jn, beforeCreate: On, created: On, beforeMount: On, mounted: On, beforeUpdate: On, updated: On, beforeDestroy: On, destroyed: On, activated: On, deactivated: On, errorCaptured: On, serverPrefetch: On, components: jn, directives: jn, watch: jn, provide: _n, inject: Cn,
    }; function _n(e, t) { return t ? e ? function () { return Object(r.h)(Object(r.n)(e) ? e.call(this, this) : e, Object(r.n)(t) ? t.call(this, this) : t); } : t : e; } function Cn(e, t) { return jn(Sn(e), Sn(t)); } function Sn(e) { if (Object(r.m)(e)) { const t = {}; for (let n = 0; n < e.length; n++)t[e[n]] = e[n]; return t; } return e; } function On(e, t) { return e ? [...new Set([].concat(e, t))] : t; } function jn(e, t) { return e ? Object(r.h)(Object(r.h)(Object.create(null), e), t) : t; } function Ln(e, t, n, i = !1) { const o = {}; const a = {}; Object(r.g)(a, kr, 1), e.propsDefaults = Object.create(null), Mn(e, t, o, a); for (const r in e.propsOptions[0])r in o || (o[r] = void 0); n ? e.props = i ? o : me(o) : e.type.props ? e.props = o : e.props = a, e.attrs = a; } function Tn(e, t, n, i) { const { props: o, attrs: a, vnode: { patchFlag: s } } = e; const l = xe(o); const [c] = e.propsOptions; let u = !1; if (!(i || s > 0) || 16 & s) { let i; Mn(e, t, o, a) && (u = !0); for (const a in l)t && (Object(r.j)(t, a) || (i = Object(r.k)(a)) !== a && Object(r.j)(t, i)) || (c ? !n || void 0 === n[a] && void 0 === n[i] || (o[a] = An(c, l, a, void 0, e, !0)) : delete o[a]); if (a !== l) for (const e in a)t && Object(r.j)(t, e) || (delete a[e], u = !0); } else if (8 & s) { const n = e.vnode.dynamicProps; for (let i = 0; i < n.length; i++) { const s = n[i]; const f = t[s]; if (c) if (Object(r.j)(a, s))f !== a[s] && (a[s] = f, u = !0); else { const t = Object(r.e)(s); o[t] = An(c, l, t, f, e, !1); } else f !== a[s] && (a[s] = f, u = !0); } }u && x(e, 'set', '$attrs'); } function Mn(e, t, n, i) { const [o, a] = e.propsOptions; let s; let l = !1; if (t) for (const c in t) { if (Object(r.x)(c)) continue; const u = t[c]; let f; o && Object(r.j)(o, f = Object(r.e)(c)) ? a && a.includes(f) ? (s || (s = {}))[f] = u : n[f] = u : dt(e.emitsOptions, c) || u !== i[c] && (i[c] = u, l = !0); } if (a) { const t = xe(n); const i = s || r.b; for (let s = 0; s < a.length; s++) { const l = a[s]; n[l] = An(o, t, l, i[l], e, !Object(r.j)(i, l)); } } return l; } function An(e, t, n, i, o, a) { const s = e[n]; if (s != null) { const e = Object(r.j)(s, 'default'); if (e && void 0 === i) { const e = s.default; if (s.type !== Function && Object(r.n)(e)) { const { propsDefaults: r } = o; n in r ? i = r[n] : (Wr(o), i = r[n] = e.call(null, t), Wr(null)); } else i = e; }s[0] && (a && !e ? i = !1 : !s[1] || i !== '' && i !== Object(r.k)(n) || (i = !0)); } return i; } function En(e, t, n = !1) { const i = t.propsCache; const o = i.get(e); if (o) return o; const a = e.props; const s = {}; const l = []; let c = !1; if (!Object(r.n)(e)) { const i = (e) => { c = !0; const [n, i] = En(e, t, !0); Object(r.h)(s, n), i && l.push(...i); }; !n && t.mixins.length && t.mixins.forEach(i), e.extends && i(e.extends), e.mixins && e.mixins.forEach(i); } if (!a && !c) return i.set(e, r.a), r.a; if (Object(r.m)(a)) for (let f = 0; f < a.length; f++) { 0; const e = Object(r.e)(a[f]); Pn(e) && (s[e] = r.b); } else if (a) { 0; for (const e in a) { const t = Object(r.e)(e); if (Pn(t)) { const n = a[e]; const i = s[t] = Object(r.m)(n) || Object(r.n)(n) ? { type: n } : n; if (i) { const e = Fn(Boolean, i.type); const n = Fn(String, i.type); i[0] = e > -1, i[1] = n < 0 || e < n, (e > -1 || Object(r.j)(i, 'default')) && l.push(t); } } } } const u = [s, l]; return i.set(e, u), u; } function Pn(e) { return e[0] !== '$'; } function Dn(e) { const t = e && e.toString().match(/^\s*function (\w+)/); return t ? t[1] : ''; } function Nn(e, t) { return Dn(e) === Dn(t); } function Fn(e, t) { return Object(r.m)(t) ? t.findIndex((t) => Nn(t, e)) : Object(r.n)(t) && Nn(t, e) ? 0 : -1; } const zn = (e) => e[0] === '_' || e === '$stable'; const In = (e) => (Object(r.m)(e) ? e.map(Tr) : [Tr(e)]); const Bn = (e, t, n) => { const r = yt((e) => In(t(e)), n); return r._c = !1, r; }; const Hn = (e, t, n) => { const i = e._ctx; for (const o in e) { if (zn(o)) continue; const n = e[o]; if (Object(r.n)(n))t[o] = Bn(o, n, i); else if (n != null) { 0; const e = In(n); t[o] = () => e; } } }; const Rn = (e, t) => { const n = In(t); e.slots.default = () => n; }; const Wn = (e, t) => { if (32 & e.vnode.shapeFlag) { const n = t._; n ? (e.slots = xe(t), Object(r.g)(t, '_', n)) : Hn(t, e.slots = {}); } else e.slots = {}, t && Rn(e, t); Object(r.g)(e.slots, kr, 1); }; const qn = (e, t, n) => { const { vnode: i, slots: o } = e; let a = !0; let s = r.b; if (32 & i.shapeFlag) { const e = t._; e ? n && e === 1 ? a = !1 : (Object(r.h)(o, t), n || e !== 1 || delete o._) : (a = !t.$stable, Hn(t, o)), s = t; } else t && (Rn(e, t), s = { default: 1 }); if (a) for (const r in o)zn(r) || r in s || delete o[r]; }; function $n(e, t, n, r) { const i = e.dirs; const o = t && t.dirs; for (let a = 0; a < i.length; a++) { const s = i[a]; o && (s.oldValue = o[a].value); const l = s.dir[r]; l && (v(), Fe(l, n, 8, [e.el, s, e, t]), y()); } } function Vn() {
      return {
        app: null,
        config: {
          isNativeTag: r.c, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {},
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap(),
        propsCache: new WeakMap(),
        emitsCache: new WeakMap(),
      };
    }let Un = 0; function Gn(e, t) {
      return function (n, i = null) {
        i == null || Object(r.t)(i) || (i = null); const o = Vn(); const a = new Set(); let s = !1; const l = o.app = {
          _uid: Un++, _component: n, _props: i, _container: null, _context: o, version: ni, get config() { return o.config; }, set config(e) { 0; }, use(e, ...t) { return a.has(e) || (e && Object(r.n)(e.install) ? (a.add(e), e.install(l, ...t)) : Object(r.n)(e) && (a.add(e), e(l, ...t))), l; }, mixin(e) { return o.mixins.includes(e) || o.mixins.push(e), l; }, component(e, t) { return t ? (o.components[e] = t, l) : o.components[e]; }, directive(e, t) { return t ? (o.directives[e] = t, l) : o.directives[e]; }, mount(r, a, c) { if (!s) { const u = Sr(n, i); return u.appContext = o, a && t ? t(u, r) : e(u, r, c), s = !0, l._container = r, r.__vue_app__ = l, u.component.proxy; } }, unmount() { s && (e(null, l._container), delete l._container.__vue_app__); }, provide(e, t) { return o.provides[e] = t, l; },
        }; return l;
      };
    } function Kn() {} const Xn = { scheduler: et, allowRecurse: !0 }; const Yn = jt; const Zn = (e, t, n, i, o = !1) => { if (Object(r.m)(e)) return void e.forEach((e, a) => Zn(e, t && (Object(r.m)(t) ? t[a] : t), n, i, o)); if (Gt(i) && !o) return; const a = 4 & i.shapeFlag ? i.component.exposed || i.component.proxy : i.el; const s = o ? null : a; const { i: l, r: c } = e; const u = t && t.r; const f = l.refs === r.b ? l.refs = {} : l.refs; const d = l.setupState; if (u != null && u !== c && (Object(r.B)(u) ? (f[u] = null, Object(r.j)(d, u) && (d[u] = null)) : _e(u) && (u.value = null)), Object(r.B)(c)) { const e = () => { f[c] = s, Object(r.j)(d, c) && (d[c] = s); }; s ? (e.id = -1, Yn(e, n)) : e(); } else if (_e(c)) { const e = () => { c.value = s; }; s ? (e.id = -1, Yn(e, n)) : e(); } else Object(r.n)(c) && Ne(c, l, 12, [s, f]); }; function Jn(e) { return Qn(e); } function Qn(e, t) {
      Kn(); const {
        insert: n, remove: i, patchProp: o, forcePatchProp: a, createElement: s, createText: l, createComment: c, setText: d, setElementText: h, parentNode: p, nextSibling: m, setScopeId: g = r.d, cloneNode: b, insertStaticContent: w,
      } = e; const x = (e, t, n, r = null, i = null, o = null, a = !1, s = null, l = !1) => { e && !xr(e, t) && (r = X(e), $(e, i, o, !0), e = null), t.patchFlag === -2 && (l = !1, t.dynamicChildren = null); const { type: c, ref: u, shapeFlag: f } = t; switch (c) { case ur: k(e, t, n, r); break; case fr: _(e, t, n, r); break; case dr: e == null && C(t, n, r, a); break; case cr: D(e, t, n, r, i, o, a, s, l); break; default: 1 & f ? j(e, t, n, r, i, o, a, s, l) : 6 & f ? N(e, t, n, r, i, o, a, s, l) : (64 & f || 128 & f) && c.process(e, t, n, r, i, o, a, s, l, Z); }u != null && i && Zn(u, e && e.ref, o, t || e, !t); }; const k = (e, t, r, i) => { if (e == null)n(t.el = l(t.children), r, i); else { const n = t.el = e.el; t.children !== e.children && d(n, t.children); } }; const _ = (e, t, r, i) => { e == null ? n(t.el = c(t.children || ''), r, i) : t.el = e.el; }; const C = (e, t, n, r) => { [e.el, e.anchor] = w(e.children, t, n, r); }; const S = ({ el: e, anchor: t }, r, i) => { let o; while (e && e !== t)o = m(e), n(e, r, i), e = o; n(t, r, i); }; const O = ({ el: e, anchor: t }) => { let n; while (e && e !== t)n = m(e), i(e), e = n; i(t); }; const j = (e, t, n, r, i, o, a, s, l) => { a = a || t.type === 'svg', e == null ? L(t, n, r, i, o, a, s, l) : A(e, t, i, o, a, s, l); }; const L = (e, t, i, a, l, c, u, f) => {
        let d; let p; const {
          type: m, props: g, shapeFlag: v, transition: y, patchFlag: w, dirs: x,
        } = e; if (e.el && void 0 !== b && w === -1)d = e.el = b(e.el); else { if (d = e.el = s(e.type, c, g && g.is, g), 8 & v ? h(d, e.children) : 16 & v && M(e.children, d, null, a, l, c && m !== 'foreignObject', u, f || !!e.dynamicChildren), x && $n(e, null, a, 'created'), g) { for (const t in g)Object(r.x)(t) || o(d, t, null, g[t], c, e.children, a, l, K); (p = g.onVnodeBeforeMount) && er(p, a, e); }T(d, e, e.scopeId, u, a); }x && $n(e, null, a, 'beforeMount'); const k = (!l || l && !l.pendingBranch) && y && !y.persisted; k && y.beforeEnter(d), n(d, t, i), ((p = g && g.onVnodeMounted) || k || x) && Yn(() => { p && er(p, a, e), k && y.enter(d), x && $n(e, null, a, 'mounted'); }, l);
      }; const T = (e, t, n, r, i) => { if (n && g(e, n), r) for (let o = 0; o < r.length; o++)g(e, r[o]); if (i) { const n = i.subTree; if (t === n) { const t = i.vnode; T(e, t, t.scopeId, t.slotScopeIds, i.parent); } } }; const M = (e, t, n, r, i, o, a, s, l = 0) => { for (let c = l; c < e.length; c++) { const l = e[c] = s ? Mr(e[c]) : Tr(e[c]); x(null, l, t, n, r, i, o, a, s); } }; const A = (e, t, n, i, s, l, c) => {
        const u = t.el = e.el; let{ patchFlag: f, dynamicChildren: d, dirs: p } = t; f |= 16 & e.patchFlag; const m = e.props || r.b; const
          g = t.props || r.b; let v; if ((v = g.onVnodeBeforeUpdate) && er(v, n, t, e), p && $n(t, e, n, 'beforeUpdate'), f > 0) { if (16 & f)P(u, t, m, g, n, i, s); else if (2 & f && m.class !== g.class && o(u, 'class', null, g.class, s), 4 & f && o(u, 'style', m.style, g.style, s), 8 & f) { const r = t.dynamicProps; for (let t = 0; t < r.length; t++) { const l = r[t]; const c = m[l]; const f = g[l]; (f !== c || a && a(u, l)) && o(u, l, c, f, s, e.children, n, i, K); } }1 & f && e.children !== t.children && h(u, t.children); } else c || d != null || P(u, t, m, g, n, i, s); const b = s && t.type !== 'foreignObject'; d ? E(e.dynamicChildren, d, u, n, i, b, l) : c || H(e, t, u, null, n, i, b, l, !1), ((v = g.onVnodeUpdated) || p) && Yn(() => { v && er(v, n, t, e), p && $n(t, e, n, 'updated'); }, i);
      }; const E = (e, t, n, r, i, o, a) => { for (let s = 0; s < t.length; s++) { const l = e[s]; const c = t[s]; const u = l.el && (l.type === cr || !xr(l, c) || 6 & l.shapeFlag || 64 & l.shapeFlag) ? p(l.el) : n; x(l, c, u, null, r, i, o, a, !0); } }; const P = (e, t, n, i, s, l, c) => { if (n !== i) { for (const u in i) { if (Object(r.x)(u)) continue; const f = i[u]; const d = n[u]; (f !== d || a && a(e, u)) && o(e, u, d, f, c, t.children, s, l, K); } if (n !== r.b) for (const a in n)Object(r.x)(a) || a in i || o(e, a, n[a], null, c, t.children, s, l, K); } }; const D = (e, t, r, i, o, a, s, c, u) => { const f = t.el = e ? e.el : l(''); const d = t.anchor = e ? e.anchor : l(''); const { patchFlag: h, dynamicChildren: p, slotScopeIds: m } = t; p && (u = !0), m && (c = c ? c.concat(m) : m), e == null ? (n(f, r, i), n(d, r, i), M(t.children, r, d, o, a, s, c, u)) : h > 0 && 64 & h && p && e.dynamicChildren ? (E(e.dynamicChildren, p, r, o, a, s, c), (t.key != null || o && t === o.subTree) && tr(e, t, !0)) : H(e, t, r, d, o, a, s, c, u); }; const N = (e, t, n, r, i, o, a, s, l) => { t.slotScopeIds = s, e == null ? 512 & t.shapeFlag ? i.ctx.activate(t, n, r, a, l) : F(t, n, r, i, o, a, l) : z(e, t, l); }; const F = (e, t, n, r, i, o, a) => { const s = e.component = Br(e, r, i); if (Kt(e) && (s.ctx.renderer = Z), Ur(s), s.asyncDep) { if (i && i.registerDep(s, I), !e.el) { const e = s.subTree = Sr(fr); _(null, e, t, n); } } else I(s, e, t, n, i, o, a); }; const z = (e, t, n) => { const r = t.component = e.component; if (_t(e, t, n)) { if (r.asyncDep && !r.asyncResolved) return void B(r, t, n); r.next = t, nt(r.update), r.update(); } else t.component = e.component, t.el = e.el, r.vnode = t; }; const I = (e, t, n, i, o, a, s) => {
        e.update = u((() => {
          if (e.isMounted) {
            let t; let {
              next: n, bu: i, u: l, parent: c, vnode: u,
            } = e; const f = n; 0, n ? (n.el = u.el, B(e, n, s)) : n = u, i && Object(r.l)(i), (t = n.props && n.props.onVnodeBeforeUpdate) && er(t, c, n, u); const d = wt(e); 0; const h = e.subTree; e.subTree = d, x(h, d, p(h.el), X(h), e, o, a), n.el = d.el, f === null && St(e, d.el), l && Yn(l, o), (t = n.props && n.props.onVnodeUpdated) && Yn(() => er(t, c, n, u), o);
          } else { let s; const { el: l, props: c } = t; const { bm: u, m: f, parent: d } = e; if (u && Object(r.l)(u), (s = c && c.onVnodeBeforeMount) && er(s, d, t), l && Q) { const n = () => { e.subTree = wt(e), Q(l, e.subTree, e, o, null); }; Gt(t) ? t.type.__asyncLoader().then(() => !e.isUnmounted && n()) : n(); } else { 0; const r = e.subTree = wt(e); 0, x(null, r, n, i, e, o, a), t.el = r.el; } if (f && Yn(f, o), s = c && c.onVnodeMounted) { const e = t; Yn(() => er(s, d, e), o); }256 & t.shapeFlag && e.a && Yn(e.a, o), e.isMounted = !0, t = n = i = null; }
        }), Xn);
      }; const B = (e, t, n) => { t.component = e; const r = e.vnode.props; e.vnode = t, e.next = null, Tn(e, t.props, r, n), qn(e, t.children, n), v(), at(void 0, e.update), y(); }; const H = (e, t, n, r, i, o, a, s, l = !1) => { const c = e && e.children; const u = e ? e.shapeFlag : 0; const f = t.children; const { patchFlag: d, shapeFlag: p } = t; if (d > 0) { if (128 & d) return void W(c, f, n, r, i, o, a, s, l); if (256 & d) return void R(c, f, n, r, i, o, a, s, l); }8 & p ? (16 & u && K(c, i, o), f !== c && h(n, f)) : 16 & u ? 16 & p ? W(c, f, n, r, i, o, a, s, l) : K(c, i, o, !0) : (8 & u && h(n, ''), 16 & p && M(f, n, r, i, o, a, s, l)); }; const R = (e, t, n, i, o, a, s, l, c) => { e = e || r.a, t = t || r.a; const u = e.length; const f = t.length; const d = Math.min(u, f); let h; for (h = 0; h < d; h++) { const r = t[h] = c ? Mr(t[h]) : Tr(t[h]); x(e[h], r, n, null, o, a, s, l, c); }u > f ? K(e, o, a, !0, !1, d) : M(t, n, i, o, a, s, l, c, d); }; const W = (e, t, n, i, o, a, s, l, c) => { let u = 0; const f = t.length; let d = e.length - 1; let h = f - 1; while (u <= d && u <= h) { const r = e[u]; const i = t[u] = c ? Mr(t[u]) : Tr(t[u]); if (!xr(r, i)) break; x(r, i, n, null, o, a, s, l, c), u++; } while (u <= d && u <= h) { const r = e[d]; const i = t[h] = c ? Mr(t[h]) : Tr(t[h]); if (!xr(r, i)) break; x(r, i, n, null, o, a, s, l, c), d--, h--; } if (u > d) { if (u <= h) { const e = h + 1; const r = e < f ? t[e].el : i; while (u <= h)x(null, t[u] = c ? Mr(t[u]) : Tr(t[u]), n, r, o, a, s, l, c), u++; } } else if (u > h) while (u <= d)$(e[u], o, a, !0), u++; else { const p = u; const m = u; const g = new Map(); for (u = m; u <= h; u++) { const e = t[u] = c ? Mr(t[u]) : Tr(t[u]); e.key != null && g.set(e.key, u); }let v; let b = 0; const y = h - m + 1; let w = !1; let k = 0; const _ = new Array(y); for (u = 0; u < y; u++)_[u] = 0; for (u = p; u <= d; u++) { const r = e[u]; if (b >= y) { $(r, o, a, !0); continue; }let i; if (r.key != null)i = g.get(r.key); else for (v = m; v <= h; v++) if (_[v - m] === 0 && xr(r, t[v])) { i = v; break; } void 0 === i ? $(r, o, a, !0) : (_[i - m] = u + 1, i >= k ? k = i : w = !0, x(r, t[i], n, null, o, a, s, l, c), b++); } const C = w ? nr(_) : r.a; for (v = C.length - 1, u = y - 1; u >= 0; u--) { const e = m + u; const r = t[e]; const d = e + 1 < f ? t[e + 1].el : i; _[u] === 0 ? x(null, r, n, d, o, a, s, l, c) : w && (v < 0 || u !== C[v] ? q(r, n, d, 2) : v--); } } }; const q = (e, t, r, i, o = null) => {
        const {
          el: a, type: s, transition: l, children: c, shapeFlag: u,
        } = e; if (6 & u) return void q(e.component.subTree, t, r, i); if (128 & u) return void e.suspense.move(t, r, i); if (64 & u) return void s.move(e, t, r, Z); if (s === cr) { n(a, t, r); for (let e = 0; e < c.length; e++)q(c[e], t, r, i); return void n(e.anchor, t, r); } if (s === dr) return void S(e, t, r); const f = i !== 2 && 1 & u && l; if (f) if (i === 0)l.beforeEnter(a), n(a, t, r), Yn(() => l.enter(a), o); else { const { leave: e, delayLeave: i, afterLeave: o } = l; const s = () => n(a, t, r); const c = () => { e(a, () => { s(), o && o(); }); }; i ? i(a, s, c) : c(); } else n(a, t, r);
      }; const $ = (e, t, n, r = !1, i = !1) => {
        const {
          type: o, props: a, ref: s, children: l, dynamicChildren: c, shapeFlag: u, patchFlag: f, dirs: d,
        } = e; if (s != null && Zn(s, null, n, e, !0), 256 & u) return void t.ctx.deactivate(e); const h = 1 & u && d; let p; if ((p = a && a.onVnodeBeforeUnmount) && er(p, t, e), 6 & u)G(e.component, n, r); else { if (128 & u) return void e.suspense.unmount(n, r); h && $n(e, null, t, 'beforeUnmount'), 64 & u ? e.type.remove(e, t, n, i, Z, r) : c && (o !== cr || f > 0 && 64 & f) ? K(c, t, n, !1, !0) : (o === cr && (128 & f || 256 & f) || !i && 16 & u) && K(l, t, n), r && V(e); }((p = a && a.onVnodeUnmounted) || h) && Yn(() => { p && er(p, t, e), h && $n(e, null, t, 'unmounted'); }, n);
      }; const V = (e) => {
        const {
          type: t, el: n, anchor: r, transition: o,
        } = e; if (t === cr) return void U(n, r); if (t === dr) return void O(e); const a = () => { i(n), o && !o.persisted && o.afterLeave && o.afterLeave(); }; if (1 & e.shapeFlag && o && !o.persisted) { const { leave: t, delayLeave: r } = o; const i = () => t(n, a); r ? r(e.el, a, i) : i(); } else a();
      }; const U = (e, t) => { let n; while (e !== t)n = m(e), i(e), e = n; i(t); }; const G = (e, t, n) => {
        const {
          bum: i, effects: o, update: a, subTree: s, um: l,
        } = e; if (i && Object(r.l)(i), o) for (let r = 0; r < o.length; r++)f(o[r]); a && (f(a), $(s, e, t, n)), l && Yn(l, t), Yn(() => { e.isUnmounted = !0; }, t), t && t.pendingBranch && !t.isUnmounted && e.asyncDep && !e.asyncResolved && e.suspenseId === t.pendingId && (t.deps--, t.deps === 0 && t.resolve());
      }; const K = (e, t, n, r = !1, i = !1, o = 0) => { for (let a = o; a < e.length; a++)$(e[a], t, n, r, i); }; const X = (e) => (6 & e.shapeFlag ? X(e.component.subTree) : 128 & e.shapeFlag ? e.suspense.next() : m(e.anchor || e.el)); const Y = (e, t, n) => { e == null ? t._vnode && $(t._vnode, null, null, !0) : x(t._vnode || null, e, t, null, null, null, n), st(), t._vnode = e; }; const Z = {
        p: x, um: $, m: q, r: V, mt: F, mc: M, pc: H, pbc: E, n: X, o: e,
      }; let J; let Q; return t && ([J, Q] = t(Z)), { render: Y, hydrate: J, createApp: Gn(Y, J) };
    } function er(e, t, n, r = null) { Fe(e, t, 7, [n, r]); } function tr(e, t, n = !1) { const i = e.children; const o = t.children; if (Object(r.m)(i) && Object(r.m)(o)) for (let r = 0; r < i.length; r++) { const e = i[r]; let t = o[r]; 1 & t.shapeFlag && !t.dynamicChildren && ((t.patchFlag <= 0 || t.patchFlag === 32) && (t = o[r] = Mr(o[r]), t.el = e.el), n || tr(e, t)); } } function nr(e) { const t = e.slice(); const n = [0]; let r; let i; let o; let a; let s; const l = e.length; for (r = 0; r < l; r++) { const l = e[r]; if (l !== 0) { if (i = n[n.length - 1], e[i] < l) { t[r] = i, n.push(r); continue; }o = 0, a = n.length - 1; while (o < a)s = (o + a) / 2 | 0, e[n[s]] < l ? o = s + 1 : a = s; l < e[n[o]] && (o > 0 && (t[r] = n[o - 1]), n[o] = r); } }o = n.length, a = n[o - 1]; while (o-- > 0)n[o] = a, a = t[a]; return n; } const rr = (e) => e.__isTeleport; const ir = 'components'; function or(e, t) { return sr(ir, e, !0, t) || e; } const ar = Symbol(); function sr(e, t, n = !0, i = !1) { const o = ht || Hr; if (o) { const n = o.type; if (e === ir) { const e = Jr(n); if (e && (e === t || e === Object(r.e)(t) || e === Object(r.f)(Object(r.e)(t)))) return n; } const a = lr(o[e] || n[e], t) || lr(o.appContext[e], t); return !a && i ? n : a; } } function lr(e, t) { return e && (e[t] || e[Object(r.e)(t)] || e[Object(r.f)(Object(r.e)(t))]); } const cr = Symbol(void 0); const ur = Symbol(void 0); const fr = Symbol(void 0); const dr = Symbol(void 0); const hr = []; let pr = null; function mr(e = !1) { hr.push(pr = e ? null : []); } function gr() { hr.pop(), pr = hr[hr.length - 1] || null; }let vr = 1; function br(e) { vr += e; } function yr(e, t, n, i, o) { const a = Sr(e, t, n, i, o, !0); return a.dynamicChildren = vr > 0 ? pr || r.a : null, gr(), vr > 0 && pr && pr.push(a), a; } function wr(e) { return !!e && !0 === e.__v_isVNode; } function xr(e, t) { return e.type === t.type && e.key === t.key; } const kr = '__vInternal'; const _r = ({ key: e }) => (e != null ? e : null); const Cr = ({ ref: e }) => (e != null ? Object(r.B)(e) || _e(e) || Object(r.n)(e) ? { i: ht, r: e } : e : null); const Sr = Or; function Or(e, t = null, n = null, i = 0, o = null, a = !1) {
      if (e && e !== ar || (e = fr), wr(e)) { const r = jr(e, t, !0); return n && Ar(r, n), r; } if (Qr(e) && (e = e.__vccOpts), t) { (we(t) || kr in t) && (t = Object(r.h)({}, t)); let{ class: e, style: n } = t; e && !Object(r.B)(e) && (t.class = Object(r.G)(e)), Object(r.t)(n) && (we(n) && !Object(r.m)(n) && (n = Object(r.h)({}, n)), t.style = Object(r.H)(n)); } const s = Object(r.B)(e) ? 1 : Ot(e) ? 128 : rr(e) ? 64 : Object(r.t)(e) ? 4 : Object(r.n)(e) ? 2 : 0; const l = {
        __v_isVNode: !0, __v_skip: !0, type: e, props: t, key: t && _r(t), ref: t && Cr(t), scopeId: pt, slotScopeIds: null, children: null, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetAnchor: null, staticCount: 0, shapeFlag: s, patchFlag: i, dynamicProps: o, dynamicChildren: null, appContext: null,
      }; return Ar(l, n), 128 & s && e.normalize(l), vr > 0 && !a && pr && (i > 0 || 6 & s) && i !== 32 && pr.push(l), l;
    } function jr(e, t, n = !1) {
      const {
        props: i, ref: o, patchFlag: a, children: s,
      } = e; const l = t ? Er(i || {}, t) : i; const c = {
        __v_isVNode: !0, __v_skip: !0, type: e.type, props: l, key: l && _r(l), ref: t && t.ref ? n && o ? Object(r.m)(o) ? o.concat(Cr(t)) : [o, Cr(t)] : Cr(t) : o, scopeId: e.scopeId, slotScopeIds: e.slotScopeIds, children: s, target: e.target, targetAnchor: e.targetAnchor, staticCount: e.staticCount, shapeFlag: e.shapeFlag, patchFlag: t && e.type !== cr ? a === -1 ? 16 : 16 | a : a, dynamicProps: e.dynamicProps, dynamicChildren: e.dynamicChildren, appContext: e.appContext, dirs: e.dirs, transition: e.transition, component: e.component, suspense: e.suspense, ssContent: e.ssContent && jr(e.ssContent), ssFallback: e.ssFallback && jr(e.ssFallback), el: e.el, anchor: e.anchor,
      }; return c;
    } function Lr(e = ' ', t = 0) { return Sr(ur, null, e, t); } function Tr(e) { return e == null || typeof e === 'boolean' ? Sr(fr) : Object(r.m)(e) ? Sr(cr, null, e.slice()) : typeof e === 'object' ? Mr(e) : Sr(ur, null, String(e)); } function Mr(e) { return e.el === null ? e : jr(e); } function Ar(e, t) { let n = 0; const { shapeFlag: i } = e; if (t == null)t = null; else if (Object(r.m)(t))n = 16; else if (typeof t === 'object') { if (1 & i || 64 & i) { const n = t.default; return void (n && (n._c && (n._d = !1), Ar(e, n()), n._c && (n._d = !0))); } { n = 32; const r = t._; r || kr in t ? r === 3 && ht && (ht.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) : t._ctx = ht; } } else Object(r.n)(t) ? (t = { default: t, _ctx: ht }, n = 32) : (t = String(t), 64 & i ? (n = 16, t = [Lr(t)]) : n = 8); e.children = t, e.shapeFlag |= n; } function Er(...e) { const t = Object(r.h)({}, e[0]); for (let n = 1; n < e.length; n++) { const i = e[n]; for (const e in i) if (e === 'class')t.class !== i.class && (t.class = Object(r.G)([t.class, i.class])); else if (e === 'style')t.style = Object(r.H)([t.style, i.style]); else if (Object(r.u)(e)) { const n = t[e]; const r = i[e]; n !== r && (t[e] = n ? [].concat(n, r) : r); } else e !== '' && (t[e] = i[e]); } return t; } const Pr = (e) => (e ? qr(e) ? e.exposed ? e.exposed : e.proxy : Pr(e.parent) : null); const Dr = Object(r.h)(Object.create(null), {
      $: (e) => e, $el: (e) => e.vnode.el, $data: (e) => e.data, $props: (e) => e.props, $attrs: (e) => e.attrs, $slots: (e) => e.slots, $refs: (e) => e.refs, $parent: (e) => Pr(e.parent), $root: (e) => Pr(e.root), $emit: (e) => e.emit, $options: (e) => wn(e), $forceUpdate: (e) => () => et(e.update), $nextTick: (e) => Je.bind(e.proxy), $watch: (e) => Pt.bind(e),
    }); const Nr = {
      get({ _: e }, t) {
        const {
          ctx: n, setupState: i, data: o, props: a, accessCache: s, type: l, appContext: c,
        } = e; if (t === '__v_skip') return !0; let u; if (t[0] !== '$') { const l = s[t]; if (void 0 !== l) switch (l) { case 0: return i[t]; case 1: return o[t]; case 3: return n[t]; case 2: return a[t]; } else { if (i !== r.b && Object(r.j)(i, t)) return s[t] = 0, i[t]; if (o !== r.b && Object(r.j)(o, t)) return s[t] = 1, o[t]; if ((u = e.propsOptions[0]) && Object(r.j)(u, t)) return s[t] = 2, a[t]; if (n !== r.b && Object(r.j)(n, t)) return s[t] = 3, n[t]; mn && (s[t] = 4); } } const f = Dr[t]; let d; let h; return f ? (t === '$attrs' && w(e, 'get', t), f(e)) : (d = l.__cssModules) && (d = d[t]) ? d : n !== r.b && Object(r.j)(n, t) ? (s[t] = 3, n[t]) : (h = c.config.globalProperties, Object(r.j)(h, t) ? h[t] : void 0);
      },
      set({ _: e }, t, n) { const { data: i, setupState: o, ctx: a } = e; if (o !== r.b && Object(r.j)(o, t))o[t] = n; else if (i !== r.b && Object(r.j)(i, t))i[t] = n; else if (Object(r.j)(e.props, t)) return !1; return (t[0] !== '$' || !(t.slice(1) in e)) && (a[t] = n, !0); },
      has({
        _: {
          data: e, setupState: t, accessCache: n, ctx: i, appContext: o, propsOptions: a,
        },
      }, s) { let l; return void 0 !== n[s] || e !== r.b && Object(r.j)(e, s) || t !== r.b && Object(r.j)(t, s) || (l = a[0]) && Object(r.j)(l, s) || Object(r.j)(i, s) || Object(r.j)(Dr, s) || Object(r.j)(o.config.globalProperties, s); },
    }; const Fr = Object(r.h)({}, Nr, { get(e, t) { if (t !== Symbol.unscopables) return Nr.get(e, t, e); }, has(e, t) { const n = t[0] !== '_' && !Object(r.o)(t); return n; } }); const zr = Vn(); let Ir = 0; function Br(e, t, n) {
      const i = e.type; const o = (t ? t.appContext : e.appContext) || zr; const a = {
        uid: Ir++, vnode: e, type: i, parent: t, appContext: o, root: null, next: null, subTree: null, update: null, render: null, proxy: null, exposed: null, withProxy: null, effects: null, provides: t ? t.provides : Object.create(o.provides), accessCache: null, renderCache: [], components: null, directives: null, propsOptions: En(i, o), emitsOptions: ft(i, o), emit: null, emitted: null, propsDefaults: r.b, inheritAttrs: i.inheritAttrs, ctx: r.b, data: r.b, props: r.b, attrs: r.b, slots: r.b, refs: r.b, setupState: r.b, setupContext: null, suspense: n, suspenseId: n ? n.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null,
      }; return a.ctx = { _: a }, a.root = t ? t.root : a, a.emit = ut.bind(null, a), a;
    }let Hr = null; const Rr = () => Hr || ht; const Wr = (e) => { Hr = e; }; function qr(e) { return 4 & e.vnode.shapeFlag; }let $r; let Vr = !1; function Ur(e, t = !1) { Vr = t; const { props: n, children: r } = e.vnode; const i = qr(e); Ln(e, n, i, t), Wn(e, r); const o = i ? Gr(e, t) : void 0; return Vr = !1, o; } function Gr(e, t) { const n = e.type; e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, Nr); const { setup: i } = n; if (i) { const n = e.setupContext = i.length > 1 ? Yr(e) : null; Hr = e, v(); const o = Ne(i, e, 0, [e.props, n]); if (y(), Hr = null, Object(r.w)(o)) { if (t) return o.then((n) => { Kr(e, n, t); }).catch((t) => { ze(t, e, 0); }); e.asyncDep = o; } else Kr(e, o, t); } else Xr(e, t); } function Kr(e, t, n) { Object(r.n)(t) ? e.render = t : Object(r.t)(t) && (e.setupState = Me(t)), Xr(e, n); } function Xr(e, t, n) { const i = e.type; if (!e.render) { if ($r && !i.render) { const t = i.template; if (t) { 0; const { isCustomElement: n, compilerOptions: o } = e.appContext.config; const { delimiters: a, compilerOptions: s } = i; const l = Object(r.h)(Object(r.h)({ isCustomElement: n, delimiters: a }, o), s); i.render = $r(t, l); } }e.render = i.render || r.d, e.render._rc && (e.withProxy = new Proxy(e.ctx, Fr)); }Hr = e, v(), gn(e), y(), Hr = null; } function Yr(e) {
      const t = (t) => { e.exposed = Me(t); }; return {
        attrs: e.attrs, slots: e.slots, emit: e.emit, expose: t,
      };
    } function Zr(e, t = Hr) { t && (t.effects || (t.effects = [])).push(e); } function Jr(e) { return Object(r.n)(e) && e.displayName || e.name; } function Qr(e) { return Object(r.n)(e) && '__vccOpts' in e; } function ei(e) { const t = De(e); return Zr(t.effect), t; } function ti(e, t, n) { const i = arguments.length; return i === 2 ? Object(r.t)(t) && !Object(r.m)(t) ? wr(t) ? Sr(e, null, [t]) : Sr(e, t) : Sr(e, null, t) : (i > 3 ? n = Array.prototype.slice.call(arguments, 2) : i === 3 && wr(n) && (n = [n]), Sr(e, t, n)); }Symbol(''); const ni = '3.1.1'; const ri = 'http://www.w3.org/2000/svg'; const ii = typeof document !== 'undefined' ? document : null; let oi; let ai; const si = {
      insert: (e, t, n) => { t.insertBefore(e, n || null); }, remove: (e) => { const t = e.parentNode; t && t.removeChild(e); }, createElement: (e, t, n, r) => { const i = t ? ii.createElementNS(ri, e) : ii.createElement(e, n ? { is: n } : void 0); return e === 'select' && r && r.multiple != null && i.setAttribute('multiple', r.multiple), i; }, createText: (e) => ii.createTextNode(e), createComment: (e) => ii.createComment(e), setText: (e, t) => { e.nodeValue = t; }, setElementText: (e, t) => { e.textContent = t; }, parentNode: (e) => e.parentNode, nextSibling: (e) => e.nextSibling, querySelector: (e) => ii.querySelector(e), setScopeId(e, t) { e.setAttribute(t, ''); }, cloneNode(e) { const t = e.cloneNode(!0); return '_value' in e && (t._value = e._value), t; }, insertStaticContent(e, t, n, r) { const i = r ? ai || (ai = ii.createElementNS(ri, 'svg')) : oi || (oi = ii.createElement('div')); i.innerHTML = e; const o = i.firstChild; let a = o; let s = a; while (a)s = a, si.insert(a, t, n), a = i.firstChild; return [o, s]; },
    }; function li(e, t, n) { if (t == null && (t = ''), n)e.setAttribute('class', t); else { const n = e._vtc; n && (t = (t ? [t, ...n] : [...n]).join(' ')), e.className = t; } } function ci(e, t, n) { const i = e.style; if (n) if (Object(r.B)(n)) { if (t !== n) { const t = i.display; i.cssText = n, '_vod' in e && (i.display = t); } } else { for (const e in n)fi(i, e, n[e]); if (t && !Object(r.B)(t)) for (const e in t)n[e] == null && fi(i, e, ''); } else e.removeAttribute('style'); } const ui = /\s*!important$/; function fi(e, t, n) { if (Object(r.m)(n))n.forEach((n) => fi(e, t, n)); else if (t.startsWith('--'))e.setProperty(t, n); else { const i = pi(e, t); ui.test(n) ? e.setProperty(Object(r.k)(i), n.replace(ui, ''), 'important') : e[i] = n; } } const di = ['Webkit', 'Moz', 'ms']; const hi = {}; function pi(e, t) { const n = hi[t]; if (n) return n; let i = Object(r.e)(t); if (i !== 'filter' && i in e) return hi[t] = i; i = Object(r.f)(i); for (let r = 0; r < di.length; r++) { const n = di[r] + i; if (n in e) return hi[t] = n; } return t; } const mi = 'http://www.w3.org/1999/xlink'; function gi(e, t, n, i, o) { if (i && t.startsWith('xlink:'))n == null ? e.removeAttributeNS(mi, t.slice(6, t.length)) : e.setAttributeNS(mi, t, n); else { const i = Object(r.A)(t); n == null || i && !1 === n ? e.removeAttribute(t) : e.setAttribute(t, i ? '' : n); } } function vi(e, t, n, r, i, o, a) { if (t === 'innerHTML' || t === 'textContent') return r && a(r, i, o), void (e[t] = n == null ? '' : n); if (t === 'value' && e.tagName !== 'PROGRESS') { e._value = n; const r = n == null ? '' : n; return e.value !== r && (e.value = r), void (n == null && e.removeAttribute(t)); } if (n === '' || n == null) { const r = typeof e[t]; if (n === '' && r === 'boolean') return void (e[t] = !0); if (n == null && r === 'string') return e[t] = '', void e.removeAttribute(t); if (r === 'number') return e[t] = 0, void e.removeAttribute(t); } try { e[t] = n; } catch (s) { 0; } }let bi = Date.now; let yi = !1; if (typeof window !== 'undefined') { bi() > document.createEvent('Event').timeStamp && (bi = () => performance.now()); const e = navigator.userAgent.match(/firefox\/(\d+)/i); yi = !!(e && Number(e[1]) <= 53); }let wi = 0; const xi = Promise.resolve(); const ki = () => { wi = 0; }; const _i = () => wi || (xi.then(ki), wi = bi()); function Ci(e, t, n, r) { e.addEventListener(t, n, r); } function Si(e, t, n, r) { e.removeEventListener(t, n, r); } function Oi(e, t, n, r, i = null) { const o = e._vei || (e._vei = {}); const a = o[t]; if (r && a)a.value = r; else { const [n, s] = Li(t); if (r) { const a = o[t] = Ti(r, i); Ci(e, n, a, s); } else a && (Si(e, n, a, s), o[t] = void 0); } } const ji = /(?:Once|Passive|Capture)$/; function Li(e) { let t; if (ji.test(e)) { let n; t = {}; while (n = e.match(ji))e = e.slice(0, e.length - n[0].length), t[n[0].toLowerCase()] = !0; } return [Object(r.k)(e.slice(2)), t]; } function Ti(e, t) { const n = (e) => { const r = e.timeStamp || bi(); (yi || r >= n.attached - 1) && Fe(Mi(e, n.value), t, 5, [e]); }; return n.value = e, n.attached = _i(), n; } function Mi(e, t) { if (Object(r.m)(t)) { const n = e.stopImmediatePropagation; return e.stopImmediatePropagation = () => { n.call(e), e._stopped = !0; }, t.map((e) => (t) => !t._stopped && e(t)); } return t; } const Ai = /^on[a-z]/; const Ei = (e, t) => t === 'value'; const Pi = (e, t, n, i, o = !1, a, s, l, c) => { switch (t) { case 'class': li(e, i, o); break; case 'style': ci(e, n, i); break; default: Object(r.u)(t) ? Object(r.s)(t) || Oi(e, t, n, i, s) : Di(e, t, i, o) ? vi(e, t, i, a, s, l, c) : (t === 'true-value' ? e._trueValue = i : t === 'false-value' && (e._falseValue = i), gi(e, t, i, o)); break; } }; function Di(e, t, n, i) { return i ? t === 'innerHTML' || !!(t in e && Ai.test(t) && Object(r.n)(n)) : t !== 'spellcheck' && t !== 'draggable' && (t !== 'form' && ((t !== 'list' || e.tagName !== 'INPUT') && ((t !== 'type' || e.tagName !== 'TEXTAREA') && ((!Ai.test(t) || !Object(r.B)(n)) && t in e)))); } const Ni = 'transition'; const Fi = 'animation'; const zi = (e, { slots: t }) => ti(Bt, Ri(e), t); zi.displayName = 'Transition'; const Ii = {
      name: String, type: String, css: { type: Boolean, default: !0 }, duration: [String, Number, Object], enterFromClass: String, enterActiveClass: String, enterToClass: String, appearFromClass: String, appearActiveClass: String, appearToClass: String, leaveFromClass: String, leaveActiveClass: String, leaveToClass: String,
    }; const Bi = (zi.props = Object(r.h)({}, Bt.props, Ii), (e, t = []) => { Object(r.m)(e) ? e.forEach((e) => e(...t)) : e && e(...t); }); const Hi = (e) => !!e && (Object(r.m)(e) ? e.some((e) => e.length > 1) : e.length > 1); function Ri(e) {
      const t = {}; for (const r in e)r in Ii || (t[r] = e[r]); if (!1 === e.css) return t; const {
        name: n = 'v', type: i, duration: o, enterFromClass: a = `${n}-enter-from`, enterActiveClass: s = `${n}-enter-active`, enterToClass: l = `${n}-enter-to`, appearFromClass: c = a, appearActiveClass: u = s, appearToClass: f = l, leaveFromClass: d = `${n}-leave-from`, leaveActiveClass: h = `${n}-leave-active`, leaveToClass: p = `${n}-leave-to`,
      } = e; const m = Wi(o); const g = m && m[0]; const v = m && m[1]; const {
        onBeforeEnter: b, onEnter: y, onEnterCancelled: w, onLeave: x, onLeaveCancelled: k, onBeforeAppear: _ = b, onAppear: C = y, onAppearCancelled: S = w,
      } = t; const O = (e, t, n) => { Vi(e, t ? f : l), Vi(e, t ? u : s), n && n(); }; const j = (e, t) => { Vi(e, p), Vi(e, h), t && t(); }; const L = (e) => (t, n) => { const r = e ? C : y; const o = () => O(t, e, n); Bi(r, [t, o]), Ui(() => { Vi(t, e ? c : a), $i(t, e ? f : l), Hi(r) || Ki(t, i, g, o); }); }; return Object(r.h)(t, {
        onBeforeEnter(e) { Bi(b, [e]), $i(e, a), $i(e, s); }, onBeforeAppear(e) { Bi(_, [e]), $i(e, c), $i(e, u); }, onEnter: L(!1), onAppear: L(!0), onLeave(e, t) { const n = () => j(e, t); $i(e, d), Ji(), $i(e, h), Ui(() => { Vi(e, d), $i(e, p), Hi(x) || Ki(e, i, v, n); }), Bi(x, [e, n]); }, onEnterCancelled(e) { O(e, !1), Bi(w, [e]); }, onAppearCancelled(e) { O(e, !0), Bi(S, [e]); }, onLeaveCancelled(e) { j(e), Bi(k, [e]); },
      });
    } function Wi(e) { if (e == null) return null; if (Object(r.t)(e)) return [qi(e.enter), qi(e.leave)]; { const t = qi(e); return [t, t]; } } function qi(e) { const t = Object(r.K)(e); return t; } function $i(e, t) { t.split(/\s+/).forEach((t) => t && e.classList.add(t)), (e._vtc || (e._vtc = new Set())).add(t); } function Vi(e, t) { t.split(/\s+/).forEach((t) => t && e.classList.remove(t)); const { _vtc: n } = e; n && (n.delete(t), n.size || (e._vtc = void 0)); } function Ui(e) { requestAnimationFrame(() => { requestAnimationFrame(e); }); }let Gi = 0; function Ki(e, t, n, r) { const i = e._endId = ++Gi; const o = () => { i === e._endId && r(); }; if (n) return setTimeout(o, n); const { type: a, timeout: s, propCount: l } = Xi(e, t); if (!a) return r(); const c = `${a}end`; let u = 0; const f = () => { e.removeEventListener(c, d), o(); }; const d = (t) => { t.target === e && ++u >= l && f(); }; setTimeout(() => { u < l && f(); }, s + 1), e.addEventListener(c, d); } function Xi(e, t) {
      const n = window.getComputedStyle(e); const r = (e) => (n[e] || '').split(', '); const i = r(`${Ni}Delay`); const o = r(`${Ni}Duration`); const a = Yi(i, o); const s = r(`${Fi}Delay`); const l = r(`${Fi}Duration`); const c = Yi(s, l); let u = null; let f = 0; let d = 0; t === Ni ? a > 0 && (u = Ni, f = a, d = o.length) : t === Fi ? c > 0 && (u = Fi, f = c, d = l.length) : (f = Math.max(a, c), u = f > 0 ? a > c ? Ni : Fi : null, d = u ? u === Ni ? o.length : l.length : 0); const h = u === Ni && /\b(transform|all)(,|$)/.test(n[`${Ni}Property`]); return {
        type: u, timeout: f, propCount: d, hasTransform: h,
      };
    } function Yi(e, t) { while (e.length < t.length)e = e.concat(e); return Math.max(...t.map((t, n) => Zi(t) + Zi(e[n]))); } function Zi(e) { return 1e3 * Number(e.slice(0, -1).replace(',', '.')); } function Ji() { return document.body.offsetHeight; } new WeakMap(), new WeakMap(); const Qi = Object(r.h)({ patchProp: Pi, forcePatchProp: Ei }, si); let eo; function to() { return eo || (eo = Jn(Qi)); } const no = (...e) => { const t = to().createApp(...e); const { mount: n } = t; return t.mount = (e) => { const i = ro(e); if (!i) return; const o = t._component; Object(r.n)(o) || o.render || o.template || (o.template = i.innerHTML), i.innerHTML = ''; const a = n(i, !1, i instanceof SVGElement); return i instanceof Element && (i.removeAttribute('v-cloak'), i.setAttribute('data-v-app', '')), a; }, t; }; function ro(e) { if (Object(r.B)(e)) { const t = document.querySelector(e); return t; } return e; }
  },
  '7b0b': function (e, t, n) { const r = n('1d80'); e.exports = function (e) { return Object(r(e)); }; },
  '7c73': function (e, t, n) { let r; const i = n('825a'); const o = n('37e8'); const a = n('7839'); const s = n('d012'); const l = n('1be4'); const c = n('cc12'); const u = n('f772'); const f = '>'; const d = '<'; const h = 'prototype'; const p = 'script'; const m = u('IE_PROTO'); const g = function () {}; const v = function (e) { return `${d + p + f + e + d}/${p}${f}`; }; const b = function (e) { e.write(v('')), e.close(); const t = e.parentWindow.Object; return e = null, t; }; const y = function () { let e; const t = c('iframe'); const n = `java${p}:`; return t.style.display = 'none', l.appendChild(t), t.src = String(n), e = t.contentWindow.document, e.open(), e.write(v('document.F=Object')), e.close(), e.F; }; var w = function () { try { r = document.domain && new ActiveXObject('htmlfile'); } catch (t) {}w = r ? b(r) : y(); let e = a.length; while (e--) delete w[h][a[e]]; return w(); }; s[m] = !0, e.exports = Object.create || function (e, t) { let n; return e !== null ? (g[h] = i(e), n = new g(), g[h] = null, n[m] = e) : n = w(), void 0 === t ? n : o(n, t); }; },
  '7dd0': function (e, t, n) {
    const r = n('23e7'); const i = n('9ed3'); const o = n('e163'); const a = n('d2bb'); const s = n('d44e'); const l = n('9112'); const c = n('6eeb'); const u = n('b622'); const f = n('c430'); const d = n('3f8c'); const h = n('ae93'); const p = h.IteratorPrototype; const m = h.BUGGY_SAFARI_ITERATORS; const g = u('iterator'); const v = 'keys'; const b = 'values'; const y = 'entries'; const w = function () { return this; }; e.exports = function (e, t, n, u, h, x, k) { i(n, t, u); let _; let C; let S; const O = function (e) { if (e === h && A) return A; if (!m && e in T) return T[e]; switch (e) { case v: return function () { return new n(this, e); }; case b: return function () { return new n(this, e); }; case y: return function () { return new n(this, e); }; } return function () { return new n(this); }; }; const j = `${t} Iterator`; let L = !1; var T = e.prototype; const M = T[g] || T['@@iterator'] || h && T[h]; var A = !m && M || O(h); const E = t == 'Array' && T.entries || M; if (E && (_ = o(E.call(new e())), p !== Object.prototype && _.next && (f || o(_) === p || (a ? a(_, p) : typeof _[g] !== 'function' && l(_, g, w)), s(_, j, !0, !0), f && (d[j] = w))), h == b && M && M.name !== b && (L = !0, A = function () { return M.call(this); }), f && !k || T[g] === A || l(T, g, A), d[t] = A, h) if (C = { values: O(b), keys: x ? A : O(v), entries: O(y) }, k) for (S in C)(m || L || !(S in T)) && c(T, S, C[S]); else r({ target: t, proto: !0, forced: m || L }, C); return C; };
  },
  '7f9a': function (e, t, n) { const r = n('da84'); const i = n('8925'); const o = r.WeakMap; e.exports = typeof o === 'function' && /native code/.test(i(o)); },
  '825a': function (e, t, n) { const r = n('861d'); e.exports = function (e) { if (!r(e)) throw TypeError(`${String(e)} is not an object`); return e; }; },
  '83ab': function (e, t, n) { const r = n('d039'); e.exports = !r((() => Object.defineProperty({}, 1, { get() { return 7; } })[1] != 7)); },
  '861d': function (e, t) { e.exports = function (e) { return typeof e === 'object' ? e !== null : typeof e === 'function'; }; },
  8925(e, t, n) { const r = n('c6cd'); const i = Function.toString; typeof r.inspectSource !== 'function' && (r.inspectSource = function (e) { return i.call(e); }), e.exports = r.inspectSource; },
  '90e3': function (e, t) { let n = 0; const r = Math.random(); e.exports = function (e) { return `Symbol(${String(void 0 === e ? '' : e)})_${(++n + r).toString(36)}`; }; },
  9112(e, t, n) { const r = n('83ab'); const i = n('9bf2'); const o = n('5c6c'); e.exports = r ? function (e, t, n) { return i.f(e, t, o(1, n)); } : function (e, t, n) { return e[t] = n, e; }; },
  9319(e, t, n) {
    const r = n('7a23'); function i() {
      let e = []; const t = (t, n) => { const r = e.length > 0 ? e[e.length - 1] : { key: t, value: n }; const i = r.value + (r.key === t ? 0 : n) + 1; return e.push({ key: t, value: i }), i; }; const n = (t) => { e = e.filter((e) => e.value !== t); }; const r = () => (e.length > 0 ? e[e.length - 1].value : 0); const i = (e) => e && parseInt(e.style.zIndex, 10) || 0; return {
        get: i, set: (e, n, r) => { n && (n.style.zIndex = String(t(e, r))); }, clear: (e) => { e && (n(i(e)), e.style.zIndex = ''); }, getCurrent: () => r(),
      };
    }i(); const o = {
      STARTS_WITH: 'startsWith', CONTAINS: 'contains', NOT_CONTAINS: 'notContains', ENDS_WITH: 'endsWith', EQUALS: 'equals', NOT_EQUALS: 'notEquals', IN: 'in', LESS_THAN: 'lt', LESS_THAN_OR_EQUAL_TO: 'lte', GREATER_THAN: 'gt', GREATER_THAN_OR_EQUAL_TO: 'gte', BETWEEN: 'between', DATE_IS: 'dateIs', DATE_IS_NOT: 'dateIsNot', DATE_BEFORE: 'dateBefore', DATE_AFTER: 'dateAfter',
    }; const a = {
      ripple: !1,
      inputStyle: 'outlined',
      locale: {
        startsWith: 'Starts with', contains: 'Contains', notContains: 'Not contains', endsWith: 'Ends with', equals: 'Equals', notEquals: 'Not equals', noFilter: 'No Filter', lt: 'Less than', lte: 'Less than or equal to', gt: 'Greater than', gte: 'Greater than or equal to', dateIs: 'Date is', dateIsNot: 'Date is not', dateBefore: 'Date is before', dateAfter: 'Date is after', clear: 'Clear', apply: 'Apply', matchAll: 'Match All', matchAny: 'Match Any', addRule: 'Add Rule', removeRule: 'Remove Rule', accept: 'Yes', reject: 'No', choose: 'Choose', upload: 'Upload', cancel: 'Cancel', dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'], dayNamesMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'], monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'], monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], today: 'Today', weekHeader: 'Wk', firstDayOfWeek: 0, dateFormat: 'mm/dd/yy', weak: 'Weak', medium: 'Medium', strong: 'Strong', passwordPrompt: 'Enter a password', emptyFilterMessage: 'No results found', emptyMessage: 'No available options',
      },
      filterMatchModeOptions: { text: [o.STARTS_WITH, o.CONTAINS, o.NOT_CONTAINS, o.ENDS_WITH, o.EQUALS, o.NOT_EQUALS], numeric: [o.EQUALS, o.NOT_EQUALS, o.LESS_THAN, o.LESS_THAN_OR_EQUAL_TO, o.GREATER_THAN, o.GREATER_THAN_OR_EQUAL_TO], date: [o.DATE_IS, o.DATE_IS_NOT, o.DATE_BEFORE, o.DATE_AFTER] },
      zIndex: {
        modal: 1100, overlay: 1e3, menu: 1e3, tooltip: 1100,
      },
    }; const s = Symbol(); const l = { install: (e, t) => { const n = t ? { ...a, ...t } : { ...a }; const i = { config: Object(r.q)(n) }; e.config.globalProperties.$primevue = i, e.provide(s, i); } }; t.a = l;
  },
  '94ca': function (e, t, n) { const r = n('d039'); const i = /#|\.prototype\./; const o = function (e, t) { const n = s[a(e)]; return n == c || n != l && (typeof t === 'function' ? r(t) : !!t); }; var a = o.normalize = function (e) { return String(e).replace(i, '.').toLowerCase(); }; var s = o.data = {}; var l = o.NATIVE = 'N'; var c = o.POLYFILL = 'P'; e.exports = o; },
  '959b': function (e, t, n) {
    (function (e) { e(n('56b3'), n('d5e0'), n('f040')); }(((e) => {
      e.defineMode('markdown', ((t, n) => {
        const r = e.getMode(t, 'text/html'); const i = r.name == 'null'; function o(n) { if (e.findModeByName) { const r = e.findModeByName(n); r && (n = r.mime || r.mimes[0]); } const i = e.getMode(t, n); return i.name == 'null' ? null : i; } void 0 === n.highlightFormatting && (n.highlightFormatting = !1), void 0 === n.maxBlockquoteDepth && (n.maxBlockquoteDepth = 0), void 0 === n.taskLists && (n.taskLists = !1), void 0 === n.strikethrough && (n.strikethrough = !1), void 0 === n.emoji && (n.emoji = !1), void 0 === n.fencedCodeBlockHighlighting && (n.fencedCodeBlockHighlighting = !0), void 0 === n.fencedCodeBlockDefaultMode && (n.fencedCodeBlockDefaultMode = 'text/plain'), void 0 === n.xml && (n.xml = !0), void 0 === n.tokenTypeOverrides && (n.tokenTypeOverrides = {}); const a = {
          header: 'header', code: 'comment', quote: 'quote', list1: 'variable-2', list2: 'variable-3', list3: 'keyword', hr: 'hr', image: 'image', imageAltText: 'image-alt-text', imageMarker: 'image-marker', formatting: 'formatting', linkInline: 'link', linkEmail: 'link', linkText: 'link', linkHref: 'string', em: 'em', strong: 'strong', strikethrough: 'strikethrough', emoji: 'builtin',
        }; for (const s in a)a.hasOwnProperty(s) && n.tokenTypeOverrides[s] && (a[s] = n.tokenTypeOverrides[s]); const l = /^([*\-_])(?:\s*\1){2,}\s*$/; const c = /^(?:[*\-+]|^[0-9]+([.)]))\s+/; const u = /^\[(x| )\](?=\s)/i; const f = n.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/; const d = /^ {0,3}(?:\={1,}|-{2,})\s*$/; const h = /^[^#!\[\]*_\\<>` "'(~:]+/; const p = /^(~~~+|```+)[ \t]*([\w\/+#-]*)[^\n`]*$/; const m = /^\s*\[[^\]]+?\]:.*$/; const g = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/; const v = '    '; function b(e, t, n) { return t.f = t.inline = n, n(e, t); } function y(e, t, n) { return t.f = t.block = n, n(e, t); } function w(e) { return !e || !/\S/.test(e.string); } function x(t) { if (t.linkTitle = !1, t.linkHref = !1, t.linkText = !1, t.em = !1, t.strong = !1, t.strikethrough = !1, t.quote = 0, t.indentedCode = !1, t.f == _) { let n = i; if (!n) { const o = e.innerMode(r, t.htmlState); n = o.mode.name == 'xml' && o.state.tagStart === null && !o.state.context && o.state.tokenize.isInText; }n && (t.f = j, t.block = k, t.htmlState = null); } return t.trailingSpace = 0, t.trailingSpaceNewLine = !1, t.prevLine = t.thisLine, t.thisLine = { stream: null }, null; } function k(t, r) { const i = t.column() === r.indentation; const s = w(r.prevLine.stream); const h = r.indentedCode; const g = r.prevLine.hr; const v = !1 !== r.list; const y = (r.listStack[r.listStack.length - 1] || 0) + 3; r.indentedCode = !1; const x = r.indentation; if (r.indentationDiff === null && (r.indentationDiff = r.indentation, v)) { r.list = null; while (x < r.listStack[r.listStack.length - 1])r.listStack.pop(), r.listStack.length ? r.indentation = r.listStack[r.listStack.length - 1] : r.list = !1; !1 !== r.list && (r.indentationDiff = x - r.listStack[r.listStack.length - 1]); } const k = !s && !g && !r.prevLine.header && (!v || !h) && !r.prevLine.fencedCodeEnd; const _ = (!1 === r.list || g || s) && r.indentation <= y && t.match(l); let O = null; if (r.indentationDiff >= 4 && (h || r.prevLine.fencedCodeEnd || r.prevLine.header || s)) return t.skipToEnd(), r.indentedCode = !0, a.code; if (t.eatSpace()) return null; if (i && r.indentation <= y && (O = t.match(f)) && O[1].length <= 6) return r.quote = 0, r.header = O[1].length, r.thisLine.header = !0, n.highlightFormatting && (r.formatting = 'header'), r.f = r.inline, S(r); if (r.indentation <= y && t.eat('>')) return r.quote = i ? 1 : r.quote + 1, n.highlightFormatting && (r.formatting = 'quote'), t.eatSpace(), S(r); if (!_ && !r.setext && i && r.indentation <= y && (O = t.match(c))) { const j = O[1] ? 'ol' : 'ul'; return r.indentation = x + t.current().length, r.list = !0, r.quote = 0, r.listStack.push(r.indentation), r.em = !1, r.strong = !1, r.code = !1, r.strikethrough = !1, n.taskLists && t.match(u, !1) && (r.taskList = !0), r.f = r.inline, n.highlightFormatting && (r.formatting = ['list', `list-${j}`]), S(r); } return i && r.indentation <= y && (O = t.match(p, !0)) ? (r.quote = 0, r.fencedEndRE = new RegExp(`${O[1]}+ *$`), r.localMode = n.fencedCodeBlockHighlighting && o(O[2] || n.fencedCodeBlockDefaultMode), r.localMode && (r.localState = e.startState(r.localMode)), r.f = r.block = C, n.highlightFormatting && (r.formatting = 'code-block'), r.code = -1, S(r)) : r.setext || !(k && v || r.quote || !1 !== r.list || r.code || _ || m.test(t.string)) && (O = t.lookAhead(1)) && (O = O.match(d)) ? (r.setext ? (r.header = r.setext, r.setext = 0, t.skipToEnd(), n.highlightFormatting && (r.formatting = 'header')) : (r.header = O[0].charAt(0) == '=' ? 1 : 2, r.setext = r.header), r.thisLine.header = !0, r.f = r.inline, S(r)) : _ ? (t.skipToEnd(), r.hr = !0, r.thisLine.hr = !0, a.hr) : t.peek() === '[' ? b(t, r, E) : b(t, r, r.inline); } function _(t, n) { const o = r.token(t, n.htmlState); if (!i) { const a = e.innerMode(r, n.htmlState); (a.mode.name == 'xml' && a.state.tagStart === null && !a.state.context && a.state.tokenize.isInText || n.md_inside && t.current().indexOf('>') > -1) && (n.f = j, n.block = k, n.htmlState = null); } return o; } function C(e, t) { let r; const i = t.listStack[t.listStack.length - 1] || 0; const o = t.indentation < i; const s = i + 3; return t.fencedEndRE && t.indentation <= s && (o || e.match(t.fencedEndRE)) ? (n.highlightFormatting && (t.formatting = 'code-block'), o || (r = S(t)), t.localMode = t.localState = null, t.block = k, t.f = j, t.fencedEndRE = null, t.code = 0, t.thisLine.fencedCodeEnd = !0, o ? y(e, t, t.block) : r) : t.localMode ? t.localMode.token(e, t.localState) : (e.skipToEnd(), a.code); } function S(e) { const t = []; if (e.formatting) { t.push(a.formatting), typeof e.formatting === 'string' && (e.formatting = [e.formatting]); for (let r = 0; r < e.formatting.length; r++)t.push(`${a.formatting}-${e.formatting[r]}`), e.formatting[r] === 'header' && t.push(`${a.formatting}-${e.formatting[r]}-${e.header}`), e.formatting[r] === 'quote' && (!n.maxBlockquoteDepth || n.maxBlockquoteDepth >= e.quote ? t.push(`${a.formatting}-${e.formatting[r]}-${e.quote}`) : t.push('error')); } if (e.taskOpen) return t.push('meta'), t.length ? t.join(' ') : null; if (e.taskClosed) return t.push('property'), t.length ? t.join(' ') : null; if (e.linkHref ? t.push(a.linkHref, 'url') : (e.strong && t.push(a.strong), e.em && t.push(a.em), e.strikethrough && t.push(a.strikethrough), e.emoji && t.push(a.emoji), e.linkText && t.push(a.linkText), e.code && t.push(a.code), e.image && t.push(a.image), e.imageAltText && t.push(a.imageAltText, 'link'), e.imageMarker && t.push(a.imageMarker)), e.header && t.push(a.header, `${a.header}-${e.header}`), e.quote && (t.push(a.quote), !n.maxBlockquoteDepth || n.maxBlockquoteDepth >= e.quote ? t.push(`${a.quote}-${e.quote}`) : t.push(`${a.quote}-${n.maxBlockquoteDepth}`)), !1 !== e.list) { const i = (e.listStack.length - 1) % 3; i ? i === 1 ? t.push(a.list2) : t.push(a.list3) : t.push(a.list1); } return e.trailingSpaceNewLine ? t.push('trailing-space-new-line') : e.trailingSpace && t.push(`trailing-space-${e.trailingSpace % 2 ? 'a' : 'b'}`), t.length ? t.join(' ') : null; } function O(e, t) { if (e.match(h, !0)) return S(t); } function j(t, i) { const o = i.text(t, i); if (typeof o !== 'undefined') return o; if (i.list) return i.list = null, S(i); if (i.taskList) { const s = t.match(u, !0)[1] === ' '; return s ? i.taskOpen = !0 : i.taskClosed = !0, n.highlightFormatting && (i.formatting = 'task'), i.taskList = !1, S(i); } if (i.taskOpen = !1, i.taskClosed = !1, i.header && t.match(/^#+$/, !0)) return n.highlightFormatting && (i.formatting = 'header'), S(i); const l = t.next(); if (i.linkTitle) { i.linkTitle = !1; let c = l; l === '(' && (c = ')'), c = (`${c}`).replace(/([.?*+^\[\]\\(){}|-])/g, '\\$1'); const f = `^\\s*(?:[^${c}\\\\]+|\\\\\\\\|\\\\.)${c}`; if (t.match(new RegExp(f), !0)) return a.linkHref; } if (l === '`') { const d = i.formatting; n.highlightFormatting && (i.formatting = 'code'), t.eatWhile('`'); const h = t.current().length; if (i.code != 0 || i.quote && h != 1) { if (h == i.code) { var p = S(i); return i.code = 0, p; } return i.formatting = d, S(i); } return i.code = h, S(i); } if (i.code) return S(i); if (l === '\\' && (t.next(), n.highlightFormatting)) { var m = S(i); const v = `${a.formatting}-escape`; return m ? `${m} ${v}` : v; } if (l === '!' && t.match(/\[[^\]]*\] ?(?:\(|\[)/, !1)) return i.imageMarker = !0, i.image = !0, n.highlightFormatting && (i.formatting = 'image'), S(i); if (l === '[' && i.imageMarker && t.match(/[^\]]*\](\(.*?\)| ?\[.*?\])/, !1)) return i.imageMarker = !1, i.imageAltText = !0, n.highlightFormatting && (i.formatting = 'image'), S(i); if (l === ']' && i.imageAltText) { n.highlightFormatting && (i.formatting = 'image'); m = S(i); return i.imageAltText = !1, i.image = !1, i.inline = i.f = T, m; } if (l === '[' && !i.image) return i.linkText && t.match(/^.*?\]/) || (i.linkText = !0, n.highlightFormatting && (i.formatting = 'link')), S(i); if (l === ']' && i.linkText) { n.highlightFormatting && (i.formatting = 'link'); m = S(i); return i.linkText = !1, i.inline = i.f = t.match(/\(.*?\)| ?\[.*?\]/, !1) ? T : j, m; } if (l === '<' && t.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, !1)) { i.f = i.inline = L, n.highlightFormatting && (i.formatting = 'link'); m = S(i); return m ? m += ' ' : m = '', m + a.linkInline; } if (l === '<' && t.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, !1)) { i.f = i.inline = L, n.highlightFormatting && (i.formatting = 'link'); m = S(i); return m ? m += ' ' : m = '', m + a.linkEmail; } if (n.xml && l === '<' && t.match(/^(!--|\?|!\[CDATA\[|[a-z][a-z0-9-]*(?:\s+[a-z_:.\-]+(?:\s*=\s*[^>]+)?)*\s*(?:>|$))/i, !1)) { const b = t.string.indexOf('>', t.pos); if (b != -1) { const w = t.string.substring(t.start, b); /markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(w) && (i.md_inside = !0); } return t.backUp(1), i.htmlState = e.startState(r), y(t, i, _); } if (n.xml && l === '<' && t.match(/^\/\w*?>/)) return i.md_inside = !1, 'tag'; if (l === '*' || l === '_') { let x = 1; const k = t.pos == 1 ? ' ' : t.string.charAt(t.pos - 2); while (x < 3 && t.eat(l))x++; const C = t.peek() || ' '; const O = !/\s/.test(C) && (!g.test(C) || /\s/.test(k) || g.test(k)); const M = !/\s/.test(k) && (!g.test(k) || /\s/.test(C) || g.test(C)); let A = null; let E = null; if (x % 2 && (i.em || !O || l !== '*' && M && !g.test(k) ? i.em != l || !M || l !== '*' && O && !g.test(C) || (A = !1) : A = !0), x > 1 && (i.strong || !O || l !== '*' && M && !g.test(k) ? i.strong != l || !M || l !== '*' && O && !g.test(C) || (E = !1) : E = !0), E != null || A != null) { n.highlightFormatting && (i.formatting = A == null ? 'strong' : E == null ? 'em' : 'strong em'), !0 === A && (i.em = l), !0 === E && (i.strong = l); p = S(i); return !1 === A && (i.em = !1), !1 === E && (i.strong = !1), p; } } else if (l === ' ' && (t.eat('*') || t.eat('_'))) { if (t.peek() === ' ') return S(i); t.backUp(1); } if (n.strikethrough) if (l === '~' && t.eatWhile(l)) { if (i.strikethrough) { n.highlightFormatting && (i.formatting = 'strikethrough'); p = S(i); return i.strikethrough = !1, p; } if (t.match(/^[^\s]/, !1)) return i.strikethrough = !0, n.highlightFormatting && (i.formatting = 'strikethrough'), S(i); } else if (l === ' ' && t.match('~~', !0)) { if (t.peek() === ' ') return S(i); t.backUp(2); } if (n.emoji && l === ':' && t.match(/^(?:[a-z_\d+][a-z_\d+-]*|\-[a-z_\d+][a-z_\d+-]*):/)) { i.emoji = !0, n.highlightFormatting && (i.formatting = 'emoji'); const P = S(i); return i.emoji = !1, P; } return l === ' ' && (t.match(/^ +$/, !1) ? i.trailingSpace++ : i.trailingSpace && (i.trailingSpaceNewLine = !0)), S(i); } function L(e, t) { const r = e.next(); if (r === '>') { t.f = t.inline = j, n.highlightFormatting && (t.formatting = 'link'); let i = S(t); return i ? i += ' ' : i = '', i + a.linkInline; } return e.match(/^[^>]+/, !0), a.linkInline; } function T(e, t) { if (e.eatSpace()) return null; const r = e.next(); return r === '(' || r === '[' ? (t.f = t.inline = A(r === '(' ? ')' : ']'), n.highlightFormatting && (t.formatting = 'link-string'), t.linkHref = !0, S(t)) : 'error'; } const M = { ')': /^(?:[^\\\(\)]|\\.|\((?:[^\\\(\)]|\\.)*\))*?(?=\))/, ']': /^(?:[^\\\[\]]|\\.|\[(?:[^\\\[\]]|\\.)*\])*?(?=\])/ }; function A(e) { return function (t, r) { const i = t.next(); if (i === e) { r.f = r.inline = j, n.highlightFormatting && (r.formatting = 'link-string'); const o = S(r); return r.linkHref = !1, o; } return t.match(M[e]), r.linkHref = !0, S(r); }; } function E(e, t) { return e.match(/^([^\]\\]|\\.)*\]:/, !1) ? (t.f = P, e.next(), n.highlightFormatting && (t.formatting = 'link'), t.linkText = !0, S(t)) : b(e, t, j); } function P(e, t) { if (e.match(']:', !0)) { t.f = t.inline = D, n.highlightFormatting && (t.formatting = 'link'); const r = S(t); return t.linkText = !1, r; } return e.match(/^([^\]\\]|\\.)+/, !0), a.linkText; } function D(e, t) { return e.eatSpace() ? null : (e.match(/^[^\s]+/, !0), void 0 === e.peek() ? t.linkTitle = !0 : e.match(/^(?:\s+(?:"(?:[^"\\]|\\.)+"|'(?:[^'\\]|\\.)+'|\((?:[^)\\]|\\.)+\)))?/, !0), t.f = t.inline = j, `${a.linkHref} url`); } var N = {
          startState() {
            return {
              f: k, prevLine: { stream: null }, thisLine: { stream: null }, block: k, htmlState: null, indentation: 0, inline: j, text: O, formatting: !1, linkText: !1, linkHref: !1, linkTitle: !1, code: 0, em: !1, strong: !1, header: 0, setext: 0, hr: !1, taskList: !1, list: !1, listStack: [], quote: 0, trailingSpace: 0, trailingSpaceNewLine: !1, strikethrough: !1, emoji: !1, fencedEndRE: null,
            };
          },
          copyState(t) {
            return {
              f: t.f, prevLine: t.prevLine, thisLine: t.thisLine, block: t.block, htmlState: t.htmlState && e.copyState(r, t.htmlState), indentation: t.indentation, localMode: t.localMode, localState: t.localMode ? e.copyState(t.localMode, t.localState) : null, inline: t.inline, text: t.text, formatting: !1, linkText: t.linkText, linkTitle: t.linkTitle, linkHref: t.linkHref, code: t.code, em: t.em, strong: t.strong, strikethrough: t.strikethrough, emoji: t.emoji, header: t.header, setext: t.setext, hr: t.hr, taskList: t.taskList, list: t.list, listStack: t.listStack.slice(0), quote: t.quote, indentedCode: t.indentedCode, trailingSpace: t.trailingSpace, trailingSpaceNewLine: t.trailingSpaceNewLine, md_inside: t.md_inside, fencedEndRE: t.fencedEndRE,
            };
          },
          token(e, t) { if (t.formatting = !1, e != t.thisLine.stream) { if (t.header = 0, t.hr = !1, e.match(/^\s*$/, !0)) return x(t), null; if (t.prevLine = t.thisLine, t.thisLine = { stream: e }, t.taskList = !1, t.trailingSpace = 0, t.trailingSpaceNewLine = !1, !t.localState && (t.f = t.block, t.f != _)) { const n = e.match(/^\s*/, !0)[0].replace(/\t/g, v).length; if (t.indentation = n, t.indentationDiff = null, n > 0) return null; } } return t.f(e, t); },
          innerMode(e) { return e.block == _ ? { state: e.htmlState, mode: r } : e.localState ? { state: e.localState, mode: e.localMode } : { state: e, mode: N }; },
          indent(t, n, i) { return t.block == _ && r.indent ? r.indent(t.htmlState, n, i) : t.localState && t.localMode.indent ? t.localMode.indent(t.localState, n, i) : e.Pass; },
          blankLine: x,
          getType: S,
          blockCommentStart: '\x3c!--',
          blockCommentEnd: '--\x3e',
          closeBrackets: "()[]{}''\"\"``",
          fold: 'markdown',
        }; return N;
      }), 'xml'), e.defineMIME('text/markdown', 'markdown'), e.defineMIME('text/x-markdown', 'markdown');
    })));
  },
  '9ad7': function (e, t, n) {},
  '9bf2': function (e, t, n) { const r = n('83ab'); const i = n('0cfb'); const o = n('825a'); const a = n('c04e'); const s = Object.defineProperty; t.f = r ? s : function (e, t, n) { if (o(e), t = a(t, !0), o(n), i) try { return s(e, t, n); } catch (r) {} if ('get' in n || 'set' in n) throw TypeError('Accessors not supported'); return 'value' in n && (e[t] = n.value), e; }; },
  '9eb9': function (e, t, n) {
    (function (e) { e(n('56b3')); }(((e) => {
      e.overlayMode = function (t, n, r) {
        return {
          startState() {
            return {
              base: e.startState(t), overlay: e.startState(n), basePos: 0, baseCur: null, overlayPos: 0, overlayCur: null, streamSeen: null,
            };
          },
          copyState(r) {
            return {
              base: e.copyState(t, r.base), overlay: e.copyState(n, r.overlay), basePos: r.basePos, baseCur: null, overlayPos: r.overlayPos, overlayCur: null,
            };
          },
          token(e, i) { return (e != i.streamSeen || Math.min(i.basePos, i.overlayPos) < e.start) && (i.streamSeen = e, i.basePos = i.overlayPos = e.start), e.start == i.basePos && (i.baseCur = t.token(e, i.base), i.basePos = e.pos), e.start == i.overlayPos && (e.pos = e.start, i.overlayCur = n.token(e, i.overlay), i.overlayPos = e.pos), e.pos = Math.min(i.basePos, i.overlayPos), i.overlayCur == null ? i.baseCur : i.baseCur != null && i.overlay.combineTokens || r && i.overlay.combineTokens == null ? `${i.baseCur} ${i.overlayCur}` : i.overlayCur; },
          indent: t.indent && function (e, n, r) { return t.indent(e.base, n, r); },
          electricChars: t.electricChars,
          innerMode(e) { return { state: e.base, mode: t }; },
          blankLine(e) { let i; let o; return t.blankLine && (i = t.blankLine(e.base)), n.blankLine && (o = n.blankLine(e.overlay)), o == null ? i : r && i != null ? `${i} ${o}` : o; },
        };
      };
    })));
  },
  '9ed3': function (e, t, n) {
    const r = n('ae93').IteratorPrototype; const i = n('7c73'); const o = n('5c6c'); const a = n('d44e'); const s = n('3f8c'); const l = function () { return this; }; e.exports = function (e, t, n) { const c = `${t} Iterator`; return e.prototype = i(r, { next: o(1, n) }), a(e, c, !1, !0), s[c] = l, e; };
  },
  '9ff4': function (e, t, n) {
    (function (e) { function r(e, t) { const n = Object.create(null); const r = e.split(','); for (let i = 0; i < r.length; i++)n[r[i]] = !0; return t ? (e) => !!n[e.toLowerCase()] : (e) => !!n[e]; }n.d(t, 'a', (() => x)), n.d(t, 'b', (() => w)), n.d(t, 'c', (() => _)), n.d(t, 'd', (() => k)), n.d(t, 'e', (() => K)), n.d(t, 'f', (() => Z)), n.d(t, 'g', (() => te)), n.d(t, 'h', (() => j)), n.d(t, 'i', (() => Q)), n.d(t, 'j', (() => M)), n.d(t, 'k', (() => Y)), n.d(t, 'l', (() => ee)), n.d(t, 'm', (() => A)), n.d(t, 'n', (() => N)), n.d(t, 'o', (() => o)), n.d(t, 'p', (() => m)), n.d(t, 'q', (() => $)), n.d(t, 'r', (() => E)), n.d(t, 's', (() => O)), n.d(t, 't', (() => I)), n.d(t, 'u', (() => S)), n.d(t, 'v', (() => q)), n.d(t, 'w', (() => B)), n.d(t, 'x', (() => V)), n.d(t, 'y', (() => g)), n.d(t, 'z', (() => P)), n.d(t, 'A', (() => s)), n.d(t, 'B', (() => F)), n.d(t, 'C', (() => z)), n.d(t, 'D', (() => b)), n.d(t, 'E', (() => y)), n.d(t, 'F', (() => r)), n.d(t, 'G', (() => d)), n.d(t, 'H', (() => l)), n.d(t, 'I', (() => L)), n.d(t, 'J', (() => J)), n.d(t, 'K', (() => ne)), n.d(t, 'L', (() => W)); const i = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt'; const o = r(i); const a = 'itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly'; const s = r(a); function l(e) { if (A(e)) { const t = {}; for (let n = 0; n < e.length; n++) { const r = e[n]; const i = l(F(r) ? f(r) : r); if (i) for (const e in i)t[e] = i[e]; } return t; } if (I(e)) return e; } const c = /;(?![^(]*\))/g; const u = /:(.+)/; function f(e) { const t = {}; return e.split(c).forEach((e) => { if (e) { const n = e.split(u); n.length > 1 && (t[n[0].trim()] = n[1].trim()); } }), t; } function d(e) { let t = ''; if (F(e))t = e; else if (A(e)) for (let n = 0; n < e.length; n++) { const r = d(e[n]); r && (t += `${r} `); } else if (I(e)) for (const n in e)e[n] && (t += `${n} `); return t.trim(); } const h = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot'; const p = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view'; const m = r(h); const g = r(p); function v(e, t) { if (e.length !== t.length) return !1; let n = !0; for (let r = 0; n && r < e.length; r++)n = b(e[r], t[r]); return n; } function b(e, t) { if (e === t) return !0; let n = D(e); let r = D(t); if (n || r) return !(!n || !r) && e.getTime() === t.getTime(); if (n = A(e), r = A(t), n || r) return !(!n || !r) && v(e, t); if (n = I(e), r = I(t), n || r) { if (!n || !r) return !1; const i = Object.keys(e).length; const o = Object.keys(t).length; if (i !== o) return !1; for (const n in e) { const r = e.hasOwnProperty(n); const i = t.hasOwnProperty(n); if (r && !i || !r && i || !b(e[n], t[n])) return !1; } } return String(e) === String(t); } function y(e, t) { return e.findIndex((e) => b(e, t)); } const w = {}; const x = []; const k = () => {}; const _ = () => !1; const C = /^on[^a-z]/; const S = (e) => C.test(e); const O = (e) => e.startsWith('onUpdate:'); const j = Object.assign; const L = (e, t) => { const n = e.indexOf(t); n > -1 && e.splice(n, 1); }; const T = Object.prototype.hasOwnProperty; const M = (e, t) => T.call(e, t); const A = Array.isArray; const E = (e) => R(e) === '[object Map]'; const P = (e) => R(e) === '[object Set]'; const D = (e) => e instanceof Date; const N = (e) => typeof e === 'function'; const F = (e) => typeof e === 'string'; const z = (e) => typeof e === 'symbol'; const I = (e) => e !== null && typeof e === 'object'; const B = (e) => I(e) && N(e.then) && N(e.catch); const H = Object.prototype.toString; const R = (e) => H.call(e); const W = (e) => R(e).slice(8, -1); const q = (e) => R(e) === '[object Object]'; const $ = (e) => F(e) && e !== 'NaN' && e[0] !== '-' && `${parseInt(e, 10)}` === e; const V = r(',key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted'); const U = (e) => { const t = Object.create(null); return (n) => { const r = t[n]; return r || (t[n] = e(n)); }; }; const G = /-(\w)/g; const K = U((e) => e.replace(G, (e, t) => (t ? t.toUpperCase() : ''))); const X = /\B([A-Z])/g; const Y = U((e) => e.replace(X, '-$1').toLowerCase()); const Z = U((e) => e.charAt(0).toUpperCase() + e.slice(1)); const J = U((e) => (e ? `on${Z(e)}` : '')); const Q = (e, t) => e !== t && (e === e || t === t); const ee = (e, t) => { for (let n = 0; n < e.length; n++)e[n](t); }; const te = (e, t, n) => { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, value: n }); }; const ne = (e) => { const t = parseFloat(e); return isNaN(t) ? e : t; }; }).call(this, n('c8ba'));
  },
  a4b4(e, t, n) { const r = n('342f'); e.exports = /web0s(?!.*chrome)/i.test(r); },
  a691(e, t) { const n = Math.ceil; const r = Math.floor; e.exports = function (e) { return isNaN(e = +e) ? 0 : (e > 0 ? r : n)(e); }; },
  a79d(e, t, n) {
    const r = n('23e7'); const i = n('c430'); const o = n('fea9'); const a = n('d039'); const s = n('d066'); const l = n('4840'); const c = n('cdf9'); const u = n('6eeb'); const f = !!o && a((() => { o.prototype.finally.call({ then() {} }, (() => {})); })); if (r({
      target: 'Promise', proto: !0, real: !0, forced: f,
    }, { finally(e) { const t = l(this, s('Promise')); const n = typeof e === 'function'; return this.then(n ? (n) => c(t, e()).then((() => n)) : e, n ? (n) => c(t, e()).then((() => { throw n; })) : e); } }), !i && typeof o === 'function') { const d = s('Promise').prototype.finally; o.prototype.finally !== d && u(o.prototype, 'finally', d, { unsafe: !0 }); }
  },
  a7be(e, t, n) {},
  abc5(e, t, n) {
    (function (e) { function r() { return i().__VUE_DEVTOOLS_GLOBAL_HOOK__; } function i() { return typeof navigator !== 'undefined' ? window : typeof e !== 'undefined' ? e : {}; }n.d(t, 'a', (() => r)), n.d(t, 'b', (() => i)); }).call(this, n('c8ba'));
  },
  ae93(e, t, n) {
    let r; let i; let o; const a = n('d039'); const s = n('e163'); const l = n('9112'); const c = n('5135'); const u = n('b622'); const f = n('c430'); const d = u('iterator'); let h = !1; const p = function () { return this; }; [].keys && (o = [].keys(), 'next' in o ? (i = s(s(o)), i !== Object.prototype && (r = i)) : h = !0); const m = void 0 == r || a((() => { const e = {}; return r[d].call(e) !== e; })); m && (r = {}), f && !m || c(r, d) || l(r, d, p), e.exports = { IteratorPrototype: r, BUGGY_SAFARI_ITERATORS: h };
  },
  b041(e, t, n) {
    const r = n('00ee'); const i = n('f5df'); e.exports = r ? {}.toString : function () { return `[object ${i(this)}]`; };
  },
  b575(e, t, n) { let r; let i; let o; let a; let s; let l; let c; let u; const f = n('da84'); const d = n('06cf').f; const h = n('2cf4').set; const p = n('1cdc'); const m = n('a4b4'); const g = n('605d'); const v = f.MutationObserver || f.WebKitMutationObserver; const b = f.document; const y = f.process; const w = f.Promise; const x = d(f, 'queueMicrotask'); const k = x && x.value; k || (r = function () { let e; let t; g && (e = y.domain) && e.exit(); while (i) { t = i.fn, i = i.next; try { t(); } catch (n) { throw i ? a() : o = void 0, n; } }o = void 0, e && e.enter(); }, p || g || m || !v || !b ? w && w.resolve ? (c = w.resolve(void 0), c.constructor = w, u = c.then, a = function () { u.call(c, r); }) : a = g ? function () { y.nextTick(r); } : function () { h.call(f, r); } : (s = !0, l = b.createTextNode(''), new v(r).observe(l, { characterData: !0 }), a = function () { l.data = s = !s; })), e.exports = k || function (e) { const t = { fn: e, next: void 0 }; o && (o.next = t), i || (i = t, a()), o = t; }; },
  b622(e, t, n) { const r = n('da84'); const i = n('5692'); const o = n('5135'); const a = n('90e3'); const s = n('4930'); const l = n('fdbf'); const c = i('wks'); const u = r.Symbol; const f = l ? u : u && u.withoutSetter || a; e.exports = function (e) { return o(c, e) && (s || typeof c[e] === 'string') || (s && o(u, e) ? c[e] = u[e] : c[e] = f(`Symbol.${e}`)), c[e]; }; },
  b774(e, t, n) {
    n.d(t, 'a', (() => r)); const r = 'devtools-plugin:setup';
  },
  c04e(e, t, n) { const r = n('861d'); e.exports = function (e, t) { if (!r(e)) return e; let n; let i; if (t && typeof (n = e.toString) === 'function' && !r(i = n.call(e))) return i; if (typeof (n = e.valueOf) === 'function' && !r(i = n.call(e))) return i; if (!t && typeof (n = e.toString) === 'function' && !r(i = n.call(e))) return i; throw TypeError("Can't convert object to primitive value"); }; },
  c430(e, t) { e.exports = !1; },
  c6b6(e, t) { const n = {}.toString; e.exports = function (e) { return n.call(e).slice(8, -1); }; },
  c6cd(e, t, n) { const r = n('da84'); const i = n('ce4e'); const o = '__core-js_shared__'; const a = r[o] || i(o, {}); e.exports = a; },
  c8ba(e, t) { let n; n = (function () { return this; }()); try { n = n || new Function('return this')(); } catch (r) { typeof window === 'object' && (n = window); }e.exports = n; },
  ca84(e, t, n) { const r = n('5135'); const i = n('fc6a'); const o = n('4d64').indexOf; const a = n('d012'); e.exports = function (e, t) { let n; const s = i(e); let l = 0; const c = []; for (n in s)!r(a, n) && r(s, n) && c.push(n); while (t.length > l)r(s, n = t[l++]) && (~o(c, n) || c.push(n)); return c; }; },
  cc12(e, t, n) { const r = n('da84'); const i = n('861d'); const o = r.document; const a = i(o) && i(o.createElement); e.exports = function (e) { return a ? o.createElement(e) : {}; }; },
  cca6(e, t, n) { const r = n('23e7'); const i = n('60da'); r({ target: 'Object', stat: !0, forced: Object.assign !== i }, { assign: i }); },
  cdf9(e, t, n) { const r = n('825a'); const i = n('861d'); const o = n('f069'); e.exports = function (e, t) { if (r(e), i(t) && t.constructor === e) return t; const n = o.f(e); const a = n.resolve; return a(t), n.promise; }; },
  ce4e(e, t, n) { const r = n('da84'); const i = n('9112'); e.exports = function (e, t) { try { i(r, e, t); } catch (n) { r[e] = t; } return t; }; },
  d012(e, t) { e.exports = {}; },
  d039(e, t) { e.exports = function (e) { try { return !!e(); } catch (t) { return !0; } }; },
  d066(e, t, n) { const r = n('428f'); const i = n('da84'); const o = function (e) { return typeof e === 'function' ? e : void 0; }; e.exports = function (e, t) { return arguments.length < 2 ? o(r[e]) || o(i[e]) : r[e] && r[e][t] || i[e] && i[e][t]; }; },
  d1e7(e, t, n) {
    const r = {}.propertyIsEnumerable; const i = Object.getOwnPropertyDescriptor; const o = i && !r.call({ 1: 2 }, 1); t.f = o ? function (e) { const t = i(this, e); return !!t && t.enumerable; } : r;
  },
  d2bb(e, t, n) { const r = n('825a'); const i = n('3bbe'); e.exports = Object.setPrototypeOf || ('__proto__' in {} ? (function () { let e; let t = !1; const n = {}; try { e = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set, e.call(n, []), t = n instanceof Array; } catch (o) {} return function (n, o) { return r(n), i(o), t ? e.call(n, o) : n.__proto__ = o, n; }; }()) : void 0); },
  d3b7(e, t, n) { const r = n('00ee'); const i = n('6eeb'); const o = n('b041'); r || i(Object.prototype, 'toString', o, { unsafe: !0 }); },
  d44e(e, t, n) { const r = n('9bf2').f; const i = n('5135'); const o = n('b622'); const a = o('toStringTag'); e.exports = function (e, t, n) { e && !i(e = n ? e : e.prototype, a) && r(e, a, { configurable: !0, value: t }); }; },
  d5e0(e, t, n) {
    (function (e) { e(n('56b3')); }(((e) => {
      const t = {
        autoSelfClosers: {
          area: !0, base: !0, br: !0, col: !0, command: !0, embed: !0, frame: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0, menuitem: !0,
        },
        implicitlyClosed: {
          dd: !0, li: !0, optgroup: !0, option: !0, p: !0, rp: !0, rt: !0, tbody: !0, td: !0, tfoot: !0, th: !0, tr: !0,
        },
        contextGrabbers: {
          dd: { dd: !0, dt: !0 },
          dt: { dd: !0, dt: !0 },
          li: { li: !0 },
          option: { option: !0, optgroup: !0 },
          optgroup: { optgroup: !0 },
          p: {
            address: !0, article: !0, aside: !0, blockquote: !0, dir: !0, div: !0, dl: !0, fieldset: !0, footer: !0, form: !0, h1: !0, h2: !0, h3: !0, h4: !0, h5: !0, h6: !0, header: !0, hgroup: !0, hr: !0, menu: !0, nav: !0, ol: !0, p: !0, pre: !0, section: !0, table: !0, ul: !0,
          },
          rp: { rp: !0, rt: !0 },
          rt: { rp: !0, rt: !0 },
          tbody: { tbody: !0, tfoot: !0 },
          td: { td: !0, th: !0 },
          tfoot: { tbody: !0 },
          th: { td: !0, th: !0 },
          thead: { tbody: !0, tfoot: !0 },
          tr: { tr: !0 },
        },
        doNotIndent: { pre: !0 },
        allowUnquoted: !0,
        allowMissing: !0,
        caseFold: !0,
      }; const n = {
        autoSelfClosers: {}, implicitlyClosed: {}, contextGrabbers: {}, doNotIndent: {}, allowUnquoted: !1, allowMissing: !1, allowMissingTagName: !1, caseFold: !1,
      }; e.defineMode('xml', ((r, i) => {
        let o; let a; const s = r.indentUnit; const l = {}; const c = i.htmlMode ? t : n; for (var u in c)l[u] = c[u]; for (var u in i)l[u] = i[u]; function f(e, t) { function n(n) { return t.tokenize = n, n(e, t); } let r; const i = e.next(); return i == '<' ? e.eat('!') ? e.eat('[') ? e.match('CDATA[') ? n(p('atom', ']]>')) : null : e.match('--') ? n(p('comment', '--\x3e')) : e.match('DOCTYPE', !0, !0) ? (e.eatWhile(/[\w\._\-]/), n(m(1))) : null : e.eat('?') ? (e.eatWhile(/[\w\._\-]/), t.tokenize = p('meta', '?>'), 'meta') : (o = e.eat('/') ? 'closeTag' : 'openTag', t.tokenize = d, 'tag bracket') : i == '&' ? (r = e.eat('#') ? e.eat('x') ? e.eatWhile(/[a-fA-F\d]/) && e.eat(';') : e.eatWhile(/[\d]/) && e.eat(';') : e.eatWhile(/[\w\.\-:]/) && e.eat(';'), r ? 'atom' : 'error') : (e.eatWhile(/[^&<]/), null); } function d(e, t) { const n = e.next(); if (n == '>' || n == '/' && e.eat('>')) return t.tokenize = f, o = n == '>' ? 'endTag' : 'selfcloseTag', 'tag bracket'; if (n == '=') return o = 'equals', null; if (n == '<') { t.tokenize = f, t.state = y, t.tagName = t.tagStart = null; const r = t.tokenize(e, t); return r ? `${r} tag error` : 'tag error'; } return /[\'\"]/.test(n) ? (t.tokenize = h(n), t.stringStartCol = e.column(), t.tokenize(e, t)) : (e.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/), 'word'); } function h(e) { const t = function (t, n) { while (!t.eol()) if (t.next() == e) { n.tokenize = d; break; } return 'string'; }; return t.isInAttribute = !0, t; } function p(e, t) { return function (n, r) { while (!n.eol()) { if (n.match(t)) { r.tokenize = f; break; }n.next(); } return e; }; } function m(e) { return function (t, n) { let r; while ((r = t.next()) != null) { if (r == '<') return n.tokenize = m(e + 1), n.tokenize(t, n); if (r == '>') { if (e == 1) { n.tokenize = f; break; } return n.tokenize = m(e - 1), n.tokenize(t, n); } } return 'meta'; }; } function g(e, t, n) { this.prev = e.context, this.tagName = t || '', this.indent = e.indented, this.startOfLine = n, (l.doNotIndent.hasOwnProperty(t) || e.context && e.context.noIndent) && (this.noIndent = !0); } function v(e) { e.context && (e.context = e.context.prev); } function b(e, t) { let n; while (1) { if (!e.context) return; if (n = e.context.tagName, !l.contextGrabbers.hasOwnProperty(n) || !l.contextGrabbers[n].hasOwnProperty(t)) return; v(e); } } function y(e, t, n) { return e == 'openTag' ? (n.tagStart = t.column(), w) : e == 'closeTag' ? x : y; } function w(e, t, n) { return e == 'word' ? (n.tagName = t.current(), a = 'tag', C) : l.allowMissingTagName && e == 'endTag' ? (a = 'tag bracket', C(e, t, n)) : (a = 'error', w); } function x(e, t, n) { if (e == 'word') { const r = t.current(); return n.context && n.context.tagName != r && l.implicitlyClosed.hasOwnProperty(n.context.tagName) && v(n), n.context && n.context.tagName == r || !1 === l.matchClosing ? (a = 'tag', k) : (a = 'tag error', _); } return l.allowMissingTagName && e == 'endTag' ? (a = 'tag bracket', k(e, t, n)) : (a = 'error', _); } function k(e, t, n) { return e != 'endTag' ? (a = 'error', k) : (v(n), y); } function _(e, t, n) { return a = 'error', k(e, t, n); } function C(e, t, n) { if (e == 'word') return a = 'attribute', S; if (e == 'endTag' || e == 'selfcloseTag') { const r = n.tagName; const i = n.tagStart; return n.tagName = n.tagStart = null, e == 'selfcloseTag' || l.autoSelfClosers.hasOwnProperty(r) ? b(n, r) : (b(n, r), n.context = new g(n, r, i == n.indented)), y; } return a = 'error', C; } function S(e, t, n) { return e == 'equals' ? O : (l.allowMissing || (a = 'error'), C(e, t, n)); } function O(e, t, n) { return e == 'string' ? j : e == 'word' && l.allowUnquoted ? (a = 'string', C) : (a = 'error', C(e, t, n)); } function j(e, t, n) { return e == 'string' ? j : C(e, t, n); } return f.isInText = !0, {
          startState(e) {
            const t = {
              tokenize: f, state: y, indented: e || 0, tagName: null, tagStart: null, context: null,
            }; return e != null && (t.baseIndent = e), t;
          },
          token(e, t) { if (!t.tagName && e.sol() && (t.indented = e.indentation()), e.eatSpace()) return null; o = null; let n = t.tokenize(e, t); return (n || o) && n != 'comment' && (a = null, t.state = t.state(o || n, e, t), a && (n = a == 'error' ? `${n} error` : a)), n; },
          indent(t, n, r) { let i = t.context; if (t.tokenize.isInAttribute) return t.tagStart == t.indented ? t.stringStartCol + 1 : t.indented + s; if (i && i.noIndent) return e.Pass; if (t.tokenize != d && t.tokenize != f) return r ? r.match(/^(\s*)/)[0].length : 0; if (t.tagName) return !1 !== l.multilineTagIndentPastTag ? t.tagStart + t.tagName.length + 2 : t.tagStart + s * (l.multilineTagIndentFactor || 1); if (l.alignCDATA && /<!\[CDATA\[/.test(n)) return 0; const o = n && /^<(\/)?([\w_:\.-]*)/.exec(n); if (o && o[1]) while (i) { if (i.tagName == o[2]) { i = i.prev; break; } if (!l.implicitlyClosed.hasOwnProperty(i.tagName)) break; i = i.prev; } else if (o) while (i) { const a = l.contextGrabbers[i.tagName]; if (!a || !a.hasOwnProperty(o[2])) break; i = i.prev; } while (i && i.prev && !i.startOfLine)i = i.prev; return i ? i.indent + s : t.baseIndent || 0; },
          electricInput: /<\/[\s\w:]+>$/,
          blockCommentStart: '\x3c!--',
          blockCommentEnd: '--\x3e',
          configuration: l.htmlMode ? 'html' : 'xml',
          helperType: l.htmlMode ? 'html' : 'xml',
          skipAttribute(e) { e.state == O && (e.state = C); },
          xmlCurrentTag(e) { return e.tagName ? { name: e.tagName, close: e.type == 'closeTag' } : null; },
          xmlCurrentContext(e) { for (var t = [], n = e.context; n; n = n.prev)t.push(n.tagName); return t.reverse(); },
        };
      })), e.defineMIME('text/xml', 'xml'), e.defineMIME('application/xml', 'xml'), e.mimeModes.hasOwnProperty('text/html') || e.defineMIME('text/html', { name: 'xml', htmlMode: !0 });
    })));
  },
  da84(e, t, n) { (function (t) { const n = function (e) { return e && e.Math == Math && e; }; e.exports = n(typeof globalThis === 'object' && globalThis) || n(typeof window === 'object' && window) || n(typeof self === 'object' && self) || n(typeof t === 'object' && t) || (function () { return this; }()) || Function('return this')(); }).call(this, n('c8ba')); },
  ddb0(e, t, n) { const r = n('da84'); const i = n('fdbc'); const o = n('e260'); const a = n('9112'); const s = n('b622'); const l = s('iterator'); const c = s('toStringTag'); const u = o.values; for (const f in i) { const d = r[f]; const h = d && d.prototype; if (h) { if (h[l] !== u) try { a(h, l, u); } catch (m) { h[l] = u; } if (h[c] || a(h, c, f), i[f]) for (const p in o) if (h[p] !== o[p]) try { a(h, p, o[p]); } catch (m) { h[p] = o[p]; } } } },
  df75(e, t, n) { const r = n('ca84'); const i = n('7839'); e.exports = Object.keys || function (e) { return r(e, i); }; },
  e163(e, t, n) { const r = n('5135'); const i = n('7b0b'); const o = n('f772'); const a = n('e177'); const s = o('IE_PROTO'); const l = Object.prototype; e.exports = a ? Object.getPrototypeOf : function (e) { return e = i(e), r(e, s) ? e[s] : typeof e.constructor === 'function' && e instanceof e.constructor ? e.constructor.prototype : e instanceof Object ? l : null; }; },
  e177(e, t, n) { const r = n('d039'); e.exports = !r((() => { function e() {} return e.prototype.constructor = null, Object.getPrototypeOf(new e()) !== e.prototype; })); },
  e260(e, t, n) {
    const r = n('fc6a'); const i = n('44d2'); const o = n('3f8c'); const a = n('69f3'); const s = n('7dd0'); const l = 'Array Iterator'; const c = a.set; const u = a.getterFor(l); e.exports = s(Array, 'Array', (function (e, t) {
      c(this, {
        type: l, target: r(e), index: 0, kind: t,
      });
    }), (function () { const e = u(this); const t = e.target; const n = e.kind; const r = e.index++; return !t || r >= t.length ? (e.target = void 0, { value: void 0, done: !0 }) : n == 'keys' ? { value: r, done: !1 } : n == 'values' ? { value: t[r], done: !1 } : { value: [r, t[r]], done: !1 }; }), 'values'), o.Arguments = o.Array, i('keys'), i('values'), i('entries');
  },
  e2cc(e, t, n) { const r = n('6eeb'); e.exports = function (e, t, n) { for (const i in t)r(e, i, t[i], n); return e; }; },
  e667(e, t) { e.exports = function (e) { try { return { error: !1, value: e() }; } catch (t) { return { error: !0, value: t }; } }; },
  e6cf(e, t, n) {
    let r; let i; let o; let a; const s = n('23e7'); const l = n('c430'); const c = n('da84'); const u = n('d066'); const f = n('fea9'); const d = n('6eeb'); const h = n('e2cc'); const p = n('d2bb'); const m = n('d44e'); const g = n('2626'); const v = n('861d'); const b = n('1c0b'); const y = n('19aa'); const w = n('8925'); const x = n('2266'); const k = n('1c7e'); const _ = n('4840'); const C = n('2cf4').set; const S = n('b575'); const O = n('cdf9'); const j = n('44de'); const L = n('f069'); const T = n('e667'); const M = n('69f3'); const A = n('94ca'); const E = n('b622'); const P = n('6069'); const D = n('605d'); const N = n('2d00'); const F = E('species'); const z = 'Promise'; const I = M.get; const B = M.set; const H = M.getterFor(z); const R = f && f.prototype; let W = f; let q = R; const $ = c.TypeError; const V = c.document; const U = c.process; let G = L.f; const K = G; const X = !!(V && V.createEvent && c.dispatchEvent); const Y = typeof PromiseRejectionEvent === 'function'; const Z = 'unhandledrejection'; const J = 'rejectionhandled'; const Q = 0; const ee = 1; const te = 2; const ne = 1; const re = 2; let ie = !1; const oe = A(z, (() => { const e = w(W) !== String(W); if (!e && N === 66) return !0; if (l && !q.finally) return !0; if (N >= 51 && /native code/.test(W)) return !1; const t = new W((((e) => { e(1); }))); const n = function (e) { e((() => {}), (() => {})); }; const r = t.constructor = {}; return r[F] = n, ie = t.then((() => {})) instanceof n, !ie || !e && P && !Y; })); const ae = oe || !k(((e) => { W.all(e).catch((() => {})); })); const se = function (e) { let t; return !(!v(e) || typeof (t = e.then) !== 'function') && t; }; const le = function (e, t) { if (!e.notified) { e.notified = !0; const n = e.reactions; S((() => { const r = e.value; const i = e.state == ee; let o = 0; while (n.length > o) { var a; var s; var l; const c = n[o++]; const u = i ? c.ok : c.fail; const f = c.resolve; const d = c.reject; const h = c.domain; try { u ? (i || (e.rejection === re && de(e), e.rejection = ne), !0 === u ? a = r : (h && h.enter(), a = u(r), h && (h.exit(), l = !0)), a === c.promise ? d($('Promise-chain cycle')) : (s = se(a)) ? s.call(a, f, d) : f(a)) : d(r); } catch (p) { h && !l && h.exit(), d(p); } }e.reactions = [], e.notified = !1, t && !e.rejection && ue(e); })); } }; const ce = function (e, t, n) { let r; let i; X ? (r = V.createEvent('Event'), r.promise = t, r.reason = n, r.initEvent(e, !1, !0), c.dispatchEvent(r)) : r = { promise: t, reason: n }, !Y && (i = c[`on${e}`]) ? i(r) : e === Z && j('Unhandled promise rejection', n); }; var ue = function (e) { C.call(c, (() => { let t; const n = e.facade; const r = e.value; const i = fe(e); if (i && (t = T((() => { D ? U.emit('unhandledRejection', r, n) : ce(Z, n, r); })), e.rejection = D || fe(e) ? re : ne, t.error)) throw t.value; })); }; var fe = function (e) { return e.rejection !== ne && !e.parent; }; var de = function (e) { C.call(c, (() => { const t = e.facade; D ? U.emit('rejectionHandled', t) : ce(J, t, e.value); })); }; const he = function (e, t, n) { return function (r) { e(t, r, n); }; }; const pe = function (e, t, n) { e.done || (e.done = !0, n && (e = n), e.value = t, e.state = te, le(e, !0)); }; var me = function (e, t, n) { if (!e.done) { e.done = !0, n && (e = n); try { if (e.facade === t) throw $("Promise can't be resolved itself"); const r = se(t); r ? S((() => { const n = { done: !1 }; try { r.call(t, he(me, n, e), he(pe, n, e)); } catch (i) { pe(n, i, e); } })) : (e.value = t, e.state = ee, le(e, !1)); } catch (i) { pe({ done: !1 }, i, e); } } }; if (oe && (W = function (e) { y(this, W, z), b(e), r.call(this); const t = I(this); try { e(he(me, t), he(pe, t)); } catch (n) { pe(t, n); } }, q = W.prototype, r = function (e) {
      B(this, {
        type: z, done: !1, notified: !1, parent: !1, reactions: [], rejection: !1, state: Q, value: void 0,
      });
    }, r.prototype = h(q, { then(e, t) { const n = H(this); const r = G(_(this, W)); return r.ok = typeof e !== 'function' || e, r.fail = typeof t === 'function' && t, r.domain = D ? U.domain : void 0, n.parent = !0, n.reactions.push(r), n.state != Q && le(n, !1), r.promise; }, catch(e) { return this.then(void 0, e); } }), i = function () {
      const e = new r(); const
        t = I(e); this.promise = e, this.resolve = he(me, t), this.reject = he(pe, t);
    }, L.f = G = function (e) { return e === W || e === o ? new i(e) : K(e); }, !l && typeof f === 'function' && R !== Object.prototype)) { a = R.then, ie || (d(R, 'then', (function (e, t) { const n = this; return new W((((e, t) => { a.call(n, e, t); }))).then(e, t); }), { unsafe: !0 }), d(R, 'catch', q.catch, { unsafe: !0 })); try { delete R.constructor; } catch (ge) {}p && p(R, q); }s({ global: !0, wrap: !0, forced: oe }, { Promise: W }), m(W, z, !1, !0), g(z), o = u(z), s({ target: z, stat: !0, forced: oe }, { reject(e) { const t = G(this); return t.reject.call(void 0, e), t.promise; } }), s({ target: z, stat: !0, forced: l || oe }, { resolve(e) { return O(l && this === o ? W : this, e); } }), s({ target: z, stat: !0, forced: ae }, { all(e) { const t = this; const n = G(t); const r = n.resolve; const i = n.reject; const o = T((() => { const n = b(t.resolve); const o = []; let a = 0; let s = 1; x(e, ((e) => { const l = a++; let c = !1; o.push(void 0), s++, n.call(t, e).then(((e) => { c || (c = !0, o[l] = e, --s || r(o)); }), i); })), --s || r(o); })); return o.error && i(o.value), n.promise; }, race(e) { const t = this; const n = G(t); const r = n.reject; const i = T((() => { const i = b(t.resolve); x(e, ((e) => { i.call(t, e).then(n.resolve, r); })); })); return i.error && r(i.value), n.promise; } });
  },
  e893(e, t, n) { const r = n('5135'); const i = n('56ef'); const o = n('06cf'); const a = n('9bf2'); e.exports = function (e, t) { for (let n = i(t), s = a.f, l = o.f, c = 0; c < n.length; c++) { const u = n[c]; r(e, u) || s(e, u, l(t, u)); } }; },
  e95a(e, t, n) { const r = n('b622'); const i = n('3f8c'); const o = r('iterator'); const a = Array.prototype; e.exports = function (e) { return void 0 !== e && (i.Array === e || a[o] === e); }; },
  f040(e, t, n) {
    (function (e) { e(n('56b3')); }(((e) => {
      e.modeInfo = [{
        name: 'APL', mime: 'text/apl', mode: 'apl', ext: ['dyalog', 'apl'],
      }, {
        name: 'PGP', mimes: ['application/pgp', 'application/pgp-encrypted', 'application/pgp-keys', 'application/pgp-signature'], mode: 'asciiarmor', ext: ['asc', 'pgp', 'sig'],
      }, {
        name: 'ASN.1', mime: 'text/x-ttcn-asn', mode: 'asn.1', ext: ['asn', 'asn1'],
      }, {
        name: 'Asterisk', mime: 'text/x-asterisk', mode: 'asterisk', file: /^extensions\.conf$/i,
      }, {
        name: 'Brainfuck', mime: 'text/x-brainfuck', mode: 'brainfuck', ext: ['b', 'bf'],
      }, {
        name: 'C', mime: 'text/x-csrc', mode: 'clike', ext: ['c', 'h', 'ino'],
      }, {
        name: 'C++', mime: 'text/x-c++src', mode: 'clike', ext: ['cpp', 'c++', 'cc', 'cxx', 'hpp', 'h++', 'hh', 'hxx'], alias: ['cpp'],
      }, {
        name: 'Cobol', mime: 'text/x-cobol', mode: 'cobol', ext: ['cob', 'cpy'],
      }, {
        name: 'C#', mime: 'text/x-csharp', mode: 'clike', ext: ['cs'], alias: ['csharp', 'cs'],
      }, {
        name: 'Clojure', mime: 'text/x-clojure', mode: 'clojure', ext: ['clj', 'cljc', 'cljx'],
      }, {
        name: 'ClojureScript', mime: 'text/x-clojurescript', mode: 'clojure', ext: ['cljs'],
      }, {
        name: 'Closure Stylesheets (GSS)', mime: 'text/x-gss', mode: 'css', ext: ['gss'],
      }, {
        name: 'CMake', mime: 'text/x-cmake', mode: 'cmake', ext: ['cmake', 'cmake.in'], file: /^CMakeLists\.txt$/,
      }, {
        name: 'CoffeeScript', mimes: ['application/vnd.coffeescript', 'text/coffeescript', 'text/x-coffeescript'], mode: 'coffeescript', ext: ['coffee'], alias: ['coffee', 'coffee-script'],
      }, {
        name: 'Common Lisp', mime: 'text/x-common-lisp', mode: 'commonlisp', ext: ['cl', 'lisp', 'el'], alias: ['lisp'],
      }, {
        name: 'Cypher', mime: 'application/x-cypher-query', mode: 'cypher', ext: ['cyp', 'cypher'],
      }, {
        name: 'Cython', mime: 'text/x-cython', mode: 'python', ext: ['pyx', 'pxd', 'pxi'],
      }, {
        name: 'Crystal', mime: 'text/x-crystal', mode: 'crystal', ext: ['cr'],
      }, {
        name: 'CSS', mime: 'text/css', mode: 'css', ext: ['css'],
      }, {
        name: 'CQL', mime: 'text/x-cassandra', mode: 'sql', ext: ['cql'],
      }, {
        name: 'D', mime: 'text/x-d', mode: 'd', ext: ['d'],
      }, {
        name: 'Dart', mimes: ['application/dart', 'text/x-dart'], mode: 'dart', ext: ['dart'],
      }, {
        name: 'diff', mime: 'text/x-diff', mode: 'diff', ext: ['diff', 'patch'],
      }, { name: 'Django', mime: 'text/x-django', mode: 'django' }, {
        name: 'Dockerfile', mime: 'text/x-dockerfile', mode: 'dockerfile', file: /^Dockerfile$/,
      }, {
        name: 'DTD', mime: 'application/xml-dtd', mode: 'dtd', ext: ['dtd'],
      }, {
        name: 'Dylan', mime: 'text/x-dylan', mode: 'dylan', ext: ['dylan', 'dyl', 'intr'],
      }, { name: 'EBNF', mime: 'text/x-ebnf', mode: 'ebnf' }, {
        name: 'ECL', mime: 'text/x-ecl', mode: 'ecl', ext: ['ecl'],
      }, {
        name: 'edn', mime: 'application/edn', mode: 'clojure', ext: ['edn'],
      }, {
        name: 'Eiffel', mime: 'text/x-eiffel', mode: 'eiffel', ext: ['e'],
      }, {
        name: 'Elm', mime: 'text/x-elm', mode: 'elm', ext: ['elm'],
      }, {
        name: 'Embedded JavaScript', mime: 'application/x-ejs', mode: 'htmlembedded', ext: ['ejs'],
      }, {
        name: 'Embedded Ruby', mime: 'application/x-erb', mode: 'htmlembedded', ext: ['erb'],
      }, {
        name: 'Erlang', mime: 'text/x-erlang', mode: 'erlang', ext: ['erl'],
      }, { name: 'Esper', mime: 'text/x-esper', mode: 'sql' }, {
        name: 'Factor', mime: 'text/x-factor', mode: 'factor', ext: ['factor'],
      }, { name: 'FCL', mime: 'text/x-fcl', mode: 'fcl' }, {
        name: 'Forth', mime: 'text/x-forth', mode: 'forth', ext: ['forth', 'fth', '4th'],
      }, {
        name: 'Fortran', mime: 'text/x-fortran', mode: 'fortran', ext: ['f', 'for', 'f77', 'f90', 'f95'],
      }, {
        name: 'F#', mime: 'text/x-fsharp', mode: 'mllike', ext: ['fs'], alias: ['fsharp'],
      }, {
        name: 'Gas', mime: 'text/x-gas', mode: 'gas', ext: ['s'],
      }, {
        name: 'Gherkin', mime: 'text/x-feature', mode: 'gherkin', ext: ['feature'],
      }, {
        name: 'GitHub Flavored Markdown', mime: 'text/x-gfm', mode: 'gfm', file: /^(readme|contributing|history)\.md$/i,
      }, {
        name: 'Go', mime: 'text/x-go', mode: 'go', ext: ['go'],
      }, {
        name: 'Groovy', mime: 'text/x-groovy', mode: 'groovy', ext: ['groovy', 'gradle'], file: /^Jenkinsfile$/,
      }, {
        name: 'HAML', mime: 'text/x-haml', mode: 'haml', ext: ['haml'],
      }, {
        name: 'Haskell', mime: 'text/x-haskell', mode: 'haskell', ext: ['hs'],
      }, {
        name: 'Haskell (Literate)', mime: 'text/x-literate-haskell', mode: 'haskell-literate', ext: ['lhs'],
      }, {
        name: 'Haxe', mime: 'text/x-haxe', mode: 'haxe', ext: ['hx'],
      }, {
        name: 'HXML', mime: 'text/x-hxml', mode: 'haxe', ext: ['hxml'],
      }, {
        name: 'ASP.NET', mime: 'application/x-aspx', mode: 'htmlembedded', ext: ['aspx'], alias: ['asp', 'aspx'],
      }, {
        name: 'HTML', mime: 'text/html', mode: 'htmlmixed', ext: ['html', 'htm', 'handlebars', 'hbs'], alias: ['xhtml'],
      }, { name: 'HTTP', mime: 'message/http', mode: 'http' }, {
        name: 'IDL', mime: 'text/x-idl', mode: 'idl', ext: ['pro'],
      }, {
        name: 'Pug', mime: 'text/x-pug', mode: 'pug', ext: ['jade', 'pug'], alias: ['jade'],
      }, {
        name: 'Java', mime: 'text/x-java', mode: 'clike', ext: ['java'],
      }, {
        name: 'Java Server Pages', mime: 'application/x-jsp', mode: 'htmlembedded', ext: ['jsp'], alias: ['jsp'],
      }, {
        name: 'JavaScript', mimes: ['text/javascript', 'text/ecmascript', 'application/javascript', 'application/x-javascript', 'application/ecmascript'], mode: 'javascript', ext: ['js'], alias: ['ecmascript', 'js', 'node'],
      }, {
        name: 'JSON', mimes: ['application/json', 'application/x-json'], mode: 'javascript', ext: ['json', 'map'], alias: ['json5'],
      }, {
        name: 'JSON-LD', mime: 'application/ld+json', mode: 'javascript', ext: ['jsonld'], alias: ['jsonld'],
      }, {
        name: 'JSX', mime: 'text/jsx', mode: 'jsx', ext: ['jsx'],
      }, {
        name: 'Jinja2', mime: 'text/jinja2', mode: 'jinja2', ext: ['j2', 'jinja', 'jinja2'],
      }, {
        name: 'Julia', mime: 'text/x-julia', mode: 'julia', ext: ['jl'], alias: ['jl'],
      }, {
        name: 'Kotlin', mime: 'text/x-kotlin', mode: 'clike', ext: ['kt'],
      }, {
        name: 'LESS', mime: 'text/x-less', mode: 'css', ext: ['less'],
      }, {
        name: 'LiveScript', mime: 'text/x-livescript', mode: 'livescript', ext: ['ls'], alias: ['ls'],
      }, {
        name: 'Lua', mime: 'text/x-lua', mode: 'lua', ext: ['lua'],
      }, {
        name: 'Markdown', mime: 'text/x-markdown', mode: 'markdown', ext: ['markdown', 'md', 'mkd'],
      }, { name: 'mIRC', mime: 'text/mirc', mode: 'mirc' }, { name: 'MariaDB SQL', mime: 'text/x-mariadb', mode: 'sql' }, {
        name: 'Mathematica', mime: 'text/x-mathematica', mode: 'mathematica', ext: ['m', 'nb', 'wl', 'wls'],
      }, {
        name: 'Modelica', mime: 'text/x-modelica', mode: 'modelica', ext: ['mo'],
      }, {
        name: 'MUMPS', mime: 'text/x-mumps', mode: 'mumps', ext: ['mps'],
      }, { name: 'MS SQL', mime: 'text/x-mssql', mode: 'sql' }, {
        name: 'mbox', mime: 'application/mbox', mode: 'mbox', ext: ['mbox'],
      }, { name: 'MySQL', mime: 'text/x-mysql', mode: 'sql' }, {
        name: 'Nginx', mime: 'text/x-nginx-conf', mode: 'nginx', file: /nginx.*\.conf$/i,
      }, {
        name: 'NSIS', mime: 'text/x-nsis', mode: 'nsis', ext: ['nsh', 'nsi'],
      }, {
        name: 'NTriples', mimes: ['application/n-triples', 'application/n-quads', 'text/n-triples'], mode: 'ntriples', ext: ['nt', 'nq'],
      }, {
        name: 'Objective-C', mime: 'text/x-objectivec', mode: 'clike', ext: ['m'], alias: ['objective-c', 'objc'],
      }, {
        name: 'Objective-C++', mime: 'text/x-objectivec++', mode: 'clike', ext: ['mm'], alias: ['objective-c++', 'objc++'],
      }, {
        name: 'OCaml', mime: 'text/x-ocaml', mode: 'mllike', ext: ['ml', 'mli', 'mll', 'mly'],
      }, {
        name: 'Octave', mime: 'text/x-octave', mode: 'octave', ext: ['m'],
      }, {
        name: 'Oz', mime: 'text/x-oz', mode: 'oz', ext: ['oz'],
      }, {
        name: 'Pascal', mime: 'text/x-pascal', mode: 'pascal', ext: ['p', 'pas'],
      }, {
        name: 'PEG.js', mime: 'null', mode: 'pegjs', ext: ['jsonld'],
      }, {
        name: 'Perl', mime: 'text/x-perl', mode: 'perl', ext: ['pl', 'pm'],
      }, {
        name: 'PHP', mimes: ['text/x-php', 'application/x-httpd-php', 'application/x-httpd-php-open'], mode: 'php', ext: ['php', 'php3', 'php4', 'php5', 'php7', 'phtml'],
      }, {
        name: 'Pig', mime: 'text/x-pig', mode: 'pig', ext: ['pig'],
      }, {
        name: 'Plain Text', mime: 'text/plain', mode: 'null', ext: ['txt', 'text', 'conf', 'def', 'list', 'log'],
      }, {
        name: 'PLSQL', mime: 'text/x-plsql', mode: 'sql', ext: ['pls'],
      }, { name: 'PostgreSQL', mime: 'text/x-pgsql', mode: 'sql' }, {
        name: 'PowerShell', mime: 'application/x-powershell', mode: 'powershell', ext: ['ps1', 'psd1', 'psm1'],
      }, {
        name: 'Properties files', mime: 'text/x-properties', mode: 'properties', ext: ['properties', 'ini', 'in'], alias: ['ini', 'properties'],
      }, {
        name: 'ProtoBuf', mime: 'text/x-protobuf', mode: 'protobuf', ext: ['proto'],
      }, {
        name: 'Python', mime: 'text/x-python', mode: 'python', ext: ['BUILD', 'bzl', 'py', 'pyw'], file: /^(BUCK|BUILD)$/,
      }, {
        name: 'Puppet', mime: 'text/x-puppet', mode: 'puppet', ext: ['pp'],
      }, {
        name: 'Q', mime: 'text/x-q', mode: 'q', ext: ['q'],
      }, {
        name: 'R', mime: 'text/x-rsrc', mode: 'r', ext: ['r', 'R'], alias: ['rscript'],
      }, {
        name: 'reStructuredText', mime: 'text/x-rst', mode: 'rst', ext: ['rst'], alias: ['rst'],
      }, { name: 'RPM Changes', mime: 'text/x-rpm-changes', mode: 'rpm' }, {
        name: 'RPM Spec', mime: 'text/x-rpm-spec', mode: 'rpm', ext: ['spec'],
      }, {
        name: 'Ruby', mime: 'text/x-ruby', mode: 'ruby', ext: ['rb'], alias: ['jruby', 'macruby', 'rake', 'rb', 'rbx'],
      }, {
        name: 'Rust', mime: 'text/x-rustsrc', mode: 'rust', ext: ['rs'],
      }, {
        name: 'SAS', mime: 'text/x-sas', mode: 'sas', ext: ['sas'],
      }, {
        name: 'Sass', mime: 'text/x-sass', mode: 'sass', ext: ['sass'],
      }, {
        name: 'Scala', mime: 'text/x-scala', mode: 'clike', ext: ['scala'],
      }, {
        name: 'Scheme', mime: 'text/x-scheme', mode: 'scheme', ext: ['scm', 'ss'],
      }, {
        name: 'SCSS', mime: 'text/x-scss', mode: 'css', ext: ['scss'],
      }, {
        name: 'Shell', mimes: ['text/x-sh', 'application/x-sh'], mode: 'shell', ext: ['sh', 'ksh', 'bash'], alias: ['bash', 'sh', 'zsh'], file: /^PKGBUILD$/,
      }, {
        name: 'Sieve', mime: 'application/sieve', mode: 'sieve', ext: ['siv', 'sieve'],
      }, {
        name: 'Slim', mimes: ['text/x-slim', 'application/x-slim'], mode: 'slim', ext: ['slim'],
      }, {
        name: 'Smalltalk', mime: 'text/x-stsrc', mode: 'smalltalk', ext: ['st'],
      }, {
        name: 'Smarty', mime: 'text/x-smarty', mode: 'smarty', ext: ['tpl'],
      }, { name: 'Solr', mime: 'text/x-solr', mode: 'solr' }, {
        name: 'SML', mime: 'text/x-sml', mode: 'mllike', ext: ['sml', 'sig', 'fun', 'smackspec'],
      }, {
        name: 'Soy', mime: 'text/x-soy', mode: 'soy', ext: ['soy'], alias: ['closure template'],
      }, {
        name: 'SPARQL', mime: 'application/sparql-query', mode: 'sparql', ext: ['rq', 'sparql'], alias: ['sparul'],
      }, {
        name: 'Spreadsheet', mime: 'text/x-spreadsheet', mode: 'spreadsheet', alias: ['excel', 'formula'],
      }, {
        name: 'SQL', mime: 'text/x-sql', mode: 'sql', ext: ['sql'],
      }, { name: 'SQLite', mime: 'text/x-sqlite', mode: 'sql' }, {
        name: 'Squirrel', mime: 'text/x-squirrel', mode: 'clike', ext: ['nut'],
      }, {
        name: 'Stylus', mime: 'text/x-styl', mode: 'stylus', ext: ['styl'],
      }, {
        name: 'Swift', mime: 'text/x-swift', mode: 'swift', ext: ['swift'],
      }, { name: 'sTeX', mime: 'text/x-stex', mode: 'stex' }, {
        name: 'LaTeX', mime: 'text/x-latex', mode: 'stex', ext: ['text', 'ltx', 'tex'], alias: ['tex'],
      }, {
        name: 'SystemVerilog', mime: 'text/x-systemverilog', mode: 'verilog', ext: ['v', 'sv', 'svh'],
      }, {
        name: 'Tcl', mime: 'text/x-tcl', mode: 'tcl', ext: ['tcl'],
      }, {
        name: 'Textile', mime: 'text/x-textile', mode: 'textile', ext: ['textile'],
      }, { name: 'TiddlyWiki', mime: 'text/x-tiddlywiki', mode: 'tiddlywiki' }, { name: 'Tiki wiki', mime: 'text/tiki', mode: 'tiki' }, {
        name: 'TOML', mime: 'text/x-toml', mode: 'toml', ext: ['toml'],
      }, { name: 'Tornado', mime: 'text/x-tornado', mode: 'tornado' }, {
        name: 'troff', mime: 'text/troff', mode: 'troff', ext: ['1', '2', '3', '4', '5', '6', '7', '8', '9'],
      }, {
        name: 'TTCN', mime: 'text/x-ttcn', mode: 'ttcn', ext: ['ttcn', 'ttcn3', 'ttcnpp'],
      }, {
        name: 'TTCN_CFG', mime: 'text/x-ttcn-cfg', mode: 'ttcn-cfg', ext: ['cfg'],
      }, {
        name: 'Turtle', mime: 'text/turtle', mode: 'turtle', ext: ['ttl'],
      }, {
        name: 'TypeScript', mime: 'application/typescript', mode: 'javascript', ext: ['ts'], alias: ['ts'],
      }, {
        name: 'TypeScript-JSX', mime: 'text/typescript-jsx', mode: 'jsx', ext: ['tsx'], alias: ['tsx'],
      }, { name: 'Twig', mime: 'text/x-twig', mode: 'twig' }, {
        name: 'Web IDL', mime: 'text/x-webidl', mode: 'webidl', ext: ['webidl'],
      }, {
        name: 'VB.NET', mime: 'text/x-vb', mode: 'vb', ext: ['vb'],
      }, {
        name: 'VBScript', mime: 'text/vbscript', mode: 'vbscript', ext: ['vbs'],
      }, {
        name: 'Velocity', mime: 'text/velocity', mode: 'velocity', ext: ['vtl'],
      }, {
        name: 'Verilog', mime: 'text/x-verilog', mode: 'verilog', ext: ['v'],
      }, {
        name: 'VHDL', mime: 'text/x-vhdl', mode: 'vhdl', ext: ['vhd', 'vhdl'],
      }, {
        name: 'Vue.js Component', mimes: ['script/x-vue', 'text/x-vue'], mode: 'vue', ext: ['vue'],
      }, {
        name: 'XML', mimes: ['application/xml', 'text/xml'], mode: 'xml', ext: ['xml', 'xsl', 'xsd', 'svg'], alias: ['rss', 'wsdl', 'xsd'],
      }, {
        name: 'XQuery', mime: 'application/xquery', mode: 'xquery', ext: ['xy', 'xquery'],
      }, {
        name: 'Yacas', mime: 'text/x-yacas', mode: 'yacas', ext: ['ys'],
      }, {
        name: 'YAML', mimes: ['text/x-yaml', 'text/yaml'], mode: 'yaml', ext: ['yaml', 'yml'], alias: ['yml'],
      }, {
        name: 'Z80', mime: 'text/x-z80', mode: 'z80', ext: ['z80'],
      }, {
        name: 'mscgen', mime: 'text/x-mscgen', mode: 'mscgen', ext: ['mscgen', 'mscin', 'msc'],
      }, {
        name: 'xu', mime: 'text/x-xu', mode: 'mscgen', ext: ['xu'],
      }, {
        name: 'msgenny', mime: 'text/x-msgenny', mode: 'mscgen', ext: ['msgenny'],
      }, {
        name: 'WebAssembly', mime: 'text/webassembly', mode: 'wast', ext: ['wat', 'wast'],
      }]; for (let t = 0; t < e.modeInfo.length; t++) { const n = e.modeInfo[t]; n.mimes && (n.mime = n.mimes[0]); }e.findModeByMIME = function (t) { t = t.toLowerCase(); for (let n = 0; n < e.modeInfo.length; n++) { const r = e.modeInfo[n]; if (r.mime == t) return r; if (r.mimes) for (let i = 0; i < r.mimes.length; i++) if (r.mimes[i] == t) return r; } return /\+xml$/.test(t) ? e.findModeByMIME('application/xml') : /\+json$/.test(t) ? e.findModeByMIME('application/json') : void 0; }, e.findModeByExtension = function (t) { t = t.toLowerCase(); for (let n = 0; n < e.modeInfo.length; n++) { const r = e.modeInfo[n]; if (r.ext) for (let i = 0; i < r.ext.length; i++) if (r.ext[i] == t) return r; } }, e.findModeByFileName = function (t) { for (let n = 0; n < e.modeInfo.length; n++) { const r = e.modeInfo[n]; if (r.file && r.file.test(t)) return r; } const i = t.lastIndexOf('.'); const o = i > -1 && t.substring(i + 1, t.length); if (o) return e.findModeByExtension(o); }, e.findModeByName = function (t) { t = t.toLowerCase(); for (let n = 0; n < e.modeInfo.length; n++) { const r = e.modeInfo[n]; if (r.name.toLowerCase() == t) return r; if (r.alias) for (let i = 0; i < r.alias.length; i++) if (r.alias[i].toLowerCase() == t) return r; } };
    })));
  },
  f069(e, t, n) {
    const r = n('1c0b'); const i = function (e) { let t; let n; this.promise = new e((((e, r) => { if (void 0 !== t || void 0 !== n) throw TypeError('Bad Promise constructor'); t = e, n = r; }))), this.resolve = r(t), this.reject = r(n); }; e.exports.f = function (e) { return new i(e); };
  },
  f5df(e, t, n) { const r = n('00ee'); const i = n('c6b6'); const o = n('b622'); const a = o('toStringTag'); const s = i(function () { return arguments; }()) == 'Arguments'; const l = function (e, t) { try { return e[t]; } catch (n) {} }; e.exports = r ? i : function (e) { let t; let n; let r; return void 0 === e ? 'Undefined' : e === null ? 'Null' : typeof (n = l(t = Object(e), a)) === 'string' ? n : s ? i(t) : (r = i(t)) == 'Object' && typeof t.callee === 'function' ? 'Arguments' : r; }; },
  f772(e, t, n) { const r = n('5692'); const i = n('90e3'); const o = r('keys'); e.exports = function (e) { return o[e] || (o[e] = i(e)); }; },
  f9d4(e, t, n) {
    (function (e) { e(n('56b3')); }(((e) => {
      e.defineMode('javascript', ((t, n) => {
        let r; let i; const o = t.indentUnit; const a = n.statementIndent; const s = n.jsonld; const l = n.json || s; const c = !1 !== n.trackScope; const u = n.typescript; const f = n.wordCharacters || /[\w$\xa1-\uffff]/; const d = (function () {
          function e(e) { return { type: e, style: 'keyword' }; } const t = e('keyword a'); const n = e('keyword b'); const r = e('keyword c'); const i = e('keyword d'); const o = e('operator'); const a = { type: 'atom', style: 'atom' }; return {
            if: e('if'), while: t, with: t, else: n, do: n, try: n, finally: n, return: i, break: i, continue: i, new: e('new'), delete: r, void: r, throw: r, debugger: e('debugger'), var: e('var'), const: e('var'), let: e('var'), function: e('function'), catch: e('catch'), for: e('for'), switch: e('switch'), case: e('case'), default: e('default'), in: o, typeof: o, instanceof: o, true: a, false: a, null: a, undefined: a, NaN: a, Infinity: a, this: e('this'), class: e('class'), super: e('atom'), yield: r, export: e('export'), import: e('import'), extends: r, await: r,
          };
        }()); const h = /[+\-*&%=<>!?|~^@]/; const p = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/; function m(e) { let t; let n = !1; let r = !1; while ((t = e.next()) != null) { if (!n) { if (t == '/' && !r) return; t == '[' ? r = !0 : r && t == ']' && (r = !1); }n = !n && t == '\\'; } } function g(e, t, n) { return r = e, i = n, t; } function v(e, t) { const n = e.next(); if (n == '"' || n == "'") return t.tokenize = b(n), t.tokenize(e, t); if (n == '.' && e.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) return g('number', 'number'); if (n == '.' && e.match('..')) return g('spread', 'meta'); if (/[\[\]{}\(\),;\:\.]/.test(n)) return g(n); if (n == '=' && e.eat('>')) return g('=>', 'operator'); if (n == '0' && e.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) return g('number', 'number'); if (/\d/.test(n)) return e.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/), g('number', 'number'); if (n == '/') return e.eat('*') ? (t.tokenize = y, y(e, t)) : e.eat('/') ? (e.skipToEnd(), g('comment', 'comment')) : it(e, t, 1) ? (m(e), e.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/), g('regexp', 'string-2')) : (e.eat('='), g('operator', 'operator', e.current())); if (n == '`') return t.tokenize = w, w(e, t); if (n == '#' && e.peek() == '!') return e.skipToEnd(), g('meta', 'meta'); if (n == '#' && e.eatWhile(f)) return g('variable', 'property'); if (n == '<' && e.match('!--') || n == '-' && e.match('->') && !/\S/.test(e.string.slice(0, e.start))) return e.skipToEnd(), g('comment', 'comment'); if (h.test(n)) return n == '>' && t.lexical && t.lexical.type == '>' || (e.eat('=') ? n != '!' && n != '=' || e.eat('=') : /[<>*+\-|&?]/.test(n) && (e.eat(n), n == '>' && e.eat(n))), n == '?' && e.eat('.') ? g('.') : g('operator', 'operator', e.current()); if (f.test(n)) { e.eatWhile(f); const r = e.current(); if (t.lastType != '.') { if (d.propertyIsEnumerable(r)) { const i = d[r]; return g(i.type, i.style, r); } if (r == 'async' && e.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, !1)) return g('async', 'keyword', r); } return g('variable', 'variable', r); } } function b(e) { return function (t, n) { let r; let i = !1; if (s && t.peek() == '@' && t.match(p)) return n.tokenize = v, g('jsonld-keyword', 'meta'); while ((r = t.next()) != null) { if (r == e && !i) break; i = !i && r == '\\'; } return i || (n.tokenize = v), g('string', 'string'); }; } function y(e, t) { let n; let r = !1; while (n = e.next()) { if (n == '/' && r) { t.tokenize = v; break; }r = n == '*'; } return g('comment', 'comment'); } function w(e, t) { let n; let r = !1; while ((n = e.next()) != null) { if (!r && (n == '`' || n == '$' && e.eat('{'))) { t.tokenize = v; break; }r = !r && n == '\\'; } return g('quasi', 'string-2', e.current()); } const x = '([{}])'; function k(e, t) { t.fatArrowAt && (t.fatArrowAt = null); let n = e.string.indexOf('=>', e.start); if (!(n < 0)) { if (u) { const r = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(e.string.slice(e.start, n)); r && (n = r.index); } for (var i = 0, o = !1, a = n - 1; a >= 0; --a) { const s = e.string.charAt(a); const l = x.indexOf(s); if (l >= 0 && l < 3) { if (!i) { ++a; break; } if (--i == 0) { s == '(' && (o = !0); break; } } else if (l >= 3 && l < 6)++i; else if (f.test(s))o = !0; else if (/["'\/`]/.test(s)) for (;;--a) { if (a == 0) return; const c = e.string.charAt(a - 1); if (c == s && e.string.charAt(a - 2) != '\\') { a--; break; } } else if (o && !i) { ++a; break; } }o && !i && (t.fatArrowAt = a); } } const _ = {
          atom: !0, number: !0, variable: !0, string: !0, regexp: !0, this: !0, import: !0, 'jsonld-keyword': !0,
        }; function C(e, t, n, r, i, o) { this.indented = e, this.column = t, this.type = n, this.prev = i, this.info = o, r != null && (this.align = r); } function S(e, t) { if (!c) return !1; for (var n = e.localVars; n; n = n.next) if (n.name == t) return !0; for (let r = e.context; r; r = r.prev) for (n = r.vars; n; n = n.next) if (n.name == t) return !0; } function O(e, t, n, r, i) { const o = e.cc; j.state = e, j.stream = i, j.marked = null, j.cc = o, j.style = t, e.lexical.hasOwnProperty('align') || (e.lexical.align = !0); while (1) { const a = o.length ? o.pop() : l ? V : q; if (a(n, r)) { while (o.length && o[o.length - 1].lex)o.pop()(); return j.marked ? j.marked : n == 'variable' && S(e, r) ? 'variable-2' : t; } } } var j = {
          state: null, column: null, marked: null, cc: null,
        }; function L() { for (let e = arguments.length - 1; e >= 0; e--)j.cc.push(arguments[e]); } function T() { return L.apply(null, arguments), !0; } function M(e, t) { for (let n = t; n; n = n.next) if (n.name == e) return !0; return !1; } function A(e) { const t = j.state; if (j.marked = 'def', c) { if (t.context) if (t.lexical.info == 'var' && t.context && t.context.block) { const r = E(e, t.context); if (r != null) return void (t.context = r); } else if (!M(e, t.localVars)) return void (t.localVars = new N(e, t.localVars)); n.globalVars && !M(e, t.globalVars) && (t.globalVars = new N(e, t.globalVars)); } } function E(e, t) { if (t) { if (t.block) { const n = E(e, t.prev); return n ? n == t.prev ? t : new D(n, t.vars, !0) : null; } return M(e, t.vars) ? t : new D(t.prev, new N(e, t.vars), !1); } return null; } function P(e) { return e == 'public' || e == 'private' || e == 'protected' || e == 'abstract' || e == 'readonly'; } function D(e, t, n) { this.prev = e, this.vars = t, this.block = n; } function N(e, t) { this.name = e, this.next = t; } const F = new N('this', new N('arguments', null)); function z() { j.state.context = new D(j.state.context, j.state.localVars, !1), j.state.localVars = F; } function I() { j.state.context = new D(j.state.context, j.state.localVars, !0), j.state.localVars = null; } function B() { j.state.localVars = j.state.context.vars, j.state.context = j.state.context.prev; } function H(e, t) { const n = function () { const n = j.state; let r = n.indented; if (n.lexical.type == 'stat')r = n.lexical.indented; else for (let i = n.lexical; i && i.type == ')' && i.align; i = i.prev)r = i.indented; n.lexical = new C(r, j.stream.column(), e, null, n.lexical, t); }; return n.lex = !0, n; } function R() { const e = j.state; e.lexical.prev && (e.lexical.type == ')' && (e.indented = e.lexical.indented), e.lexical = e.lexical.prev); } function W(e) { function t(n) { return n == e ? T() : e == ';' || n == '}' || n == ')' || n == ']' ? L() : T(t); } return t; } function q(e, t) { return e == 'var' ? T(H('vardef', t), Le, W(';'), R) : e == 'keyword a' ? T(H('form'), G, q, R) : e == 'keyword b' ? T(H('form'), q, R) : e == 'keyword d' ? j.stream.match(/^\s*$/, !1) ? T() : T(H('stat'), X, W(';'), R) : e == 'debugger' ? T(W(';')) : e == '{' ? T(H('}'), I, de, R, B) : e == ';' ? T() : e == 'if' ? (j.state.lexical.info == 'else' && j.state.cc[j.state.cc.length - 1] == R && j.state.cc.pop()(), T(H('form'), G, q, R, De)) : e == 'function' ? T(Ie) : e == 'for' ? T(H('form'), I, Ne, q, B, R) : e == 'class' || u && t == 'interface' ? (j.marked = 'keyword', T(H('form', e == 'class' ? e : t), qe, R)) : e == 'variable' ? u && t == 'declare' ? (j.marked = 'keyword', T(q)) : u && (t == 'module' || t == 'enum' || t == 'type') && j.stream.match(/^\s*\w/, !1) ? (j.marked = 'keyword', t == 'enum' ? T(tt) : t == 'type' ? T(He, W('operator'), ve, W(';')) : T(H('form'), Te, W('{'), H('}'), de, R, R)) : u && t == 'namespace' ? (j.marked = 'keyword', T(H('form'), V, q, R)) : u && t == 'abstract' ? (j.marked = 'keyword', T(q)) : T(H('stat'), oe) : e == 'switch' ? T(H('form'), G, W('{'), H('}', 'switch'), I, de, R, R, B) : e == 'case' ? T(V, W(':')) : e == 'default' ? T(W(':')) : e == 'catch' ? T(H('form'), z, $, q, R, B) : e == 'export' ? T(H('stat'), Ge, R) : e == 'import' ? T(H('stat'), Xe, R) : e == 'async' ? T(q) : t == '@' ? T(V, q) : L(H('stat'), V, W(';'), R); } function $(e) { if (e == '(') return T(Re, W(')')); } function V(e, t) { return K(e, t, !1); } function U(e, t) { return K(e, t, !0); } function G(e) { return e != '(' ? L() : T(H(')'), X, W(')'), R); } function K(e, t, n) { if (j.state.fatArrowAt == j.stream.start) { const r = n ? te : ee; if (e == '(') return T(z, H(')'), ue(Re, ')'), R, W('=>'), r, B); if (e == 'variable') return L(z, Te, W('=>'), r, B); } const i = n ? Z : Y; return _.hasOwnProperty(e) ? T(i) : e == 'function' ? T(Ie, i) : e == 'class' || u && t == 'interface' ? (j.marked = 'keyword', T(H('form'), We, R)) : e == 'keyword c' || e == 'async' ? T(n ? U : V) : e == '(' ? T(H(')'), X, W(')'), R, i) : e == 'operator' || e == 'spread' ? T(n ? U : V) : e == '[' ? T(H(']'), et, R, i) : e == '{' ? fe(se, '}', null, i) : e == 'quasi' ? L(J, i) : e == 'new' ? T(ne(n)) : T(); } function X(e) { return e.match(/[;\}\)\],]/) ? L() : L(V); } function Y(e, t) { return e == ',' ? T(X) : Z(e, t, !1); } function Z(e, t, n) { const r = n == 0 ? Y : Z; const i = n == 0 ? V : U; return e == '=>' ? T(z, n ? te : ee, B) : e == 'operator' ? /\+\+|--/.test(t) || u && t == '!' ? T(r) : u && t == '<' && j.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, !1) ? T(H('>'), ue(ve, '>'), R, r) : t == '?' ? T(V, W(':'), i) : T(i) : e == 'quasi' ? L(J, r) : e != ';' ? e == '(' ? fe(U, ')', 'call', r) : e == '.' ? T(ae, r) : e == '[' ? T(H(']'), X, W(']'), R, r) : u && t == 'as' ? (j.marked = 'keyword', T(ve, r)) : e == 'regexp' ? (j.state.lastType = j.marked = 'operator', j.stream.backUp(j.stream.pos - j.stream.start - 1), T(i)) : void 0 : void 0; } function J(e, t) { return e != 'quasi' ? L() : t.slice(t.length - 2) != '${' ? T(J) : T(V, Q); } function Q(e) { if (e == '}') return j.marked = 'string-2', j.state.tokenize = w, T(J); } function ee(e) { return k(j.stream, j.state), L(e == '{' ? q : V); } function te(e) { return k(j.stream, j.state), L(e == '{' ? q : U); } function ne(e) { return function (t) { return t == '.' ? T(e ? ie : re) : t == 'variable' && u ? T(Se, e ? Z : Y) : L(e ? U : V); }; } function re(e, t) { if (t == 'target') return j.marked = 'keyword', T(Y); } function ie(e, t) { if (t == 'target') return j.marked = 'keyword', T(Z); } function oe(e) { return e == ':' ? T(R, q) : L(Y, W(';'), R); } function ae(e) { if (e == 'variable') return j.marked = 'property', T(); } function se(e, t) { return e == 'async' ? (j.marked = 'property', T(se)) : e == 'variable' || j.style == 'keyword' ? (j.marked = 'property', t == 'get' || t == 'set' ? T(le) : (u && j.state.fatArrowAt == j.stream.start && (n = j.stream.match(/^\s*:\s*/, !1)) && (j.state.fatArrowAt = j.stream.pos + n[0].length), T(ce))) : e == 'number' || e == 'string' ? (j.marked = s ? 'property' : `${j.style} property`, T(ce)) : e == 'jsonld-keyword' ? T(ce) : u && P(t) ? (j.marked = 'keyword', T(se)) : e == '[' ? T(V, he, W(']'), ce) : e == 'spread' ? T(U, ce) : t == '*' ? (j.marked = 'keyword', T(se)) : e == ':' ? L(ce) : void 0; let n; } function le(e) { return e != 'variable' ? L(ce) : (j.marked = 'property', T(Ie)); } function ce(e) { return e == ':' ? T(U) : e == '(' ? L(Ie) : void 0; } function ue(e, t, n) { function r(i, o) { if (n ? n.indexOf(i) > -1 : i == ',') { const a = j.state.lexical; return a.info == 'call' && (a.pos = (a.pos || 0) + 1), T(((n, r) => (n == t || r == t ? L() : L(e))), r); } return i == t || o == t ? T() : n && n.indexOf(';') > -1 ? L(e) : T(W(t)); } return function (n, i) { return n == t || i == t ? T() : L(e, r); }; } function fe(e, t, n) { for (let r = 3; r < arguments.length; r++)j.cc.push(arguments[r]); return T(H(t, n), ue(e, t), R); } function de(e) { return e == '}' ? T() : L(q, de); } function he(e, t) { if (u) { if (e == ':') return T(ve); if (t == '?') return T(he); } } function pe(e, t) { if (u && (e == ':' || t == 'in')) return T(ve); } function me(e) { if (u && e == ':') return j.stream.match(/^\s*\w+\s+is\b/, !1) ? T(V, ge, ve) : T(ve); } function ge(e, t) { if (t == 'is') return j.marked = 'keyword', T(); } function ve(e, t) { return t == 'keyof' || t == 'typeof' || t == 'infer' || t == 'readonly' ? (j.marked = 'keyword', T(t == 'typeof' ? U : ve)) : e == 'variable' || t == 'void' ? (j.marked = 'type', T(Ce)) : t == '|' || t == '&' ? T(ve) : e == 'string' || e == 'number' || e == 'atom' ? T(Ce) : e == '[' ? T(H(']'), ue(ve, ']', ','), R, Ce) : e == '{' ? T(H('}'), ye, R, Ce) : e == '(' ? T(ue(_e, ')'), be, Ce) : e == '<' ? T(ue(ve, '>'), ve) : e == 'quasi' ? L(xe, Ce) : void 0; } function be(e) { if (e == '=>') return T(ve); } function ye(e) { return e.match(/[\}\)\]]/) ? T() : e == ',' || e == ';' ? T(ye) : L(we, ye); } function we(e, t) { return e == 'variable' || j.style == 'keyword' ? (j.marked = 'property', T(we)) : t == '?' || e == 'number' || e == 'string' ? T(we) : e == ':' ? T(ve) : e == '[' ? T(W('variable'), pe, W(']'), we) : e == '(' ? L(Be, we) : e.match(/[;\}\)\],]/) ? void 0 : T(); } function xe(e, t) { return e != 'quasi' ? L() : t.slice(t.length - 2) != '${' ? T(xe) : T(ve, ke); } function ke(e) { if (e == '}') return j.marked = 'string-2', j.state.tokenize = w, T(xe); } function _e(e, t) { return e == 'variable' && j.stream.match(/^\s*[?:]/, !1) || t == '?' ? T(_e) : e == ':' ? T(ve) : e == 'spread' ? T(_e) : L(ve); } function Ce(e, t) { return t == '<' ? T(H('>'), ue(ve, '>'), R, Ce) : t == '|' || e == '.' || t == '&' ? T(ve) : e == '[' ? T(ve, W(']'), Ce) : t == 'extends' || t == 'implements' ? (j.marked = 'keyword', T(ve)) : t == '?' ? T(ve, W(':'), ve) : void 0; } function Se(e, t) { if (t == '<') return T(H('>'), ue(ve, '>'), R, Ce); } function Oe() { return L(ve, je); } function je(e, t) { if (t == '=') return T(ve); } function Le(e, t) { return t == 'enum' ? (j.marked = 'keyword', T(tt)) : L(Te, he, Ee, Pe); } function Te(e, t) { return u && P(t) ? (j.marked = 'keyword', T(Te)) : e == 'variable' ? (A(t), T()) : e == 'spread' ? T(Te) : e == '[' ? fe(Ae, ']') : e == '{' ? fe(Me, '}') : void 0; } function Me(e, t) { return e != 'variable' || j.stream.match(/^\s*:/, !1) ? (e == 'variable' && (j.marked = 'property'), e == 'spread' ? T(Te) : e == '}' ? L() : e == '[' ? T(V, W(']'), W(':'), Me) : T(W(':'), Te, Ee)) : (A(t), T(Ee)); } function Ae() { return L(Te, Ee); } function Ee(e, t) { if (t == '=') return T(U); } function Pe(e) { if (e == ',') return T(Le); } function De(e, t) { if (e == 'keyword b' && t == 'else') return T(H('form', 'else'), q, R); } function Ne(e, t) { return t == 'await' ? T(Ne) : e == '(' ? T(H(')'), Fe, R) : void 0; } function Fe(e) { return e == 'var' ? T(Le, ze) : e == 'variable' ? T(ze) : L(ze); } function ze(e, t) { return e == ')' ? T() : e == ';' ? T(ze) : t == 'in' || t == 'of' ? (j.marked = 'keyword', T(V, ze)) : L(V, ze); } function Ie(e, t) { return t == '*' ? (j.marked = 'keyword', T(Ie)) : e == 'variable' ? (A(t), T(Ie)) : e == '(' ? T(z, H(')'), ue(Re, ')'), R, me, q, B) : u && t == '<' ? T(H('>'), ue(Oe, '>'), R, Ie) : void 0; } function Be(e, t) { return t == '*' ? (j.marked = 'keyword', T(Be)) : e == 'variable' ? (A(t), T(Be)) : e == '(' ? T(z, H(')'), ue(Re, ')'), R, me, B) : u && t == '<' ? T(H('>'), ue(Oe, '>'), R, Be) : void 0; } function He(e, t) { return e == 'keyword' || e == 'variable' ? (j.marked = 'type', T(He)) : t == '<' ? T(H('>'), ue(Oe, '>'), R) : void 0; } function Re(e, t) { return t == '@' && T(V, Re), e == 'spread' ? T(Re) : u && P(t) ? (j.marked = 'keyword', T(Re)) : u && e == 'this' ? T(he, Ee) : L(Te, he, Ee); } function We(e, t) { return e == 'variable' ? qe(e, t) : $e(e, t); } function qe(e, t) { if (e == 'variable') return A(t), T($e); } function $e(e, t) { return t == '<' ? T(H('>'), ue(Oe, '>'), R, $e) : t == 'extends' || t == 'implements' || u && e == ',' ? (t == 'implements' && (j.marked = 'keyword'), T(u ? ve : V, $e)) : e == '{' ? T(H('}'), Ve, R) : void 0; } function Ve(e, t) { return e == 'async' || e == 'variable' && (t == 'static' || t == 'get' || t == 'set' || u && P(t)) && j.stream.match(/^\s+[\w$\xa1-\uffff]/, !1) ? (j.marked = 'keyword', T(Ve)) : e == 'variable' || j.style == 'keyword' ? (j.marked = 'property', T(Ue, Ve)) : e == 'number' || e == 'string' ? T(Ue, Ve) : e == '[' ? T(V, he, W(']'), Ue, Ve) : t == '*' ? (j.marked = 'keyword', T(Ve)) : u && e == '(' ? L(Be, Ve) : e == ';' || e == ',' ? T(Ve) : e == '}' ? T() : t == '@' ? T(V, Ve) : void 0; } function Ue(e, t) { if (t == '!') return T(Ue); if (t == '?') return T(Ue); if (e == ':') return T(ve, Ee); if (t == '=') return T(U); const n = j.state.lexical.prev; const r = n && n.info == 'interface'; return L(r ? Be : Ie); } function Ge(e, t) { return t == '*' ? (j.marked = 'keyword', T(Qe, W(';'))) : t == 'default' ? (j.marked = 'keyword', T(V, W(';'))) : e == '{' ? T(ue(Ke, '}'), Qe, W(';')) : L(q); } function Ke(e, t) { return t == 'as' ? (j.marked = 'keyword', T(W('variable'))) : e == 'variable' ? L(U, Ke) : void 0; } function Xe(e) { return e == 'string' ? T() : e == '(' ? L(V) : e == '.' ? L(Y) : L(Ye, Ze, Qe); } function Ye(e, t) { return e == '{' ? fe(Ye, '}') : (e == 'variable' && A(t), t == '*' && (j.marked = 'keyword'), T(Je)); } function Ze(e) { if (e == ',') return T(Ye, Ze); } function Je(e, t) { if (t == 'as') return j.marked = 'keyword', T(Ye); } function Qe(e, t) { if (t == 'from') return j.marked = 'keyword', T(V); } function et(e) { return e == ']' ? T() : L(ue(U, ']')); } function tt() { return L(H('form'), Te, W('{'), H('}'), ue(nt, '}'), R, R); } function nt() { return L(Te, Ee); } function rt(e, t) { return e.lastType == 'operator' || e.lastType == ',' || h.test(t.charAt(0)) || /[,.]/.test(t.charAt(0)); } function it(e, t, n) { return t.tokenize == v && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(t.lastType) || t.lastType == 'quasi' && /\{\s*$/.test(e.string.slice(0, e.pos - (n || 0))); } return B.lex = !0, R.lex = !0, {
          startState(e) {
            const t = {
              tokenize: v, lastType: 'sof', cc: [], lexical: new C((e || 0) - o, 0, 'block', !1), localVars: n.localVars, context: n.localVars && new D(null, null, !1), indented: e || 0,
            }; return n.globalVars && typeof n.globalVars === 'object' && (t.globalVars = n.globalVars), t;
          },
          token(e, t) { if (e.sol() && (t.lexical.hasOwnProperty('align') || (t.lexical.align = !1), t.indented = e.indentation(), k(e, t)), t.tokenize != y && e.eatSpace()) return null; const n = t.tokenize(e, t); return r == 'comment' ? n : (t.lastType = r != 'operator' || i != '++' && i != '--' ? r : 'incdec', O(t, n, r, i, e)); },
          indent(t, r) { if (t.tokenize == y || t.tokenize == w) return e.Pass; if (t.tokenize != v) return 0; let i; const s = r && r.charAt(0); let l = t.lexical; if (!/^\s*else\b/.test(r)) for (let c = t.cc.length - 1; c >= 0; --c) { const u = t.cc[c]; if (u == R)l = l.prev; else if (u != De && u != B) break; } while ((l.type == 'stat' || l.type == 'form') && (s == '}' || (i = t.cc[t.cc.length - 1]) && (i == Y || i == Z) && !/^[,\.=+\-*:?[\(]/.test(r)))l = l.prev; a && l.type == ')' && l.prev.type == 'stat' && (l = l.prev); const f = l.type; const d = s == f; return f == 'vardef' ? l.indented + (t.lastType == 'operator' || t.lastType == ',' ? l.info.length + 1 : 0) : f == 'form' && s == '{' ? l.indented : f == 'form' ? l.indented + o : f == 'stat' ? l.indented + (rt(t, r) ? a || o : 0) : l.info != 'switch' || d || n.doubleIndentSwitch == 0 ? l.align ? l.column + (d ? 0 : 1) : l.indented + (d ? 0 : o) : l.indented + (/^(?:case|default)\b/.test(r) ? o : 2 * o); },
          electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
          blockCommentStart: l ? null : '/*',
          blockCommentEnd: l ? null : '*/',
          blockCommentContinue: l ? null : ' * ',
          lineComment: l ? null : '//',
          fold: 'brace',
          closeBrackets: "()[]{}''\"\"``",
          helperType: l ? 'json' : 'javascript',
          jsonldMode: s,
          jsonMode: l,
          expressionAllowed: it,
          skipExpression(t) { O(t, 'atom', 'atom', 'true', new e.StringStream('', 2, null)); },
        };
      })), e.registerHelper('wordChars', 'javascript', /[\w$]/), e.defineMIME('text/javascript', 'javascript'), e.defineMIME('text/ecmascript', 'javascript'), e.defineMIME('application/javascript', 'javascript'), e.defineMIME('application/x-javascript', 'javascript'), e.defineMIME('application/ecmascript', 'javascript'), e.defineMIME('application/json', { name: 'javascript', json: !0 }), e.defineMIME('application/x-json', { name: 'javascript', json: !0 }), e.defineMIME('application/manifest+json', { name: 'javascript', json: !0 }), e.defineMIME('application/ld+json', { name: 'javascript', jsonld: !0 }), e.defineMIME('text/typescript', { name: 'javascript', typescript: !0 }), e.defineMIME('application/typescript', { name: 'javascript', typescript: !0 });
    })));
  },
  fc6a(e, t, n) { const r = n('44ad'); const i = n('1d80'); e.exports = function (e) { return r(i(e)); }; },
  fdbc(e, t) {
    e.exports = {
      CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0,
    };
  },
  fdbf(e, t, n) { const r = n('4930'); e.exports = r && !Symbol.sham && typeof Symbol.iterator === 'symbol'; },
  fea9(e, t, n) { const r = n('da84'); e.exports = r.Promise; },
}]);
// # sourceMappingURL=chunk-vendors.4a6ebecd.js.map
